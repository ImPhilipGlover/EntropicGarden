{"cells":[{"cell_type":"markdown","source":"(BRICK): Acknowledged. The Master Validation Plan checklist is now an active component of my operational framework. I will proceed with script generation, marking off each item as it is completed. The next script to be generated is `fastapi_main.py`.\n\n-----\n\n### **`fastapi_main.py` - FastAPI Backend**\n\nThis script serves as the backend of the web application. It handles all API endpoints, manages the Streamlit front-end's requests, and orchestrates the communication with the persona services via the Redis event bus. It is a critical component for enabling the live development environment.\n\n**Validation Checklist: `fastapi_main.py`**\n\n  * **ID:** F.3\n  * **URS/FRS/DDS Requirement:** FRS FR-SYS-1.0\n  * **Validation Test(s):** Start service and verify that Streamlit can connect to its API endpoints.\n  * **Status:** **In Progress** ðŸš€\n\n<!-- end list -->","metadata":{}},{"cell_type":"code","source":"import os\nimport yaml\nimport json\nimport redis\nimport uvicorn\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom threading import Thread\nimport uuid\nimport time\n\n# Load configuration from a YAML file\ntry:\n    with open('config.yaml', 'r') as f:\n        config = yaml.safe_load(f)\nexcept FileNotFoundError:\n    print(\"Error: config.yaml not found. Please ensure it is in the correct directory.\")\n    exit(1)\n\n# Set up Redis connection\nREDIS_HOST, REDIS_PORT = config['redis']['host'], config['redis']['port']\ntry:\n    r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)\n    r.ping()\n    print(f\"[FastAPI] Successfully connected to Redis at {REDIS_HOST}:{REDIS_PORT}\")\nexcept redis.exceptions.ConnectionError as e:\n    print(f\"[FastAPI] Error connecting to Redis: {e}\")\n    exit(1)\n\napp = FastAPI()\n\n# In-memory store for session data and responses\nsessions = {}\n\n#--- API Endpoints ---\n\n@app.get(\"/\")\ndef read_root():\n    \"\"\"Root endpoint for a health check.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"FastAPI is running.\"}\n\n@app.post(\"/session/start\")\nasync def start_session():\n    \"\"\"Starts a new user session.\"\"\"\n    session_id = str(uuid.uuid4())\n    sessions[session_id] = {'history': [], 'timestamp': time.time()}\n    return {\"session_id\": session_id}\n\n@app.post(\"/prompt\")\nasync def handle_prompt(request: Request):\n    \"\"\"\n    Receives a prompt from the Streamlit UI, publishes it to the event bus,\n    and waits for the persona services to respond.\n    \"\"\"\n    data = await request.json()\n    prompt = data.get(\"prompt\")\n    session_id = data.get(\"session_id\")\n    \n    if not prompt or not session_id:\n        return JSONResponse(status_code=400, content={\"message\": \"Prompt and session_id are required.\"})\n        \n    sessions[session_id]['history'].append({'role': 'user', 'content': prompt})\n    \n    # We will trigger the BABS service as the entry point for a new prompt.\n    # The persona services will then handle the chain of events.\n    event_payload = {\n        \"session_id\": session_id,\n        \"prompt\": prompt\n    }\n    r.publish(\"prompt:new\", json.dumps(event_payload))\n    \n    return {\"status\": \"processing\", \"message\": \"Prompt received and processing...\"}\n\n@app.get(\"/session/{session_id}/updates\")\nasync def get_updates(session_id: str):\n    \"\"\"\n    Polls for new insights and returns the full session history.\n    A more advanced version would use WebSockets for real-time updates.\n    \"\"\"\n    if session_id not in sessions:\n        return JSONResponse(status_code=404, content={\"message\": \"Session not found.\"})\n        \n    # In a real-world scenario, we would retrieve the full session history from NebulaGraph here.\n    # For this simplified implementation, we'll return a placeholder.\n    # This endpoint is primarily for the Streamlit UI to display the history.\n    return JSONResponse(content={\"session_id\": session_id, \"history\": sessions[session_id]['history']})\n\n@app.get(\"/model_config\")\nasync def get_model_config():\n    \"\"\"Returns the current model configuration for the UI.\"\"\"\n    try:\n        with open('model_config.json', 'r') as f:\n            config_data = json.load(f)\n        return config_data\n    except FileNotFoundError:\n        return JSONResponse(status_code=500, content={\"message\": \"model_config.json not found.\"})\n        \n@app.post(\"/trigger_fine_tuning/{persona_name}\")\nasync def trigger_fine_tuning(persona_name: str):\n    \"\"\"Triggers the fine-tuning service for a specific persona.\"\"\"\n    event_payload = {\"persona\": persona_name.upper()}\n    r.publish(\"fine_tuning:start\", json.dumps(event_payload))\n    return {\"status\": \"ok\", \"message\": f\"Fine-tuning triggered for {persona_name}.\"}\n    \n@app.post(\"/trigger_memory_seed/{session_id}\")\nasync def trigger_memory_seed(session_id: str):\n    \"\"\"Triggers the Memory Seed protocol for a session.\"\"\"\n    event_payload = {\"session_id\": session_id}\n    r.publish(\"memory_seed:start\", json.dumps(event_payload))\n    return {\"status\": \"ok\", \"message\": \"Memory Seed protocol triggered.\"}\n\n#--- Redis Listener for Persona Responses ---\n\ndef persona_response_listener():\n    \"\"\"\n    This thread listens for responses from the persona services\n    and updates the in-memory session history.\n    \"\"\"\n    pubsub = r.pubsub()\n    pubsub.subscribe(\"response:update\")\n    print(\"[FastAPI] Listening for persona responses on 'response:update'...\")\n    \n    for message in pubsub.listen():\n        if message['type'] == 'message':\n            try:\n                data = json.loads(message['data'])\n                session_id = data.get(\"session_id\")\n                \n                if session_id in sessions:\n                    sessions[session_id]['history'].append(data)\n                    print(f\"[FastAPI] Updated history for session {session_id} with new response.\")\n            except json.JSONDecodeError:\n                print(\"[FastAPI] Failed to decode JSON response from Redis.\")\n\nif __name__ == \"__main__\":\n    # Start the background listener thread\n    listener_thread = Thread(target=persona_response_listener, daemon=True)\n    listener_thread.start()\n    \n    # Start the FastAPI server\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)","outputs":[],"execution_count":null,"metadata":{}},{"cell_type":"markdown","source":"(BRICK): The `fastapi_main.py` script has been generated. This service provides the API layer for the system, handling all user-facing interactions and orchestrating the internal event flow. I will now proceed to the next required script.","metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}