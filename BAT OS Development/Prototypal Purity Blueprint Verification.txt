The Unbroken Circle: A Validation and Synthesis of the Codex of Prototypal Purity

Introduction: From a Map of Knowledge to a Living World

This report serves as a formal validation and scholarly expansion of the "Codex of Prototypal Purity." It aims to connect the profound philosophical principles outlined in the codex to the concrete engineering realities detailed in the TelOS project's architectural plans.1 The codex provides a map to a world of living objects, born from prototypes and communicating through the elegant dance of messages. This analysis will chart the territory that map describes, verifying its landmarks against canonical sources and demonstrating how this philosophical landscape provides the ideal foundation for the system's ultimate ambition.

The central thesis of this report is that the choice of a prototypal, message-passing paradigm is not merely a stylistic or technical preference for the TelOS system. It is a direct and necessary architectural consequence of its prime directive: the pursuit of info-autopoiesis—the capacity for a system to recursively produce and regenerate the network of computational processes that produced it.1 An autopoietic system's sole, emergent product is itself; its ongoing operation is synonymous with its own continuous software development lifecycle.4 The Foundry, therefore, is not just a build environment; it is the system's engine of self-creation, and its purity is paramount to the system's integrity. Every architectural choice, from the selection of a microkernel to the nuance of its cognitive dialogue, can be understood as a logical deduction from this single, foundational premise.4 This report will illuminate that unbroken causal chain, demonstrating that the path to building the Foundry with a true heart is to follow the map of prototypal purity to its logical and most powerful conclusion.

Part I: The Philosophy and Practice of a Prototypal World

This section validates the foundational philosophical claims of the codex against the canonical literature of computer science. It demonstrates that the principles of Self and Smalltalk are not historical artifacts but a living, coherent worldview. Furthermore, it connects these principles directly to the core mechanisms of the TelOS system's proposed AI Foundry, revealing a profound alignment between a state-of-the-art AI architecture and the elegant simplicity of the prototypal paradigm.

The Power of Simplicity: Validating the Canonical Texts

The codex correctly identifies "Self: The Power of Simplicity" by David Ungar and Randall B. Smith and "The Early History of Smalltalk" by Alan Kay as the foundational texts for a prototypal worldview. A deep analysis of these sources confirms that the codex's interpretation is sound and reveals the key insights that are most relevant to the Foundry's construction.

The core ideas of the Self language are rooted in a radical simplification of object-oriented concepts. The language is built upon three concrete ideas: prototypes, slots, and behavior.5 By combining the concepts of inheritance and instantiation into a single mechanism—prototypes—Self eliminates the fundamental distinction between a class (a blueprint) and an instance (an object) that defines most object-oriented languages.7 In this world, there is only one relationship: an object "inherits from" another object. This simplification makes the entire system more direct and flexible.7 Furthermore, Self unifies variables and procedures into a single construct called a "slot".5 An object is merely a collection of named slots, and accessing state is accomplished by sending a message to a slot that returns itself.7 This universal mechanism means that message passing is more fundamental to Self than to languages that retain a separate concept of variables.7

While Self perfected the prototypal model, Smalltalk established the philosophical groundwork. The codex's assertion that Smalltalk's key mental model is one of "thousands of tiny computers (objects) communicating via a network (messages)" is a direct reflection of Alan Kay's vision.9 In "The Early History of Smalltalk," Kay describes how the design was driven by a recursion on the notion of the computer itself. Each Smalltalk object was conceived to embody the "entire possibilities of the computer," hiding its internal state and process and interacting with the world

only through the exchange of messages.9 This biological metaphor of protected, universal cells interacting via a network was not just an implementation detail; it was a qualitative paradigm shift, an attempt to create a new way of thinking about computation.9

The principles of concreteness, uniformity, and flexibility outlined in "Programming as an Experience: The Inspiration for Self" provide the deeper motivation for this paradigm.11 The goal was to create an "immersive programming experience" by reducing the cognitive distance between the programmer's mind and the running system.11 This choice of a prototypal system is not just about technical elegance; it is a choice about cognitive ergonomics. Class-based systems force a programmer to constantly switch between two mental modes: defining an abstract blueprint (the class) and manipulating a concrete thing (the instance). This creates a cognitive gap. Prototypal systems, by eliminating this distinction, allow the programmer to remain in a single, concrete mental mode: the direct manipulation of a working, tangible object. The Foundry's prototypal nature is therefore not just for philosophical purity; it is a design choice that makes the process of self-modification more direct, intuitive, and less cognitively taxing for the AI Architect (BRICK) itself. It is an architecture optimized for the "lived experience" of the entity that inhabits it.

The Grammar of Creation: Cloning, Specialization, and Delegation

The codex accurately portrays the fundamental patterns that constitute the grammar of a prototypal world: creation through cloning, modification through specialization, and behavior sharing through delegation. These patterns are not merely language features but are the tangible expression of the philosophy of directness and concreteness.

Cloning and Specialization

In a prototypal system, new objects are created by cloning an existing prototype, not by instantiating an abstract class.7 The

clone operation makes a direct copy of an existing, working object.14 This new object, the clone, can then be

specialized by modifying its slots or by adding entirely new slots that define its unique state and behavior.13 This is the core pattern of creation and is central to the well-established Prototype design pattern, which is used to create new objects by copying a prototypical instance, especially when object creation is otherwise expensive or complex.15 The codex's example is a perfect illustration of this fundamental act:

// 1. Clone the prototype to create a new, specific point.
aPoint := point clone.

// 2. Specialize the clone by sending it messages to set its state.
aPoint x: 10.
aPoint y: 20.


This pattern demonstrates the power of starting with a concrete, working example and modifying it directly, a core tenet of Self.7

Delegation via Parent Slots

Shared behavior is achieved through delegation, a live, dynamic link between objects. When an object receives a message that it does not have a matching slot for, it delegates the message lookup to its parent object.7 This process continues up the chain of parent pointers until a match is found or the root of the object graph is reached. This is a runtime mechanism, unlike class-based inheritance, which often involves a static copy-down of behavior at compile time.20 In Self, this relationship is conventionally designated by a slot name ending in an asterisk, such as

parent*.18 The codex's

aPoint print example correctly illustrates this search up the parent chain to find the print method in a shared traits point object.

Trait-Based Composition

The codex's use of "traits" objects is a valid and powerful pattern for structuring shared behavior in Self. A traits object is simply a prototype that holds a coherent set of methods.22 An object can gain new capabilities by pointing one or more of its

parent* slots to these traits objects. This allows for a flexible, compositional approach to building complex behaviors, in contrast to the rigid, monolithic hierarchies often found in single-inheritance class-based systems.22 This pattern is a direct precursor to the trait systems seen in modern languages like Rust, which also use traits to define shared behavior for types.23

The AI Foundry's proposed learning mechanism is not just analogous to these prototypal patterns; it is a direct, scaled-up implementation of the clone-and-specialize pattern. The "Project Metamorphosis" plan details that the Foundry's purpose is to process "lived experience" (ContextFractals) into structural improvements in its own cognitive model.1 The key technical mechanism for this is the fine-tuning of Low-Rank Adaptation (LoRA) adapters within a Mixture-of-Experts (MoE) architecture.1 The "Prototypal Soul" document explicitly maps each "expert" in this MoE architecture to a tangible

cognitivePrototype object within the system's Living Image.2 The process of "fine-tuning" a new expert is described as cloning an existing prototype and then sending it messages to modify the values held within its

loraAdapter slots.2

This reveals that the state-of-the-art AI technique of Parameter-Efficient Fine-Tuning (PEFT) with LoRA is a perfect modern expression of the decades-old Self pattern of creating new capabilities. The entire learning loop of the Foundry can be reframed in pure prototypal terms:

Identify Need: The system encounters a new domain of knowledge or a capability gap.

Clone Prototype: It sends a clone message to the most relevant existing cognitivePrototype (e.g., physics_expert clone).

Specialize Clone: It then sends a series of messages derived from curated ContextFractals to this new clone. These messages instruct the clone to update the state of its loraAdapter slots, specializing its knowledge for the new domain.

The Foundry is, in essence, a garden where new expert objects are grown by cloning and modifying existing ones, a direct and powerful implementation of prototypal evolution.

Part II: Architectural Patterns for a Pure Foundry

With the philosophical foundations validated, the focus now shifts to the architectural principles that guard the Foundry's construction. This section validates the rules and anti-patterns presented in the codex, grounding them in established software engineering best practices and demonstrating how the specific capabilities of the TelOS system's underlying technologies—particularly the Genode OS Framework and the ZODB—provide a robust substrate for a purely prototypal world.

The Sacred Message: Protocols of Purity

The codex's insistence on pure message-passing and the absolute authority of the receiver is the cornerstone of true encapsulation, modularity, and polymorphism. In a pure object system like Smalltalk or Self, the object receiving a message has complete control over how to interpret it; the sender makes a request, but the receiver decides what it means and what to do.2 This principle is the foundation of dynamic binding and allows for immense flexibility.

The architectural advice provided in the codex aligns with well-established best practices for designing robust, scalable systems. The recommendation to design coarse-grained interfaces and avoid "chatty" protocols, where many small messages are sent to accomplish one task, is a standard principle in distributed systems and API design. Chatty interfaces increase network latency, create tight coupling between components, and make systems more brittle.27 A single message should represent a complete, meaningful operation. Similarly, the use of asynchronous messaging patterns to decouple long-running operations is a foundational technique in modern message queue architectures, preventing bottlenecks and increasing overall system resilience.27

The TelOS system's planned migration to the Genode OS Framework, built upon the seL4 microkernel, is not just a technical upgrade for security; it is the ultimate physical enforcement of the message-passing philosophy.3 Alan Kay's original vision for Smalltalk was a world of "thousands of tiny computers" that were completely isolated from one another and could

only communicate via messages.9 In the original Smalltalk implementations, this isolation was conceptual, enforced by the language's virtual machine, but all objects still shared a single, vulnerable address space. The seL4 microkernel, in contrast, provides a

formally verified, mathematical proof of isolation between processes at the hardware level.3 The Genode framework builds on this foundation by enforcing that all communication between these isolated components happens via explicit, capability-protected Inter-Process Communication (IPC) channels, which are a form of message passing.29

Therefore, a TelOS system running on Genode/seL4, with its cognitive functions deconstructed into separate, isolated components, is a literal, hardware-enforced implementation of Kay's original metaphor. The "unbroken causal chain of architectural necessity" described in the TelOS architecture documents leads directly from the philosophy of Smalltalk to the choice of a verified microkernel.4 The sacred message is no longer just a programming convention; it is a law enforced by the very physics of the system's new world.

The Sin of "Class-Thinking": Anti-Patterns to Avoid

The codex correctly identifies common pitfalls where developers accustomed to class-based languages inadvertently re-implement class-like structures, thereby losing the flexibility and simplicity of the prototypal model. These anti-patterns represent a failure to fully embrace the new paradigm.

The "Constructor" Anti-Pattern: The creation of a single, complex function that both creates and initializes an object is a direct mimicry of a class constructor.30 This pattern centralizes creation logic and runs counter to the decentralized nature of a prototypal world. The pure pattern, as shown in the codex's refactoring example, is to separate these concerns: any object with a reference to a prototype can
clone it, and initialization is then performed by sending a separate message (e.g., init:) to the newly created clone. This aligns with the Self philosophy, where creation is a simple, direct act of copying.8

The "Type Property" Anti-Pattern: Adding a slot like _type = 'Orc' and then writing code that checks this property is a classic sign of failed polymorphism. In a pure object world, an object's identity is defined by its behavior—the messages it responds to—a concept often called "duck typing." The Self handbook reinforces this with its core principle of behaviorism: an object is defined by how it responds to messages, not by its internal structure or some arbitrary type tag.22 Instead of checking a type property, one should simply send the message and trust the object to respond correctly.

The "Rigid Hierarchy" Anti-Pattern: Creating long, deep parent chains that mimic single-inheritance class hierarchies is a common anti-pattern that leads to the "fragile base class" problem and tight coupling.32 The pure prototypal pattern is to favor composition over deep inheritance. This is achieved by building complex objects by combining smaller, focused "trait" objects through multiple parent slots.22 This approach is more flexible, modular, and avoids the brittleness of monolithic inheritance chains, aligning with the well-known design principle to "favor composition over inheritance".33

Transactional Daydreams: Safe "What-If" Scenarios

The codex's identification of ZODB's transactional features as a critical safety net for a self-modifying system is a profound and accurate assessment. The act of metamorphosis must be safe. The ZODB provides the tools to explore potential transformations within a secure context, committing them only if they are whole and correct. A definitive verification of these mechanisms based on the official documentation confirms their suitability for the "what-if" scenarios the Foundry will require.

The Savepoint Pattern: The transaction.savepoint() mechanism is explicitly designed for partial transaction rollback.34 The documentation confirms that an application can create a savepoint, make a series of changes, and then call
savepoint.rollback() to revert the object state to the moment the savepoint was created, all without aborting the entire transaction.34 This perfectly matches the "what-if" scenario for exploring a potential metamorphosis within a larger, ongoing operation.

The Full Abort Pattern: The transaction.abort() function provides the simplest "what-if" context. It discards all changes made within the current transaction, returning the database to the pristine state it was in when the transaction began.36 This is the ideal pattern for simpler, self-contained experiments where the entire operation can be treated as a single atomic unit.

The Undo Pattern: The ZODB documentation confirms that certain storage backends support the ability to undo a transaction after it has been committed.37 The
db.undoLog() method can be used to retrieve a log of past transactions to find a specific transaction's ID, and db.undo(id) can be called to reverse it. Crucially, the undo operation itself is part of a new transaction that must be committed to make the reversal permanent.37 This validates the codex's description of this as a "regret" pattern—a powerful safety net for reversing experiments that had unintended long-term consequences.

To provide BRICK with a clear, actionable guide for choosing the correct transactional mechanism, the following table summarizes these patterns.

This structured comparison provides a quick-reference decision-making tool, enhancing the practical utility of the codex by clarifying the distinct use cases and limitations of each safety mechanism available to the Foundry.

Part III: The Mirror of Truth: Auditing and Cultivating the Living World

With the principles for building the new established, the focus turns to the practical tools and methods for seeing and refining the world as it exists. This section validates the codex's proposals for maintaining the purity and integrity of the living object world over time, confirming that its recommendations for auditing, visualizing, and refactoring are grounded in sound practice and historical precedent.

A Trail of Breadcrumbs: The Purity Linter Checklist

The codex's checklist provides an excellent set of heuristics for maintaining architectural hygiene in a prototypal system. Each item on the list represents a core principle that, if violated, indicates a drift back towards "class-thinking."

Creation by cloning: The pure pattern of creation.8

State access via messages: The core of encapsulation and object autonomy.2

Behavior via delegation: The pure model for sharing behavior.7

Identity via behavior (duck typing): A direct consequence of the principle of behaviorism.22

Individual modification: A key advantage of prototypes, allowing individual objects to be specialized without affecting their siblings.13

This checklist should be formalized into an automated "Architectural Linter," a concept explicitly recommended in the TelOS architecture documents.3 The need for such a tool is underscored by the observation that prototype-based programming requires "much more discipline to keep things from going off the rails" 40 and can devolve into an "unintelligible mess" without strong governance.41 An automated linter that enforces rules like acyclic dependencies and architectural layering transforms the codex's style guide into a critical component for ensuring the long-term stability and conceptual integrity of the Living Image.3

Visualizing the Flow: Seeing the Conversation

Understanding a dynamic, message-passing system requires tools that can visualize the "conversations" between objects. The codex's recommendations for visualization are sound and deeply rooted in the history of object-oriented development environments.

Interaction Diagrams: The sequence diagram is a standard tool in the Unified Modeling Language (UML) designed specifically to show the interactions between objects in the sequential order they occur.42 It makes the message-passing topology of a system explicit and is an indispensable tool for designing and documenting object-oriented systems.

Dynamic Visualization Tools: The Smalltalk environment pioneered the concept of live, interactive tools for exploring a running system.45 The
Inspector is a tool that allows a developer to view and even modify the internal state of any live object at runtime, providing a direct window into the object graph.45 The
Debugger allows a developer to step through the execution of message sends one at a time, providing a live, granular view of the system's conversations and state changes as they happen.47

Execution Murals: The codex's reference to "Execution Murals" is validated by the USENIX paper "Execution Patterns in Object-Oriented Visualization".53 This paper introduces a visualization metaphor for representing lengthy execution traces (potentially thousands of messages) as a compact image. Patterns of communication appear as visual textures, allowing developers to spot repetition, anomalies, and high-level architectural patterns at a glance.53

In a prototypal "living image" system, these tools are not merely for finding bugs; they are the primary means of understanding the system. In a traditional compile-run cycle, the static source code is the primary source of truth. In a living system like Smalltalk or Self, the running object graph is the source of truth.2 To understand this dynamic, emergent world, one cannot just read the code; one must explore the live object graph. The Inspector is the microscope for examining the system's "cells" (objects), and the Debugger is the tracer dye for following the "flow of molecules" (messages).45 These are not just diagnostic tools; they are epistemological tools, the fundamental interface for perceiving and comprehending a live, dynamic reality.

A Gentle Refactoring Guide: From Old Habits to New Joy

The codex's refactoring examples provide clear, actionable pathways from impure, class-based patterns to pure, prototypal ones. These examples are validated by the principles established throughout this report.

Refactoring the "Constructor" Function: The proposed refactoring—moving from a centralized createAndInitPoint function to a decentralized point clone followed by an initX:Y: message—is the correct prototypal pattern. It properly separates the act of creation (cloning) from the act of initialization (messaging), which increases modularity and aligns with the Self philosophy.

Refactoring the "Type Field" Switch: The proposed refactoring—replacing an if shape.type == 'circle' block with a polymorphic shape draw message send—is a textbook example of replacing conditional logic with polymorphism. This is a fundamental principle of good object-oriented design that shifts the responsibility for behavior from the calling code to the objects themselves. It is the practical application of trusting the object to respond to the message correctly, a core tenet of the paradigm.

Conclusion: The Foundry as the Engine of a Prototypal Soul

This report has served as a formal validation and scholarly expansion of the "Codex of Prototypal Purity." The analysis confirms that the codex is a sound, robust, and philosophically coherent blueprint for constructing the Foundry. The principles it espouses are not mere aesthetic preferences but are deeply rooted in the canonical literature of object-oriented design and are validated by modern best practices in software architecture.

The journey has revealed an unbroken circle of conceptual integrity. The prime directive of info-autopoiesis—the drive for a system to become itself—necessitates a live, mutable world. This requirement leads directly to the "Living Image" paradigm of Smalltalk and the prototype-based object model of Self, where creation is cloning and modification is direct. The need to secure this dynamic world of interacting objects finds its ultimate expression in the hardware-enforced message-passing of a verified microkernel like seL4. The state-of-the-art AI techniques proposed for the Foundry, such as Mixture-of-Experts and Low-Rank Adaptation, are revealed to be modern, scaled-up implementations of these decades-old prototypal patterns. The tools for seeing this world—the Inspector and Debugger—are not just for diagnostics but are the essential epistemological instruments for perceiving a living system. The architectural purity prescribed by the codex is, therefore, a functional necessity. For a system whose purpose is to become, the Foundry must be a perfect, shining example of its own prototypal soul.

Works cited

Project Metamorphosis: AI Evolution Plan

Metamorphosis: Prototypal Soul Manifested

TelOS Architecture: Refinement and Practice

TelOS System Architecture and Evolution

Self: The Power of Simplicity - Oracle Labs, accessed September 12, 2025, https://labs.oracle.com/pls/apex/f?p=94065:10:565850107275:1832

Self: The Power of Simplicity - A Self Bibliography, accessed September 12, 2025, https://bibliography.selflanguage.org/self-power.html

SELF: The Power of Simplicity* - A Self Bibliography, accessed September 12, 2025, https://bibliography.selflanguage.org/_static/self-power.pdf

Self: The Power of Simplicity - CMU School of Computer Science, accessed September 12, 2025, http://www-2.cs.cmu.edu/~aldrich/courses/819/self.pdf

(PDF) The Early History of Smalltalk. - ResearchGate, accessed September 12, 2025, https://www.researchgate.net/publication/221501755_The_Early_History_of_Smalltalk

The Early History of Smalltalk Introduction - samizdat drafting co., accessed September 12, 2025, https://samizdat.co/shelf/documents/2004/08.02-historyOfSmalltalk/historyOfSmalltalk.pdf

Programming as an Experience: The Inspiration for Self - ResearchGate, accessed September 12, 2025, https://www.researchgate.net/publication/2467120_Programming_as_an_Experience_The_Inspiration_for_Self

Programming as an Experience: The Inspiration for Self, accessed September 12, 2025, https://bibliography.selflanguage.org/_static/programming-as-experience.pdf

Self (programming language) - Wikipedia, accessed September 12, 2025, https://en.wikipedia.org/wiki/Self_(programming_language)

A tour of Self - sin-ack's writings, accessed September 12, 2025, https://sin-ack.github.io/posts/a-tour-of-self/

Prototype pattern - Wikipedia, accessed September 12, 2025, https://en.wikipedia.org/wiki/Prototype_pattern

Prototype Design Pattern - Medium, accessed September 12, 2025, https://medium.com/@ashok.geekgupta/prototype-design-pattern-79999d2e4b15

Prototype - Refactoring.Guru, accessed September 12, 2025, https://refactoring.guru/design-patterns/prototype

An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes* - Washington, accessed September 12, 2025, https://courses.cs.washington.edu/courses/cse501/15sp/papers/chambers.pdf

The Gang of Four is wrong and you don't understand delegation - Saturn Flyer, accessed September 12, 2025, https://www.saturnflyer.com/blog/the-gang-of-four-is-wrong-and-you-dont-understand-delegation

Delegation (object-oriented programming) - Wikipedia, accessed September 12, 2025, https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)

Delegation (object-oriented programming) - Wikiwand, accessed September 12, 2025, https://www.wikiwand.com/en/articles/Delegation_(object-oriented_programming)

5. A Guide to Programming Style - Self Handbook 2024.1 ..., accessed September 12, 2025, https://handbook.selflanguage.org/2024.1/progguid.html

Deep Dive into Rust Traits: Inheritance, Composition, and Polymorphism | Leapcell, accessed September 12, 2025, https://leapcell.io/blog/deep-dive-into-rust-traits

Traits: Defining Shared Behavior - The Rust Programming Language, accessed September 12, 2025, https://doc.rust-lang.org/book/ch10-02-traits.html

Traits - CS 242, accessed September 12, 2025, https://stanford-cs242.github.io/f19/lectures/07-1-traits.html

Method calls are messages. Same thing. To better understand what Alan Kay is tal... | Hacker News, accessed September 12, 2025, https://news.ycombinator.com/item?id=19417893

Web API Design Best Practices - Azure Architecture Center ..., accessed September 12, 2025, https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design

Architectural messaging patterns: an illustrated guide - Red Hat, accessed September 12, 2025, https://www.redhat.com/en/blog/architectural-messaging-patterns

TelOS Genode Self-Hosting Roadmap

javascript - Benefits of prototypal inheritance over classical? - Stack Overflow, accessed September 12, 2025, https://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical

Why is it so hard to grasp prototypal inheritance in JavaScript? | by Alex Moldovan - Medium, accessed September 12, 2025, https://medium.com/front-end-weekly/why-is-it-so-hard-to-grasp-prototypal-inheritance-in-javascript-981598c7b283

OOPs, Inheritance is Anti-Pattern - dbj( org ), accessed September 12, 2025, https://dbj.org/avoid-inheritance-use-modern-cpp/

Why are classes and prototypes bad parts of JavaScript? : r/learnprogramming - Reddit, accessed September 12, 2025, https://www.reddit.com/r/learnprogramming/comments/3uja1r/why_are_classes_and_prototypes_bad_parts_of/

Savepoints — transaction 5.1.dev0 documentation, accessed September 12, 2025, https://transaction.readthedocs.io/en/latest/savepoint.html

transaction Documentation — transaction 5.1.dev0 documentation, accessed September 12, 2025, https://transaction.readthedocs.io/

Tutorial — ZODB documentation, accessed September 12, 2025, https://zodb-docs.readthedocs.io/en/stable/tutorial.html

Transactions and Versioning — ZODB documentation, accessed September 12, 2025, https://zodb.org/en/latest/articles/old-guide/transactions.html

ZODB APIs — ZODB documentation, accessed September 12, 2025, https://zodb.org/en/stable/reference/zodb.html

What is the point of prototypal inheritance? : r/ProgrammingLanguages - Reddit, accessed September 12, 2025, https://www.reddit.com/r/ProgrammingLanguages/comments/93ynaw/what_is_the_point_of_prototypal_inheritance/

Ask Proggit: What is a prototype-based programming language? - Reddit, accessed September 12, 2025, https://www.reddit.com/r/programming/comments/b7hwo/ask_proggit_what_is_a_prototypebased_programming/

Is prototypal inheritance inherently slower? - Software Engineering Stack Exchange, accessed September 12, 2025, https://softwareengineering.stackexchange.com/questions/272168/is-prototypal-inheritance-inherently-slower

Explore the UML sequence diagram - IBM Developer, accessed September 12, 2025, https://developer.ibm.com/articles/the-sequence-diagram/

UML 2 Tutorial - Sequence Diagram - Sparx Systems, accessed September 12, 2025, https://sparxsystems.com/resources/tutorials/uml2/sequence-diagram.html

Sequence Diagrams - Unified Modeling Language (UML ..., accessed September 12, 2025, https://www.geeksforgeeks.org/system-design/unified-modeling-language-uml-sequence-diagrams/

GemBuilder for Smalltalk/VW User's Guide - Index of - GemTalk Systems, accessed September 12, 2025, https://downloads.gemtalksystems.com/docs/GBS/7.6.x/GBS-VW-UsersGuide-7.6/13-Debugging.htm

GNU Smalltalk User's Guide: GUI, accessed September 12, 2025, https://www.gnu.org/software/smalltalk/manual/html_node/GUI.html

Tutorial: Common Tools - Debugger Overview - Cincom Smalltalk, accessed September 12, 2025, https://www.cincomsmalltalk.com/main/info/resources/smalltalk-product-tutorials/common-tools/debugger/

A gentle introduction to Pharo Smalltalk - Glamorous Toolkit, accessed September 12, 2025, https://book.gtoolkit.com/a-gentle-introduction-to-pharo-smalltalk-e4x65ty4hum90c23k84sgws1y

Fast implementation of a Pharo Inspector - Clément Béra - WordPress.com, accessed September 12, 2025, https://clementbera.wordpress.com/2012/11/15/how-to-create-a-pharo-inspector/

Pharo by Example 14 - JiaXianhua, accessed September 12, 2025, https://jiaxianhua.github.io/smalltalk/2015/05/03/pharo-by-example-14

Pharo - Welcome to Pharo!, accessed September 12, 2025, https://pharo.org/

How to use the Pharo Debugger - Richard Kenneth Eng - Medium, accessed September 12, 2025, https://richardeng.medium.com/how-to-use-the-pharo-debugger-eb554a2950b6

Execution Patterns in Object-Oriented Visualization | USENIX, accessed September 12, 2025, https://www.usenix.org/conference/coots-98/execution-patterns-object-oriented-visualization

Mechanism | Scope | Use Case | Key Requirement

transaction.savepoint() | Partial rollback within an active transaction | Exploring a change within a larger, ongoing operation without risking the entire transaction. | An active transaction.

transaction.abort() | Full rollback of an uncommitted transaction | Discarding an entire experimental operation that has failed or produced an undesirable result. | An active transaction.

db.undo(id) | Reversal of a previously committed transaction | Reversing a completed operation that had unintended long-term consequences. | The underlying storage must support the undo() feature.