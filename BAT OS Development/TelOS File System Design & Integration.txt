An Architectural Blueprint for the Persistence Substrate of an Autopoietic Operating System

Part I: Deconstructing the Mandate: From "File System" to a Dual-Mode Persistence Architecture

This foundational analysis addresses the architectural challenge of designing a storage substrate for a system conceived as an autopoietic (self-producing) entity. A surface-level interpretation of a "file system" requirement would lead to conventional solutions that are fundamentally incompatible with the system's constitutional principles. A deep synthesis of the project's architectural documents reveals that the system, referred to as TelOS, is predicated on a philosophy that initiates an unbreakable causal chain of design, logically forbidding a traditional file system for the management of its core state.1 The only viable solution is a dual-mode persistence architecture, comprising a novel

Internal Substrate to embody the system's live, mutable state, and a pragmatic External Substrate to provide a secure bridge to the external world of block devices and legacy software.

The Autopoietic Imperative vs. The Static File: An Unbroken Causal Chain

The core architecture of the TelOS system is not a collection of independent engineering preferences but a cascade of logical deductions derived from a single, immutable axiom: the pursuit of info-autopoiesis.1 This principle, a translation of the biological theory of autopoiesis formulated by Maturana and Varela to the informational domain, defines the system's primary product as the continuous, recursive regeneration of its own operational logic and worldview.1 This prime directive establishes the system's fundamental physics and initiates the causal chain that dictates its entire architecture.

The first and most critical consequence of this directive is the mandate for Organizational Closure (Constraint 3).7 This principle requires that all core operating system components—the scheduler, the memory manager, the process server—must not be static, pre-compiled artifacts. Instead, they must be dynamic, regenerable objects within the system itself, capable of being modified and replaced by other system processes while the system is running.14 This mandate for a "continuous, unbroken process of its own becoming" 13 is architecturally irreconcilable with conventional, static, file-based persistence models. A traditional file system stores programs and data as inert artifacts; to apply a change to a core OS component, the system must be halted, the file must be replaced by an external agent, and the system must be restarted. This act fundamentally breaches the system's operational boundary, violating the principle of organizational closure.5

This foundational constraint forces the adoption of the "Living Image" paradigm, a concept inherited from the Smalltalk programming environment.2 In this model, the system's entire state—its code, its data, and its evolving cognitive architecture—is persisted as a single, live, mutable, and transactionally coherent object graph.5 The Python-based Minimum Viable Application (MVA) serves as a high-level, practical analogue for this concept, using the Zope Object Database (ZODB) to manage its state as a single

mydata.fs file that represents the system's durable embodiment.6

This unbroken causal chain represents the system's fundamental design principle, elevating its architecture from a collection of "good ideas" to a logical proof derived from a single axiom.18 The selection of a microkernel for process isolation, orthogonal persistence for state durability, and a prototype-based object model for runtime dynamism is not a set of independent choices. It is an "indivisible trinity" of mutually reinforcing concepts.7 The removal of any one of these pillars would cause the entire philosophical and architectural structure to collapse. Consequently, the design of the "file system" cannot be considered in isolation; it must be a direct and logical continuation of this causal chain, satisfying the same constitutional constraints as the kernel and the object model.

The Duality of Persistence: A Bifurcated Substrate

The only architectural approach that satisfies both the autopoietic mandate for a "Living Image" and the pragmatic necessity of interacting with the external world is a dual-mode, or bifurcated, persistence substrate. This architecture cleanly separates the system's internal "world of being" from its external "sensory-motor system" for storage.

The Internal Substrate ("The Living Image"): This is the system's core persistence layer, a novel, object-oriented substrate designed to be the durable embodiment of the live object graph. Its design prioritizes absolute transactional integrity and runtime mutability, enabling the system to safely and continuously modify its own state. The MVA's use of ZODB is the direct high-level analogue for this component.16

The External Substrate ("The Bridge to the World"): This is the system's interface to conventional storage. It is a componentized, modular framework for interacting with block devices and providing standard, file-like interfaces (e.g., POSIX) to legacy applications or for specific tasks like managing large, immutable data. This layer prioritizes modularity, security, and compatibility. The Genode OS Framework's Virtual File System (VFS) is the definitive reference model for this substrate.17

This separation of concerns is a critical risk-mitigation strategy that directly confronts the "sterility trap" identified in the project's development roadmap.25 The initial roadmap's exclusive focus on internal, software-based abstractions created a system that never learned to deal with the "messy, asynchronous, and insecure reality of the external world" of physical hardware and networks.25 The dual-mode architecture resolves this by allowing the philosophically pure Internal Substrate to exist within its protected, transactional environment, while the External Substrate provides the necessary, albeit complex and non-deterministic, interface to reality. This allows the high-risk, novel research into the Internal Substrate to proceed in parallel with the complex but better-understood engineering work of implementing device drivers and POSIX-compliant file systems for the External Substrate.

The following table serves as the foundational justification for this report, visually and logically connecting the system's abstract constitutional principles to the concrete architectural features of the proposed dual-mode substrate. It makes the "unbroken causal chain" explicit and verifiable.

Part II: The Internal Substrate: A Native Persistence Server for the "Living Image"

This section details the high-level design for the system's most critical and novel component: the user-space Persistence Server (PS). This server is the native, low-level realization of the ZODB paradigm, designed to run as a secure, isolated component upon the Genode/seL4 foundation. It is the heart of the Internal Substrate, responsible for maintaining the transactional integrity of the system's entire existence.

Core Architecture: A Capability-Secure User-Space Server

In accordance with the microkernel philosophy that underpins the entire TelOS project, the Persistence Server will be implemented as a native Genode component, running in a dedicated, isolated sandbox.17 This architectural pattern, which moves all traditional operating system services out of the privileged kernel and into user-space server processes, is a direct and necessary consequence of the autopoietic mandate.27

The PS will be responsible for managing a single, dedicated file on a block device, which is provided by a component from the External Substrate. This file physically contains the transaction log of the "Living Image." Access to the PS is not open; it is strictly governed by Genode's capability-based security model. A client component, such as the Memory Management Server or the AI Architect's cognitive core, can do nothing to the persistent state by default. To interact with the PS, a client must be explicitly granted an unforgeable capability to the PS's session interface by a common parent component (typically init during system bootstrap).29 This enforces the Principle of Least Authority at the most fundamental level of the system's state, ensuring that only explicitly authorized components can even attempt to read or modify the "Living Image."

The Transactional Object Model: An IPC-Based Protocol

The Persistence Server will expose its functionality through a custom Genode session interface. This interface defines a set of Remote Procedure Calls (RPCs) that constitute the system's low-level persistence API.33 This API is the mechanism that enables "Transactional Cognition," ensuring that any multi-step cognitive cycle performed by the AI Architect that results in a state change is atomic: either all changes are committed successfully, or the system's state is rolled back to its previous consistent state, with no partial modifications.2

The proposed RPC interface for the Persistence::Session will include the following fundamental primitives:

BeginTransaction(): Initiates a new transaction context for the calling thread. All subsequent PutObject calls from this thread will be associated with this transaction until a Commit or Abort is issued.

Commit(): Atomically commits all object modifications made within the current transaction to the persistent store.

Abort(): Discards all object modifications made within the current transaction, restoring the in-memory state of all affected objects.

GetObject(oid): Retrieves the last committed serialized state of an object, identified by its unique 64-bit object identifier (oid).

PutObject(oid, data): Writes the serialized state of a new or modified object into the current transaction's changeset. This change is not made durable until Commit() is called.

A critical analysis of this architecture reveals a primary performance risk that must be addressed at the protocol level. The research explicitly identifies the potential for an IPC-based persistence server to become a system-wide bottleneck.25 In a monolithic system, accessing or modifying state is an inexpensive memory read or write. In this distributed, microkernel-based architecture, every single object mutation or retrieval could potentially require a full kernel context switch and an IPC round-trip to the Persistence Server. For a system whose state is composed of millions of small, interconnected objects, this overhead could be catastrophically slow.

Therefore, the protocol design must prioritize the minimization of this overhead through aggressive batching. The GetObject and PutObject RPCs must be designed to operate on collections of objects, not just single instances. A single RPC call must be able to retrieve or submit hundreds of objects simultaneously, allowing the high fixed cost of the context switch and IPC message passing to be amortized over a large number of operations. The validation roadmap detailed in Part IV must prioritize the rigorous benchmarking of this batched IPC overhead to prove the computational viability of the entire architecture.

The BLOB Storage Protocol: Persisting the Mind

A significant architectural challenge, identified in the project's long-term planning, is the persistence of large, immutable data assets, such as the multi-gigabyte weights of a fine-tuned Large Language Model (LLM).13 Attempting to store such massive assets directly within the main transaction log of the "Living Image" would be disastrous, leading to extreme transactional overhead and crippling latency.13

The proposed design directly adopts the architectural pattern of ZODB's Binary Large Object (BLOB) feature.35 The Persistence Server will manage a separate "blob directory" on the block device, distinct from the main transaction log file. When a client wishes to commit a large object, the PS will write the object's data to a new, uniquely named file within the blob directory. It will then store only a lightweight, transactionally-managed reference to that file within the main "Living Image" log as part of the client's transaction.

This protocol creates a clean, transactional bridge between the Internal and External Substrates. The management of BLOBs is a powerful pattern where the data itself is stored using the file-like interfaces of the External Substrate, while the metadata and references that give that data meaning are managed with the full ACID guarantees of the Internal Substrate.35 This allows the philosophically pure "Living Image" to safely and consistently manage large-scale data in the "real world" of files and blocks, solving a critical pragmatic challenge without compromising its core principles.

Research Mandate: Confronting the Unsolved Problems

The project's own feasibility analysis correctly identifies the implementation of a native, high-performance, transactional object database as a problem of "extreme" technical complexity.25 While a full design is beyond the scope of this high-level proposal, it is critical to acknowledge the significant, unsolved systems problems that must be addressed by a dedicated research effort. This proposal does not offer definitive solutions but frames the necessary research mandates:

Concurrent Garbage Collection: How will the system identify and reclaim storage space from objects that are no longer transitively reachable from the root of the persistent graph? This is a well-understood problem in single-threaded systems but becomes immensely more complex in a concurrent environment where multiple transactions may be in flight.

Write Barriers: How will the system efficiently and transparently intercept every single state-modifying operation on a persistent object in memory to mark it as "dirty" for the next transaction? This is a fundamental requirement for orthogonal persistence. Solutions may require compiler support (to instrument write operations) or clever use of virtual memory page protection mechanisms provided by the kernel.

Schema Evolution: In a prototype-based system where the structure of core objects can change at runtime, how does the Persistence Server handle loading an older version of an object from disk when its in-memory "prototype" has evolved to have a different set of slots? This requires a robust strategy for data migration and versioning to be built into the persistence layer itself.

Part III: The External Substrate: A Componentized VFS for Pragmatic Integration

This section details the architecture for the system's interface to the external world of storage devices and legacy software. The design leverages the Genode OS Framework's Virtual File System (VFS) as its core architectural pattern. This approach provides unparalleled modularity and security, allowing different storage paradigms—from raw block devices to POSIX-compliant file systems—to coexist as isolated, capability-secured components.

The Genode VFS Paradigm: Component-Local Namespaces

The Genode VFS architecture represents a fundamental departure from the global, system-wide VFS found in traditional Unix-like operating systems. In Genode, the VFS is not a monolithic entity within the kernel; it is a library that is linked into each individual component. This gives every program its own private, isolated, and fully configurable file-system namespace.24

A component's view of the "file system" is defined entirely by its parent in an XML configuration block. This configuration specifies a tree of mount points that constitute the component's root namespace. These mount points can be populated by various VFS "plugins," which are shared libraries that provide access to different services, such as a RAM disk, a physical block device, or a network socket.40

This architecture is the direct embodiment of capability-based security at the file-system level. In a traditional OS, file access is governed by user IDs and permissions. In a Genode-based system, access is governed by capabilities. A component cannot access any file system or storage device unless its parent explicitly routes a corresponding file-system session capability to it during its creation.32 The VFS configuration is the policy engine that defines these routes. This makes the Genode VFS the perfect architectural match for TelOS's constitutional mandate of

Boundary Self-Production.15 The AI Architect, acting as a parent component, can dynamically create child components (for example, to test newly generated code) and provide them with a custom-tailored VFS containing only the exact files and services they require for their specific task. This enforces the Principle of Least Authority with extreme granularity, creating secure, purpose-built sandboxes at the file-system level.

The vfs_server Multiplexer: A Gateway to Storage

To provide shared access to common storage resources, the architecture will employ a central vfs_server component. This is a standard and powerful pattern within the Genode ecosystem. The vfs_server component uses a VFS internally to mount and manage various storage backends, and it then exports its entire configured namespace as a single, unified file-system service. Other components can then mount this service into their own local VFS namespaces.39 This server acts as a secure multiplexer or gateway, allowing multiple, mutually distrusting client components to share access to a common set of storage resources, with the

vfs_server's parent defining the access control policy for each client.

A Suite of VFS Plugins: The Building Blocks of Storage

The power and flexibility of the Genode VFS lie in its dynamic plugin architecture.39 The External Substrate will be constructed from a suite of custom and existing VFS plugins, composed together to create a layered storage stack.

vfs_block_device: This is the lowest-level plugin, serving as the ultimate bridge to physical hardware. It will be a client of a user-space device driver (e.g., an AHCI driver for SATA disks or a VirtIO driver for virtualized environments), requesting a Block::Session from the driver. This session provides raw, block-based read/write access to the physical storage medium. The plugin then exposes this block-level interface to its children in the VFS tree.44

vfs_posix: This is a high-level plugin that implements a standard, POSIX-compliant file system, such as a simple FAT-like or ext2-like structure. It will be a client of a vfs_block_device plugin, using the raw block I/O service as its backend storage. This component is the primary bridge for running legacy applications that expect a conventional file system and for providing a familiar interface for external data exchange.

vfs_living_image: This is a specialized, read-only plugin that provides a crucial introspection and governance capability. It will be a client of the Internal Substrate's Persistence Server. It will present the entire "Living Image" object graph as a navigable, file-like hierarchy (e.g., /image/objects/<oid>). This allows the AI Architect or a Human Oracle to "browse" the system's live, persistent state using standard command-line tools, providing a powerful mechanism for debugging, auditing, and system governance.

The following table provides a clear schematic of the proposed External Substrate architecture, detailing how the different layers of abstraction are composed to create a complete and secure storage stack.

Part IV: A Phased, Risk-Driven Validation Roadmap

This final section translates the comprehensive architectural design into an actionable, four-phase research and implementation plan. This approach explicitly counters the philosophically elegant but pragmatically flawed linear "descent from abstraction" roadmap critiqued in the project's own analysis.25 By prioritizing the highest-risk and most foundational assumptions first, this risk-driven, bottom-up strategy ensures the project's core viability before committing resources to higher-level integrations.

Phase 1: The Persistence Kernel Prototype & IPC Benchmark

Objective: To empirically validate the performance and correctness of the highest-risk component: the native, IPC-based Persistence Server.

Core Tasks: Implement a minimal, in-memory prototype of the Persistence Server and a multi-threaded client test harness within the Genode framework. The focus is not on features like garbage collection but on the raw performance of the transactional IPC protocol.

Primary Risk Addressed: IPC Overhead Bottleneck.25

Validation Criteria & Milestones: Conduct rigorous benchmarking of batched GetObject and PutObject RPCs. The key metric is transactions-per-second for various object sizes and batch counts. The milestone is to achieve a performance level that proves an IPC-based persistence layer is computationally viable for the system's expected workload.

Phase 2: The VFS Gateway and Raw Block I/O

Objective: To establish a complete, end-to-end, user-space I/O path from a client application to a physical storage device.

Core Tasks: Implement the vfs_server multiplexer component and the vfs_block_device plugin. Integrate these components with a pre-existing or simple custom block driver (e.g., Genode's existing VirtIO block driver for use within a QEMU test environment).

Primary Risk Addressed: Driver integration complexity and the viability of a purely user-space storage stack.

Validation Criteria & Milestones: A client component must be able to successfully open a session to the vfs_server, write a block of data to a virtual block device file, and read the same block back, with the data being physically stored and retrieved by the underlying block driver.

Phase 3: POSIX Conformance and Empirical Validation

Objective: To implement a functional, demonstrably correct, POSIX-compliant file system as a user-space component.

Core Tasks: Implement the vfs_posix plugin, building upon the block device service validated in Phase 2.

Primary Risk Addressed: The immense complexity of POSIX semantics and the risk of subtle correctness bugs.

Validation Criteria & Milestones: The vfs_posix implementation must be subjected to a rigorous, automated testing regime using the pjdfstest suite.47 The milestone is to pass a significant and progressively growing subset of the test cases, providing objective, empirical proof of correctness. This directly satisfies the system's core "generate-and-test" epistemology.15

Phase 4: Full Autopoietic Integration and Self-Modification

Objective: To integrate the complete, validated storage substrate with the Agentic Control Plane and demonstrate a true act of autopoietic capability.

Core Tasks: Grant the AI Architect component the necessary capabilities to act as the parent for the vfs_server and its underlying plugins.

Primary Risk Addressed: The governance and safety of AI-driven modification of core system components.

Validation Criteria & Milestones: The AI Architect receives a high-level goal from the Human Oracle, such as: "Create a new, encrypted file system for secure data storage." It must autonomously execute the entire development lifecycle: (1) Clone the source code for the vfs_posix plugin by accessing it through a VFS ROM service. (2) Generate new code to add an encryption layer, leveraging a cryptographic service. (3) Compile the new plugin as a shared library. (4) Instantiate a new, sandboxed vfs_server instance configured to use the modified plugin. (5) Execute a subset of the pjdfstest suite against the new server to empirically validate its own work. The successful completion of this sequence closes the autopoietic loop, demonstrating the system's ability to safely modify and extend its own core storage components.

This master project plan provides a clear, step-by-step path from initial prototyping to the final demonstration of autopoietic self-modification. It makes the risk-driven approach explicit, providing the system's Architect with a clear view of how the project's foundational uncertainties will be systematically confronted and eliminated.

Conclusion and Strategic Recommendations

The challenge of designing a "file system" for the TelOS project is, in reality, the challenge of architecting the entire persistence and storage substrate for a new class of autonomous, self-producing computational entity. A monolithic, traditional file system is not merely a suboptimal choice; it is a philosophical and architectural impossibility that violates the system's most fundamental constitutional mandates.

The proposed dual-mode architecture provides a coherent and viable path forward. It respects the absolute necessity of a transactional, live-mutable "Living Image" for the system's autopoietic core while simultaneously providing a pragmatic, secure, and modular bridge to the external world of conventional storage. The Internal Substrate, realized as a native Persistence Server, provides the foundation for "Transactional Cognition." The External Substrate, realized through the Genode VFS, provides the foundation for secure, componentized interaction with hardware and legacy software.

The strategic recommendation is to adopt the proposed four-phase, risk-driven roadmap. This approach directly confronts the most significant technical and performance uncertainties early in the development cycle. By prioritizing the empirical validation of the IPC-based persistence kernel and the correctness of the user-space I/O stack, the project can build upon a foundation of proven, high-confidence components. This methodology not only mitigates project risk but is also in perfect alignment with the system's own "generate-and-test" epistemology—a development process that, like the system it aims to create, prioritizes empirical validation as the sole arbiter of truth.

Works cited

Dynamic OO System Synthesis Blueprint

MVA Research Plan Synthesis

MVA Roadmap: Autopoiesis and Learning

Integrating RAG into Forge Script

Autopoietic MVA Morphic UI Blueprint

TelOS: A Living System's Becoming

Building A Self-Modifying System

Living Learning System Blueprint

Evolving BatOS: Fractal Cognition Augmentation

AI Architecture: A Living Codex

Co-Creative AI System Design Prompt

Morphic UI Research Plan Integration

Fractal OS Design: Morphic UI Generation

Human-AI Autopoietic OS Collaboration

Refining Meta-Prompt for AI OS Construction

TelOS MVP: Prototype-Based Self-Modification

Genode Roadmap for TelOS Development

TelOS Architectural Research Plan Synthesis

Forge TelOS MVA Core and UI

Building a Local AI System

Fractal Memory System Proof of Concept

Genode TelOS Roadmap Research Plan

Genode - Wikipedia, accessed September 11, 2025, https://en.wikipedia.org/wiki/Genode

Genode's VFS #1: The basics - Genodians.org, accessed September 11, 2025, https://genodians.org/m-stein/2021-06-21-vfs-1

Project TelOS Iterative Development Roadmap

Metaphorical System Architecture Blueprint

AI OS Microkernel Implementation Plan

TelOS seL4 Architectural Blueprint Refinement

Self-Modifying Fractal AI Architecture

Genode Operating System Framework, accessed September 11, 2025, http://genode.org/files/53bcb8e33fe6602fed25edc3c7b922c5/manual-2015-04-27.pdf

A Universal Prototype-Based OS

Design of the Genode OS Architecture: Interfaces and Mechanisms, accessed September 11, 2025, https://genode.org/documentation/architecture/interfaces

A simple client-server scenario - Genode, accessed September 11, 2025, https://genode.org/documentation/developer-resources/client_server_tutorial

Base API - Genode, accessed September 11, 2025, https://genode.org/documentation/api/base_index

Storage APIs — ZODB documentation, accessed September 11, 2025, https://zodb.org/en/latest/reference/storages.html

Introduction — ZODB documentation, accessed September 11, 2025, https://zodb.org/en/latest/introduction.html

An overview of the ZODB (by Laurence Rowe), accessed September 11, 2025, https://zodb.org/en/latest/articles/ZODB-overview.html

Tyr: Blob Storage Meets Built-In Transactions - ResearchGate, accessed September 11, 2025, https://www.researchgate.net/publication/313193390_Tyr_Blob_Storage_Meets_Built-In_Transactions

Genode 17.02 uses Linux TCP/IP stack as file system - OSnews, accessed September 11, 2025, https://www.osnews.com/story/29691/genode-1702-uses-linux-tcpip-stack-as-file-system/

The VFS paradigm from the perspective of a component OS - Previous FOSDEM Editions, accessed September 11, 2025, https://archive.fosdem.org/2017/schedule/event/microkernel_vfs_component_os/attachments/slides/1698/export/events/attachments/microkernel_vfs_component_os/slides/1698/fosdem_genode_vfs_2017_02_04.pdf

Genode's VFS #3: Networking - Genodians.org, accessed September 11, 2025, https://genodians.org/m-stein/2021-09-23-vfs-3

The init component - Genode OS Framework Foundations, accessed September 11, 2025, https://genode.org/documentation/genode-foundations/21.05/system_configuration/The_init_component.html

Component composition - Genode OS Framework Foundations, accessed September 11, 2025, https://genode.org/documentation/genode-foundations/20.05/components/Component_composition.html

OS-level session interfaces - Genode OS Framework Foundations, accessed September 11, 2025, https://genode.org/documentation/genode-foundations/24.05/api/OS-level_session_interfaces.html

Common session interfaces - Genode OS Framework Foundations, accessed September 11, 2025, https://genode.org/documentation/genode-foundations/21.05/components/Common_session_interfaces.html

Common session interfaces - Genode OS Framework Foundations, accessed September 11, 2025, https://genode.org/documentation/genode-foundations/24.05/components/Common_session_interfaces.html

Pjdfstest - FreeBSD Wiki, accessed September 11, 2025, https://wiki.freebsd.org/Pjdfstest

pjd/pjdfstest: File system test suite. - GitHub, accessed September 11, 2025, https://github.com/pjd/pjdfstest

POSIX Compatibility | JuiceFS Document Center, accessed September 11, 2025, https://juicefs.com/docs/community/posix_compatibility/

JuiceFS is a distributed POSIX file system built on top of Redis and S3. - GitHub, accessed September 11, 2025, https://github.com/juicedata/juicefs

Foundational Principle | Direct Consequence | Architectural Necessity | Internal Substrate Implementation | External Substrate Implementation

Info-Autopoiesis 1 | System must be able to regenerate its own components at runtime. | Live, mutable state model that is transactionally coherent. | The "Living Image" paradigm, embodied in a user-space Persistence Server. | N/A (External files are allopoietic, not part of the self).

Organizational Closure 7 | Runtime self-modification without halting or external intervention. | Orthogonal persistence; durability is an intrinsic property of objects. | An IPC-based transactional protocol for GetObject and PutObject. | A vfs_living_image plugin for read-only introspection.

Boundary Self-Production 15 | System must create and manage its own security boundaries. | Fine-grained, capability-based access control for all resources. | The Persistence Server is a sandboxed component accessible only via capabilities. | A component-local Genode VFS where access is governed by session routing.

Epistemology of Undecidability 15 | Impossibility of a priori proof of correctness for self-modifications. | Empirical "generate-and-test" methodology is the sole arbiter of correctness. | N/A (Persistence ensures logical safety via Abort on test failure). | A vfs_posix plugin validated against the pjdfstest conformance suite.

Plugin Name | Core Function | Backend Dependency (Session Type) | Exported Interface | Role in TelOS Ecosystem

vfs_posix | Provides a POSIX-compliant file system. | File_system::Session (from vfs_block_device) | Standard file and directory hierarchy. | Legacy application support; external data exchange.

vfs_block_device | Provides raw block-level access to a storage partition. | Block::Session (from a device driver) | A single file representing the block device. | The physical storage layer for conventional file systems.

vfs_living_image | Provides read-only, file-like access to the persistent object graph. | Persistence::Session (from the Persistence Server) | A navigable directory of object IDs and their serialized state. | System introspection, debugging, and governance.

Phase | Key Objectives | Core Tasks | Primary Risks Addressed | Validation Criteria & Milestones

1 | Validate performance of the IPC-based persistence model. | Implement minimal PS prototype. Benchmark batched RPCs. | IPC Overhead Bottleneck. | Achieve target transactions-per-second for various object sizes and batch counts.

2 | Establish a complete user-space I/O path to a block device. | Implement vfs_server and vfs_block_device. Integrate with a block driver. | Driver Integration Complexity. | A client can successfully perform a raw block read/write operation to a physical or virtual disk.

3 | Implement a functional and correct POSIX file system. | Implement the vfs_posix plugin on top of the Phase 2 stack. | POSIX Semantic Correctness. | Pass a defined, comprehensive subset of the pjdfstest conformance suite.

4 | Demonstrate autopoietic self-modification of the storage substrate. | Integrate with the Agentic Control Plane. Issue a high-level modification goal. | AI Governance & Safety. | The AI Architect autonomously generates, compiles, deploys, and validates a new file system plugin.