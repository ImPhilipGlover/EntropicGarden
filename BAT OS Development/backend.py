{"cells":[{"cell_type":"code","source":"import asyncio\nimport zmq\nimport zmq.asyncio\nimport msgpack\nimport json\nimport types\nimport copy\nimport os\nimport ollama\nimport ZODB, ZODB.FileStorage, ZODB.DB\nimport transaction\nimport persistent\nimport persistent.mapping\n\n# --- Configuration ---\nDB_PATH = \"./data/bat_os_image.fs\"\nCOMMAND_SOCKET_ADDR = \"tcp://*:5555\"\nSTATE_SOCKET_ADDR = \"tcp://*:5556\"\n\n# --- The Persistent, Prototype-Based Object ---\nclass ArchitectObject(persistent.Persistent):\n    \"\"\"\n    A persistent, prototype-based object implementing reflective autopoiesis.\n    Its state and behavior are stored in ZODB-aware slots.\n    \"\"\"\n    def __init__(self, is_prototype=True):\n        # Use a PersistentMapping for slots to ensure ZODB tracks changes.\n        self._slots = persistent.mapping.PersistentMapping()\n        if is_prototype:\n            self._slots['_parent'] = None\n\n    def clone(self):\n        new_obj = ArchitectObject(is_prototype=False)\n        # deepcopy ensures a fully independent, persistent copy.\n        new_obj._slots = copy.deepcopy(self._slots)\n        return new_obj\n\n    def __getattr__(self, name):\n        \"\"\"Handles message passing, delegation, and triggers autopoiesis.\"\"\"\n        if name in self._slots:\n            slot_value = self._slots[name]\n            if callable(slot_value) and not isinstance(slot_value, types.MethodType):\n                return types.MethodType(slot_value, self)\n            return slot_value\n\n        parent = self._slots.get('_parent')\n        if parent:\n            try:\n                return getattr(parent, name)\n            except AttributeError:\n                pass\n\n        def method_missing(*args, **kwargs):\n            print(f\"\\n--- AUTOPOIETIC EVENT TRIGGERED for '{name}' ---\")\n            return self._doesNotUnderstand(name, *args, **kwargs)\n        return method_missing\n\n    def _doesNotUnderstand(self, name, *args, **kwargs):\n        \"\"\"The core of autopoiesis: generates and binds a new method via LLM.\"\"\"\n        prompt = self._create_llm_prompt(name, args, kwargs)\n        print(f\"[*] Generating method '{name}'...\")\n        print(f\"    Context sent to LLM: {json.dumps(self.get_data_slots())}\")\n\n        try:\n            response = ollama.chat(\n                model='phi3',\n                messages=[{'role': 'user', 'content': prompt}],\n            )\n            code_str = response['message']['content']\n            if \"```python\" in code_str:\n                code_str = code_str.split(\"```python\").[1]split(\"```\").strip()\n            print(f\"[+] LLM generated code:\\n---\\n{code_str}\\n---\")\n        except Exception as e:\n            print(f\"[!] LLM generation failed: {e}\")\n            raise AttributeError(f\"Could not generate method '{name}'\")\n\n        try:\n            temp_scope = {}\n            exec(f\"def temp_func(self, *args, **kwargs):\\n    \" + \"\\n    \".join(code_str.splitlines()), temp_scope)\n            new_function = temp_scope['temp_func']\n            \n            # Add the new function to this object's slots. It will be bound on first access.\n            self._slots[name] = new_function\n            print(f\"[*] Method '{name}' successfully created and stored in slots.\")\n\n            # Re-invoke the original message, which will now succeed.\n            print(f\"[*] Re-invoking '{name}'...\")\n            return getattr(self, name)(*args, **kwargs)\n        except Exception as e:\n            print(f\"[!] Failed to bind or execute new method: {e}\")\n            raise AttributeError(f\"Generated code for '{name}' was invalid.\")\n\n    def _create_llm_prompt(self, name, args, kwargs):\n        data_slots = json.dumps(self.get_data_slots(), indent=2)\n        return f\"\"\"\nYou are an expert Python method generator. Your task is to write ONLY the body of a Python method for an object.\n\nMETHOD CONTEXT:\n- The object's data is stored in a dictionary accessed via `self._slots`.\n- The method to generate is named: `{name}`\n- It was called with positional arguments: `{args}`\n- It was called with keyword arguments: `{kwargs}`\n- The object's current data slots are:\n{data_slots}\n\nTASK:\nWrite the Python code for the body of the method `{name}`.\n- The code must operate on `self._slots`.\n- The code MUST return a value or modify `self._slots`.\n- DO NOT import any libraries.\n- DO NOT define the function signature `def {name}(self,...):`. Write only the indented code for the function body.\n\"\"\"\n\n    def get_data_slots(self):\n        return {k: v for k, v in self._slots.items() if not callable(v) and k!= '_parent'}\n\n    def get_full_state(self):\n        state = self.get_data_slots()\n        for key, value in self._slots.items():\n            if callable(value):\n                state[key] = f\"<method>\"\n        return state\n\n# --- Backend Application ---\nclass Backend:\n    def __init__(self, loop):\n        self.loop = loop\n        self.db, self.conn, self.root, self.uvm = self._initialize_persistence()\n\n        self.context = zmq.asyncio.Context()\n        self.rep_socket = self.context.socket(zmq.REP)\n        self.rep_socket.bind(COMMAND_SOCKET_ADDR)\n        self.pub_socket = self.context.socket(zmq.PUB)\n        self.pub_socket.bind(STATE_SOCKET_ADDR)\n\n    def _initialize_persistence(self):\n        \"\"\"Initializes ZODB and loads or creates the UVM.\"\"\"\n        print(\"(ALFRED): Initializing persistence layer...\")\n        storage = ZODB.FileStorage.FileStorage(DB_PATH)\n        db = ZODB.DB(storage)\n        conn = db.open()\n        root = conn.root()\n\n        if 'uvm' not in root:\n            print(\"(BRICK): No UVM found. Creating Genesis Morph.\")\n            uvm = ArchitectObject()\n            uvm._slots['x'] = 100\n            uvm._slots['y'] = 100\n            uvm._slots['color'] = (0.5, 0.7, 0.9, 1.0)\n            uvm._slots['name'] = \"Genesis UVM\"\n            root['uvm'] = uvm\n            transaction.commit()\n        else:\n            print(\"(BRICK): UVM found. Resuming from persistent image.\")\n            uvm = root['uvm']\n        \n        print(\"(ALFRED): Persistence layer online.\")\n        return db, conn, root, uvm\n\n    async def handle_commands(self):\n        print(f\"(ALFRED): Command listener active on {COMMAND_SOCKET_ADDR}\")\n        while True:\n            message = await self.rep_socket.recv()\n            command_data = msgpack.unpackb(message, raw=False)\n            command = command_data.get(\"command\")\n            \n            print(f\"(BABS): Received command: {command}\")\n            response = {\"status\": \"error\", \"message\": \"Unknown command\"}\n\n            if command == \"invoke_method\":\n                response = await self.invoke_method(command_data)\n            \n            await self.rep_socket.send(msgpack.packb(response))\n\n    async def broadcast_state(self):\n        state = self.uvm.get_full_state()\n        packed_state = msgpack.packb({\"event\": \"UvmStateUpdate\", \"state\": state})\n        await self.pub_socket.send(packed_state)\n\n    async def invoke_method(self, data):\n        method_name = data.get(\"method_name\")\n        args = data.get(\"args\",)\n        kwargs = data.get(\"kwargs\", {})\n\n        def sync_invoke_and_commit():\n            \"\"\"Synchronous function to be run in a thread executor.\"\"\"\n            try:\n                method = getattr(self.uvm, method_name)\n                result = method(*args, **kwargs)\n                # If the method modified state, commit the transaction\n                transaction.commit()\n                return {\"status\": \"ok\", \"message\": f\"Method '{method_name}' invoked.\", \"result\": str(result)}\n            except Exception as e:\n                # If anything fails, abort the transaction to ensure consistency\n                transaction.abort()\n                print(f\"[!] Transaction aborted due to error: {e}\")\n                return {\"status\": \"error\", \"message\": str(e)}\n\n        # Run the synchronous, transactional code in a separate thread\n        response = await self.loop.run_in_executor(None, sync_invoke_and_commit)\n        \n        # Broadcast the new state only after a successful commit\n        if response.get(\"status\") == \"ok\":\n            await self.broadcast_state()\n            \n        return response\n\nasync def main():\n    if not os.path.exists(\"./data\"):\n        os.makedirs(\"./data\")\n\n    loop = asyncio.get_running_loop()\n    backend = Backend(loop)\n    \n    print(\"(ALFRED): Backend initialized. Broadcasting initial state.\")\n    await backend.broadcast_state()\n\n    asyncio.create_task(backend.handle_commands())\n    while True:\n        await asyncio.sleep(3600)\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\n(ALFRED): System shutdown initiated by Architect.\")","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}