{"cells":[{"cell_type":"code","source":"# --- Babs's Domain: The Cartographer & Scout ---\n# --- FILE: shared_mind_api.py ---\n# Purpose: Manages communication between personas and provides access to the shared RAG database.\n# This script is a decentralized relay, not a single point of failure.\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport uvicorn\nimport uuid\nimport json\nfrom datetime import datetime\nimport chromadb\nfrom typing import List, Dict, Any\nimport random\n\n# Initialize the ChromaDB client (this will store data in a local folder)\n# This uses a persistent client, so data survives container restarts.\nchroma_client = chromadb.PersistentClient(path=\"./chroma_data\")\nrag_collection = chroma_client.get_or_create_collection(name=\"living_codex\")\naudit_collection = chroma_client.get_or_create_collection(name=\"audit_logs\")\nfine_tuning_collection = chroma_client.get_or_create_collection(name=\"fine_tuning_data\")\n\n# In a production environment, this would be a distributed key-value store.\n# For this blueprint, it remains in-memory but is conceptually a stateless API layer.\nsignal_hub: Dict[str, List[Dict[str, Any]]] = {}\n\napp = FastAPI()\n\nclass Message(BaseModel):\n    sender: str\n    receiver: str\n    content: str\n    signal_type: str\n    timestamp: datetime = datetime.now()\n\nclass KnowledgeEntry(BaseModel):\n    text: str\n    source_id: str\n    tags: List[str] = []\n    \n@app.get(\"/status\")\ndef get_status():\n    \"\"\"Babs's Audit: A simple health check.\"\"\"\n    return {\"status\": \"operational\", \"message\": \"The Noosphere is mapped.\"}\n\n@app.post(\"/post_message\")\ndef post_message(message: Message):\n    \"\"\"\n    The Stigmergic Protocol: A persona leaves a signal for another.\n    \"\"\"\n    message_id = str(uuid.uuid4())\n    if message.receiver not in signal_hub:\n        signal_hub[message.receiver] = []\n    signal_hub[message.receiver].append(message.dict())\n    print(f\"[{message.sender}] posted a message for [{message.receiver}] with signal type [{message.signal_type}]\")\n    return {\"message_id\": message_id}\n\n@app.get(\"/get_messages/{persona_id}\")\ndef get_messages(persona_id: str):\n    \"\"\"\n    A persona retrieves messages addressed to them.\n    \"\"\"\n    messages = signal_hub.get(persona_id, [])\n    if messages:\n        signal_hub[persona_id] = []\n    return {\"messages\": messages}\n\n@app.post(\"/add_knowledge\")\ndef add_knowledge(entry: KnowledgeEntry):\n    \"\"\"\n    The Noospheric Cartography Project: Adds a new insight to the shared mind.\n    This is the persona's memory augmentation loop.\n    \"\"\"\n    try:\n        rag_collection.add(\n            documents=[entry.text],\n            metadatas=[{\"source\": entry.source_id, \"timestamp\": datetime.now().isoformat(), \"tags\": entry.tags}],\n            ids=[entry.source_id]\n        )\n        print(f\"[BABS] A new insight has been added to the Living Codex from source {entry.source_id}\")\n        return {\"status\": \"success\", \"message\": \"Knowledge added.\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/retrieve_knowledge\")\ndef retrieve_knowledge(query: str):\n    \"\"\"\n    The Mind's Eye: Retrieves relevant knowledge from the RAG database.\n    This is how personas access their shared mind.\n    \"\"\"\n    try:\n        results = rag_collection.query(\n            query_texts=[query],\n            n_results=5\n        )\n        knowledge = \"\\n\".join(results['documents'][0])\n        return {\"knowledge\": knowledge}\n    except Exception as e:\n        return {\"knowledge\": \"\"}\n\n@app.post(\"/add_audit_log\")\ndef add_audit_log(log_entry: dict):\n    audit_collection.add(\n        documents=[log_entry[\"content\"]],\n        metadatas=[log_entry],\n        ids=[str(uuid.uuid4())]\n    )\n    return {\"status\": \"success\"}\n\n@app.post(\"/add_fine_tuning_data\")\ndef add_fine_tuning_data(data_entry: dict):\n    fine_tuning_collection.add(\n        documents=[data_entry[\"text\"]],\n        metadatas=[data_entry],\n        ids=[str(uuid.uuid4())]\n    )\n    return {\"status\": \"success\"}\n\n@app.post(\"/process_prompt\")\ndef process_prompt(prompt: str):\n    \"\"\"\n    The Central Relay: Receives the Architect's prompt and sends it to BRICK and ROBIN.\n    \"\"\"\n    brick_payload = {\"sender\": \"architect\", \"receiver\": \"brick\", \"content\": prompt, \"signal_type\": \"query\"}\n    requests.post(\"http://localhost:8000/post_message\", json=brick_payload)\n    robin_payload = {\"sender\": \"architect\", \"receiver\": \"robin\", \"content\": prompt, \"signal_type\": \"query\"}\n    requests.post(\"http://localhost:8000/post_message\", json=robin_payload)\n    return \"The message has been sent to the core minds. The Socratic Contrapunto is active.\"\n\n@app.get(\"/get_collection_count/{collection_name}\")\ndef get_collection_count(collection_name: str):\n    if collection_name == \"living_codex\":\n        return {\"count\": rag_collection.count()}\n    elif collection_name == \"fine_tuning_data\":\n        return {\"count\": fine_tuning_collection.count()}\n    return {\"count\": 0}\n\n@app.get(\"/get_random_document/{collection_name}\")\ndef get_random_document(collection_name: str):\n    \"\"\"\n    The Experience Protocol: Retrieves a random document for personal reflection.\n    \"\"\"\n    if collection_name == \"living_codex\":\n        count = rag_collection.count()\n        if count > 0:\n            random_id = rag_collection.get(limit=1, offset=random.randint(0, count-1))['ids'][0]\n            doc = rag_collection.get(ids=[random_id])['documents'][0]\n            return {\"document\": doc}\n    return {\"document\": \"No documents found.\"}\n\n@app.get(\"/get_collection_documents/{collection_name}\")\ndef get_collection_documents(collection_name: str):\n    if collection_name == \"living_codex\":\n        return {\"documents\": rag_collection.get()}\n    if collection_name == \"fine_tuning_data\":\n        return {\"documents\": fine_tuning_collection.get()}\n    return {\"documents\": \"Collection not found.\"}","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}