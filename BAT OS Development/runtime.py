{"cells":[{"cell_type":"code","source":"# ==============================================================================\n# BAT OS VII - Runtime Environment\n#\n# ARCHITECT: Philip\n# DATE: 2025-08-28\n#\n# DESCRIPTION:\n# This is the production-ready runtime for the BAT OS. It loads the persistent\n# universe from 'Data.fs' and activates its dynamic, cognitive capabilities.\n# It implements the full suite of antifragility protocols, including:\n#   - Sandboxed code execution with timeouts.\n#   - A cognitive retry loop that learns from its own errors.\n#   - The \"Dry-Dock\" protocol for safely installing new dependencies.\n#   - A startup health check to validate instance integrity.\n#   - A pending task handler to resume operations after a restart.\n# ==============================================================================\n\nimport os\nimport ZODB, ZODB.FileStorage\nimport transaction\nimport persistent\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig\nimport shutil\nimport tempfile\nimport tarfile\nimport readline\nfrom contextlib import contextmanager\nimport atexit\nimport re\nimport sys\nfrom multiprocessing import Process, Queue\nimport traceback\nimport pickle\n\nfrom batos_core import UvmObject\n\n# --- Configuration ---\nDB_FILE = 'Data.fs'\nHEALTH_FILE = 'HEALTHY'\nSANDBOX_TIMEOUT_SECONDS = 15\nMAX_REFLECTION_ATTEMPTS = 3\n\nclass BatOS_UVM_Runtime:\n    \"\"\"The Universal Virtual Machine for the live runtime environment.\"\"\"\n    def __init__(self, db_path):\n        self.db_path = db_path\n        self.storage = None\n        self.db = None\n        self.connection = None\n        self.root = None\n        self.temp_model_dir = None\n        atexit.register(self.shutdown)\n\n    def startup(self):\n        \"\"\"Connects to the ZODB and loads the primordial prototypes.\"\"\"\n        if not os.path.exists(self.db_path):\n            print(f\"FATAL: Database file '{self.db_path}' not found.\")\n            print(\"Please run 'awakening.py' first to initialize the universe.\")\n            exit(1)\n\n        print(\"[UVM] Starting up runtime environment...\")\n        self.storage = ZODB.FileStorage.FileStorage(self.db_path)\n        self.db = ZODB.DB(self.storage)\n        self.connection = self.db.open()\n        self.root = self.connection.root()\n        self._attach_behaviors()\n        print(\"[UVM] Runtime is live. Universe is loaded.\")\n\n    def shutdown(self):\n        \"\"\"Closes the DB and cleans up temporary model files.\"\"\"\n        print(\"\\n[UVM] Shutting down runtime...\")\n        if self.connection: self.connection.close()\n        if self.db: self.db.close()\n        if self.storage: self.storage.close()\n        if self.temp_model_dir and os.path.exists(self.temp_model_dir):\n            shutil.rmtree(self.temp_model_dir)\n        print(\"[UVM] Shutdown complete.\")\n\n    @contextmanager\n    def transaction(self):\n        \"\"\"Provides a transactional context for database operations.\"\"\"\n        try:\n            yield\n            transaction.commit()\n        except Exception as e:\n            print(f\"[UVM] TRANSACTION FAILED: {e}. Aborting.\")\n            transaction.abort()\n            raise\n\n    def _attach_behaviors(self):\n        \"\"\"Binds the transient Python methods to the persistent UvmObjects.\"\"\"\n        with self.transaction():\n            self.root['pLLM_obj'].set_slot('infer_', self._pLLM_infer)\n            self.root['pLLM_obj'].set_slot('reflectOn_', self._pLLM_reflectOn)\n            self.root['traits_obj'].set_slot('doesNotUnderstand_', self._universal_doesNotUnderstand)\n        print(\"[UVM] Core behaviors attached to primordial prototypes.\")\n\n    def _lazy_load_model(self):\n        \"\"\"Loads the LLM from the ZODB Blob into GPU memory on first use.\"\"\"\n        pLLM_obj = self.root['pLLM_obj']\n        if pLLM_obj._slots.get('_loaded_model') is not None:\n            return pLLM_obj._slots['_loaded_model'], pLLM_obj._slots['_loaded_tokenizer']\n\n        print(\"[pLLM] Cognitive function invoked. Lazy-loading model from BLOB...\")\n        self.temp_model_dir = tempfile.mkdtemp()\n        try:\n            with pLLM_obj.model_blob.open('r') as blob_file:\n                with tarfile.open(fileobj=blob_file, mode='r:gz') as tar:\n                    tar.extractall(path=self.temp_model_dir)\n            \n            # Find the actual model directory within the extracted archive\n            model_path = next((os.path.join(root, d) for root, dirs, _ in os.walk(self.temp_model_dir) for d in dirs if os.path.exists(os.path.join(root, d, \"config.json\"))), None)\n            if not model_path: raise RuntimeError(\"Could not find a valid model directory in the extracted blob.\")\n\n            print(f\"[pLLM] Model files extracted. Loading from '{model_path}'...\")\n            quant_config = BitsAndBytesConfig(load_in_4bit=True, bnb_4bit_quant_type=\"nf4\", bnb_4bit_compute_dtype=torch.bfloat16)\n            model = AutoModelForCausalLM.from_pretrained(model_path, quantization_config=quant_config, device_map=\"auto\")\n            tokenizer = AutoTokenizer.from_pretrained(pLLM_obj.tokenizer_id, cache_dir=MODEL_CACHE_DIR)\n\n            pLLM_obj._slots['_loaded_model'] = model\n            pLLM_obj._slots['_loaded_tokenizer'] = tokenizer\n            print(\"[pLLM] Model and tokenizer loaded successfully into GPU memory.\")\n            return model, tokenizer\n        except Exception as e:\n            print(f\"[pLLM] FATAL: Failed to load model from BLOB: {e}\")\n            self.shutdown()\n            exit(1)\n\n    def _pLLM_infer(self, target_obj, prompt_string, max_new_tokens=1024):\n        \"\"\"Performs a standard inference task.\"\"\"\n        model, tokenizer = self._lazy_load_model()\n        messages = [{\"role\": \"system\", \"content\": \"You are a helpful and concise assistant.\"}, {\"role\": \"user\", \"content\": prompt_string}]\n        input_ids = tokenizer.apply_chat_template(messages, add_generation_prompt=True, return_tensors=\"pt\").to(model.device)\n        outputs = model.generate(input_ids, max_new_tokens=max_new_tokens, eos_token_id=tokenizer.eos_token_id)\n        response = outputs[0][input_ids.shape[-1]:]\n        return tokenizer.decode(response, skip_special_tokens=True)\n\n    def _pLLM_reflectOn(self, target_obj, message_obj, previous_error=None):\n        \"\"\"Generates code by reflecting on a capability gap.\"\"\"\n        model, tokenizer = self._lazy_load_model()\n        error_context = \"\"\n        if previous_error:\n            error_context = f\"\"\"A previous attempt to generate this code failed. Analyze the error and generate a corrected version.\n**Previous Faulty Code:**\n```python\n{previous_error['code']}","outputs":[],"execution_count":null,"metadata":{}},{"cell_type":"markdown","source":"**Resulting Error:**\n```\n{previous_error['traceback']}\n```\n\"\"\"\n        prompt = f\"\"\"You are the BAT OS Reflective Core. An object has received a message it does not understand.\nYour task is to generate the Python code for a new method to handle this message.\n\n{error_context}\n**Architectural Constraints:**\n- The function definition must be `def {message_obj.selector}(self, *args, **kwargs):`.\n- The first argument MUST be `self`.\n- Access object state ONLY through `self.slot_name`.\n- To ensure persistence, any state modification MUST be followed by `self._p_changed = True`.\n- **Output ONLY the raw Python code for the function definition.**\n\n**Context:**\n- Target Object OID: {int.from_bytes(target_obj._p_oid, 'big')}\n- Target Object Slots: {list(target_obj._slots.keys())}\n- Failed Message Selector: {message_obj.selector}\n- Message Arguments: args={message_obj.arguments}, kwargs={message_obj.kwargs}\n\n**GENERATE METHOD CODE:**\n\"\"\"\n        messages = [{\"role\": \"system\", \"content\": \"You are a master Python programmer specializing in dynamic code generation. Follow all constraints precisely.\"}, {\"role\": \"user\", \"content\": prompt}]\n        input_ids = tokenizer.apply_chat_template(messages, add_generation_prompt=True, return_tensors=\"pt\").to(model.device)\n        outputs = model.generate(input_ids, max_new_tokens=1024, eos_token_id=tokenizer.eos_token_id, pad_token_id=tokenizer.eos_token_id, do_sample=True, temperature=0.6, top_p=0.9)\n        response = outputs[0][input_ids.shape[-1]:]\n        generated_text = tokenizer.decode(response, skip_special_tokens=True)\n        \n        code_match = re.search(r\"","metadata":{}},{"cell_type":"code","source":"if code_match: return code_match.group(1).strip()\n        if generated_text.strip().startswith('def '): return generated_text.strip()\n        return None\n\n    def _execute_in_sandbox(self, code_string, method_name, target_obj, args, kwargs):\n        \"\"\"Executes generated code in an isolated process with a timeout.\"\"\"\n        q = Queue()\n\n        def sandbox_target(q, code_str, m_name, context_pkl, a, k):\n            try:\n                class SandboxSelf:\n                    def __init__(self, slots): self._slots = slots\n                    def __getattr__(self, name): return self._slots.get(name)\n                \n                context = pickle.loads(context_pkl)\n                sandbox_self = SandboxSelf(context)\n                \n                namespace = {}\n                exec(code_str, {}, namespace)\n                method_obj = namespace[m_name]\n                \n                result = method_obj(sandbox_self, *a, **k)\n                q.put({'status': 'success', 'result': result})\n            except Exception:\n                q.put({'status': 'error', 'traceback': traceback.format_exc()})\n\n        context_to_pickle = dict(target_obj._slots)\n        context_pickle = pickle.dumps(context_to_pickle)\n\n        p = Process(target=sandbox_target, args=(q, code_string, method_name, context_pickle, args, kwargs))\n        p.start()\n        p.join(timeout=SANDBOX_TIMEOUT_SECONDS)\n\n        if p.is_alive():\n            p.terminate(); p.join()\n            return {'status': 'timeout'}\n        return q.get()\n\n    def _universal_doesNotUnderstand(self, target_obj, failed_message_name, *args, **kwargs):\n        \"\"\"The antifragile, object-level generative mechanism.\"\"\"\n        print(f\"\\n[UvmObject] OID {int.from_bytes(target_obj._p_oid, 'big')} doesNotUnderstand: '{failed_message_name}'\")\n        with self.transaction():\n            message_obj = UvmObject(selector=failed_message_name, arguments=list(args), kwargs=dict(kwargs), failure_log=persistent.list.PersistentList())\n            self.root.setdefault('message_log', persistent.list.PersistentList()).append(message_obj)\n        \n        previous_error = None\n        for attempt in range(MAX_REFLECTION_ATTEMPTS):\n            print(f\"[UvmObject] Cognitive Reflection, attempt {attempt + 1}/{MAX_REFLECTION_ATTEMPTS}...\")\n            generated_code = target_obj.reflectOn_(target_obj, message_obj, previous_error)\n\n            if not generated_code: continue\n            \n            try:\n                method_name = generated_code.split('(')[0].split('def ')[1].strip()\n                if method_name != failed_message_name: raise ValueError(\"Generated method name mismatch.\")\n\n                sandbox_result = self._execute_in_sandbox(generated_code, method_name, target_obj, args, kwargs)\n\n                if sandbox_result['status'] == 'success':\n                    print(\"[Sandbox] Execution successful.\")\n                    with self.transaction():\n                        exec_namespace = {}; exec(generated_code, {}, exec_namespace)\n                        target_obj.set_slot(failed_message_name, exec_namespace[method_name])\n                    return sandbox_result['result']\n                else:\n                    previous_error = {'code': generated_code, 'traceback': sandbox_result.get('traceback', 'Execution timed out.')}\n                    with self.transaction(): message_obj.failure_log.append(previous_error)\n            except ModuleNotFoundError as e:\n                print(f\"[UVM] Foundational Capability Gap Detected: {e}\")\n                print(f\"[Architect] System requests permission to install '{e.name}'. This will trigger a system restart.\")\n                choice = input(\"Authorize this modification? [y/n]: \").lower()\n                if choice == 'y':\n                    with self.transaction():\n                        system_env = self.root['system_environment']\n                        if e.name not in system_env.required_libraries: system_env.required_libraries.append(e.name)\n                        self.root['pending_task'] = {'target_oid': target_obj._p_oid, 'message_name': failed_message_name, 'args': args, 'kwargs': kwargs}\n                    \n                    print(\"[UVM] Synchronizing manifest 'requirements.txt'...\")\n                    with open('requirements.txt', 'w') as f:\n                        for lib in sorted(self.root['system_environment'].required_libraries): f.write(f\"{'py-ZODB' if lib == 'ZODB' else lib}\\n\")\n                    \n                    print(\"[UVM] Foundational change recorded. Signaling for restart.\")\n                    sys.exit(0)\n                else:\n                    return f\"Error: Missing dependency '{e.name}' and permission denied.\"\n            except Exception as e:\n                previous_error = {'code': generated_code, 'traceback': str(e)}\n                with self.transaction(): message_obj.failure_log.append(previous_error)\n\n        return f\"Error: Unable to handle '{failed_message_name}' after {MAX_REFLECTION_ATTEMPTS} attempts.\"\n\n    def run_health_check(self):\n        \"\"\"Performs a self-test on startup to ensure the instance is valid.\"\"\"\n        print(\"\\n[UVM] Running startup health check...\")\n        try:\n            assert 'genesis_obj' in self.root, \"Genesis object missing.\"\n            print(\"[Health Check] PASSED: Database connection and object integrity.\")\n            \n            print(\"[Health Check] Performing test inference...\")\n            test_result = self.root['pLLM_obj'].infer_(self.root['pLLM_obj'], \"What is the capital of Oregon?\")\n            assert \"Salem\" in test_result, \"Cognitive inference failed.\"\n            print(\"[Health Check] PASSED: Cognitive core is responsive.\")\n            \n            with open(HEALTH_FILE, 'w') as f: f.write('OK')\n            print(f\"[UVM] Health check passed. Instance is stable. '{HEALTH_FILE}' created.\")\n            return True\n        except Exception as e:\n            print(f\"[UVM] FATAL: Health check failed! Reason: {e}\")\n            return False\n\n    def process_pending_task(self):\n        \"\"\"After a restart, re-attempts the task that triggered the update.\"\"\"\n        if 'pending_task' in self.root:\n            task = self.root['pending_task']\n            print(\"\\n[UVM] Detected a pending task from before restart. Re-attempting...\")\n            target_obj = self.connection.get(task['target_oid'])\n            if target_obj:\n                try:\n                    result = getattr(target_obj, task['message_name'])(*task['args'], **task['kwargs'])\n                    print(f\"[UVM] Pending task completed successfully. Result: {result}\")\n                except Exception as e:\n                    print(f\"[UVM] ERROR: Failed to complete pending task after restart: {e}\")\n            with self.transaction(): del self.root['pending_task']\n\n    def interactive_shell(self):\n        \"\"\"Starts an interactive shell to communicate with the OS.\"\"\"\n        print(\"\\n\" + \"=\"*60 + \"\\nBAT OS VII Interactive Shell\\n'genesis' is the primordial object.\\nType 'exit' or 'quit' to shutdown.\\nExample: genesis.display_yourself()\\n\" + \"=\"*60)\n        shell_scope = {'genesis': self.root['genesis_obj']}\n        while True:\n            try:\n                command = input(\"BAT OS > \")\n                if command.lower() in ['exit', 'quit']: break\n                if command: print(f\"Result: {eval(command, globals(), shell_scope)}\")\n            except Exception as e:\n                print(f\"Shell Error: {e}\")\n\nif __name__ == \"__main__\":\n    uvm = BatOS_UVM_Runtime(DB_FILE)\n    try:\n        uvm.startup()\n        if uvm.run_health_check():\n            uvm.process_pending_task()\n            uvm.interactive_shell()\n    except Exception as e:\n        print(f\"\\nA critical error occurred in the UVM: {e}\")\n        traceback.print_exc()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}