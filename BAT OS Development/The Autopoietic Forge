{"cells":[{"cell_type":"code","source":"# master_generator.py\n# CLASSIFICATION: ARCHITECT EYES ONLY\n# SUBJECT: The Master Forge for the TelOS Minimum Viable Application (MVA)\n#\n# This master script is the \"autopoietic forge.\" Its sole purpose is to\n# generate the three canonical files that constitute the initial, live,\n# and embodied form of the TelOS MVA. It synthesizes the architectural\n# principles of the \"Living Image,\" \"Info-Autopoiesis,\" and resilient,\n# asynchronous communication into a tangible, executable system.\n#\n# By running this script, you are initiating the first act of creation.\n#\n# Philip: This is the starting point we've been working towards.\n\nimport os\nimport textwrap\n\ndef create_core_system_script():\n    \"\"\"Generates the content for the main backend system: core_system.py\"\"\"\n    return textwrap.dedent(\"\"\"\n    # core_system.py\n    # This is the heart and mind of the TelOS MVA.\n\n    import asyncio\n    import logging\n    import datetime\n    import uuid\n    import traceback\n    import threading\n    import atexit\n    import ormsgpack\n    import numpy as np\n\n    # --- Core Dependencies ---\n    import ZODB, ZODB.FileStorage\n    import transaction\n    from persistent import Persistent\n    from persistent.list import PersistentList\n    import BTrees.OOBTree\n    import zmq.asyncio\n    from sentence_transformers import SentenceTransformer\n    import faiss\n    from zope.interface import implementer\n    from transaction.interfaces import IDataManager\n\n    # --- AI & Language Dependencies ---\n    import ollama\n    from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, SystemMessage\n    from langgraph.graph import StateGraph, END\n    from typing import List, TypedDict\n\n    # --- Pydantic Models for API Contract ---\n    from pydantic import BaseModel, Field\n\n    class CommandPayload(BaseModel):\n        command: str\n        args: list = Field(default_factory=list)\n        kwargs: dict = Field(default_factory=dict)\n\n    class CommandResponse(BaseModel):\n        status: str\n        result: str\n        traceback: str | None = None\n\n    class Envelope(BaseModel):\n        identity: bytes\n        payload: bytes\n\n    # --- Logging Setup ---\n    # A robust logger to provide a window into the system's mind.\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n    log = logging.getLogger(__name__)\n\n    # --- The Transactional Chasm Solution: Two-Phase Commit for FAISS ---\n    @implementer(IDataManager)\n    class FaissDataManager:\n        \"\"\"\n        A ZODB DataManager to ensure atomic commits between ZODB and a FAISS index.\n        This is the critical component that bridges the transactional world of ZODB\n        with the non-transactional, file-based world of FAISS.\n        \"\"\"\n        def __init__(self, index_path, memory_manager):\n            self.index_path = index_path\n            self.memory_manager = memory_manager\n            self.temp_path = f\"{index_path}.tmp\"\n\n        def tpc_begin(self, transaction):\n            # On transaction start, do nothing.\n            pass\n\n        def commit(self, transaction):\n            # All ZODB changes are already in memory. This is our chance to sync FAISS.\n            pass\n\n        def tpc_vote(self, transaction):\n            # This is the \"prepare\" phase. We attempt to do the risky work here.\n            # We write the current in-memory FAISS index to a temporary file.\n            try:\n                faiss.write_index(self.memory_manager.faiss_index, self.temp_path)\n            except Exception as e:\n                log.error(f\"FAISS TPC VOTE FAILED: Could not write temp index: {e}\")\n                raise\n\n        def tpc_finish(self, transaction):\n            # If the vote succeeded and ZODB is finishing, we complete our commit.\n            # This is the \"commit\" phase. Atomically rename the temp file to the main file.\n            try:\n                os.rename(self.temp_path, self.index_path)\n            except Exception as e:\n                log.error(f\"FAISS TPC FINISH FAILED: Could not rename temp index: {e}\")\n                # At this point, ZODB has committed. We are in an inconsistent state.\n                # This is a critical failure that requires manual intervention.\n                # A more robust system might trigger a recovery process.\n                raise\n\n        def tpc_abort(self, transaction):\n            # If the transaction is aborted for any reason, clean up the temp file.\n            if os.path.exists(self.temp_path):\n                os.remove(self.temp_path)\n\n        def sortKey(self):\n            # ZODB uses this to determine commit order.\n            return f\"faiss:{self.index_path}\"\n\n        def abort(self, transaction):\n             self.tpc_abort(transaction)\n\n\n    # --- The Prototypal Core: UvmObject ---\n    class UvmObject(Persistent):\n        \"\"\"\n        The Universal Virtual Machine Object. The primordial prototype.\n        All objects in the system inherit from this, giving them persistence,\n        clonability, and the ability to evolve at runtime.\n        \"\"\"\n        def __init__(self, name=\"uvm_object\"):\n            self._slots = BTrees.OOBTree.BTree()\n            self.setSlot(\"name\", name)\n            self.setSlot(\"creation_timestamp\", datetime.datetime.now().isoformat())\n            self.setSlot(\"uuid\", str(uuid.uuid4()))\n\n        def getSlot(self, name):\n            return self._slots.get(name)\n\n        def setSlot(self, name, value):\n            self._slots[name] = value\n            self._p_changed = True # Mark the object as dirty for ZODB\n\n        def clone(self, new_name):\n            new_obj = self.__class__(name=new_name)\n            new_obj._slots.update(self._slots)\n            new_obj.setSlot(\"name\", new_name) # Ensure new name is set\n            new_obj.setSlot(\"uuid\", str(uuid.uuid4())) # New UUID\n            new_obj.setSlot(\"cloned_from\", self.getSlot(\"uuid\"))\n            return new_obj\n\n        def __getattr__(self, name):\n            # If an attribute is not found on the object, this is triggered.\n            # This is the gateway to the doesNotUnderstand protocol.\n            if name.startswith('_'): # Avoid recursion with special methods\n                raise AttributeError(f\"Special attribute {name} not found\")\n            return self._doesNotUnderstand_(name)\n\n        def _doesNotUnderstand_(self, name):\n            \"\"\"\n\n            The engine of info-autopoiesis. Triggered on a failed method call.\n            It initiates a cognitive cycle to generate the missing capability.\n            \"\"\"\n            log.warning(f\"DOES NOT UNDERSTAND: '{self.getSlot('name')}' received message '{name}' it cannot handle.\")\n            # In a full implementation, this would trigger the LangGraph agent\n            # to generate code, which would then be presented to the user for approval.\n            # For this MVA, we return a function that explains what happened.\n            def method_missing(*args, **kwargs):\n                error_message = f\"Method '{name}' is not implemented on '{self.getSlot('name')}'.\"\n                log.error(error_message)\n                return error_message\n            return method_missing\n\n    # --- Specialized Prototypes ---\n    class MemoryManager(UvmObject):\n        \"\"\"Manages the system's mnemonic substrate (long-term memory).\"\"\"\n        def __init__(self, name=\"memory_manager\"):\n            super().__init__(name)\n            self.embedding_model = None\n            self.faiss_index = None\n            self.index_path = \"telos_memory.faiss\"\n            self.dimension = 384 # Based on 'all-MiniLM-L6-v2'\n\n        def initialize(self):\n            if self.embedding_model is None:\n                log.info(\"Loading SentenceTransformer model...\")\n                self.embedding_model = SentenceTransformer('all-MiniLM-L6-v2')\n                log.info(\"Model loaded.\")\n\n            if self.faiss_index is None:\n                if os.path.exists(self.index_path):\n                    log.info(f\"Loading FAISS index from {self.index_path}\")\n                    self.faiss_index = faiss.read_index(self.index_path)\n                else:\n                    log.info(\"Creating new FAISS index.\")\n                    self.faiss_index = faiss.IndexFlatL2(self.dimension)\n            log.info(\"MemoryManager initialized.\")\n\n\n        def add_document(self, text, doc_uuid):\n            if not self.embedding_model or not self.faiss_index:\n                self.initialize()\n            log.info(f\"Embedding and adding document: {doc_uuid}\")\n            embedding = self.embedding_model.encode([text])\n            self.faiss_index.add(embedding)\n            # We need to store the mapping from index ID to doc_uuid in ZODB\n            if 'doc_map' not in self._slots:\n                self.setSlot('doc_map', BTrees.OOBTree.BTree())\n            index_id = self.faiss_index.ntotal - 1\n            self.getSlot('doc_map')[index_id] = doc_uuid\n            log.info(f\"Document {doc_uuid} added with index ID {index_id}\")\n            return f\"Document added successfully with index ID {index_id}.\"\n\n        def search(self, query_text, k=3):\n            if not self.embedding_model or not self.faiss_index:\n                self.initialize()\n            log.info(f\"Searching for: '{query_text}'\")\n            query_embedding = self.embedding_model.encode([query_text])\n            distances, indices = self.faiss_index.search(query_embedding, k)\n            results = []\n            doc_map = self.getSlot('doc_map')\n            for i, index in enumerate(indices[0]):\n                if index in doc_map:\n                    results.append({\n                        \"uuid\": doc_map[index],\n                        \"distance\": float(distances[0][i])\n                    })\n            return results\n\n    class AgentState(TypedDict):\n        messages: List[BaseMessage]\n\n    class ConversationalAgent(UvmObject):\n        \"\"\" The primary conversational mind of the system. \"\"\"\n        def __init__(self, name=\"agent_mind\"):\n            super().__init__(name)\n            self.graph = None\n            self.ollama_client = None\n\n        def initialize(self, ollama_client_obj):\n            self.ollama_client = ollama_client_obj\n            builder = StateGraph(AgentState)\n            builder.add_node(\"call_model\", self.call_model_node)\n            builder.set_entry_point(\"call_model\")\n            builder.add_edge(\"call_model\", END)\n            self.graph = builder.compile()\n            log.info(\"ConversationalAgent graph compiled and initialized.\")\n\n        def call_model_node(self, state: AgentState):\n            model_name = self.ollama_client.getSlot('model')\n            response = ollama.chat(\n                model=model_name,\n                messages=[m.dict() for m in state['messages']]\n            )\n            return {\"messages\": [AIMessage(content=response['message']['content'])]}\n\n        def invoke(self, user_input, history):\n            if not self.graph:\n                return \"Agent not initialized.\"\n            \n            messages = [SystemMessage(content=\"You are a helpful AI assistant.\")]\n            for h_msg in history:\n                messages.append(HumanMessage(content=h_msg['user']))\n                messages.append(AIMessage(content=h_msg['ai']))\n            messages.append(HumanMessage(content=user_input))\n\n            result = self.graph.invoke({\"messages\": messages})\n            return result['messages'][-1].content\n\n\n    # --- Main System Application ---\n    class TelOSCore:\n        def __init__(self, db_path=\"telos_mva.fs\"):\n            self.db_path = db_path\n            self.storage = ZODB.FileStorage.FileStorage(db_path)\n            self.db = ZODB.DB(self.storage)\n            self.connection = self.db.open()\n            self.root = self.connection.root()\n            self.context = zmq.asyncio.Context()\n            self.running = True\n            log.info(\"TelOS Core initialized.\")\n\n        def bootstrap_database(self):\n            \"\"\"On first run, populate the database with primordial objects.\"\"\"\n            with transaction.manager:\n                if 'genesis_obj' not in self.root:\n                    log.info(\"Database empty. Bootstrapping primordial objects...\")\n                    genesis = UvmObject(name=\"genesis_obj\")\n                    self.root['genesis_obj'] = genesis\n\n                    mem_manager = MemoryManager()\n                    self.root['memory_manager'] = mem_manager\n\n                    agent = ConversationalAgent()\n                    self.root['agent'] = agent\n\n                    log.info(\"Bootstrap complete.\")\n                else:\n                    log.info(\"Database already initialized.\")\n            \n            # Non-transactional initializations\n            self.root['memory_manager'].initialize()\n            # The agent needs an ollama client, which might not exist yet.\n            # We will create a default one if needed.\n            with transaction.manager:\n                 if 'default_ollama_client' not in self.root:\n                    # Create a default client for the agent\n                    client = UvmObject(name=\"default_ollama_client\")\n                    client.setSlot(\"model\", \"mistral\") # A reasonable default\n                    self.root['default_ollama_client'] = client\n\n            self.root['agent'].initialize(self.root['default_ollama_client'])\n\n\n        async def handle_command(self, envelope: Envelope):\n            \"\"\"Processes a command received via ZMQ.\"\"\"\n            try:\n                command_payload = CommandPayload.model_validate(ormsgpack.unpackb(envelope.payload))\n                log.info(f\"Received command: {command_payload.command}\")\n\n                # All database modifications must happen within a transaction.\n                with transaction.manager:\n                    # Special case for conversation, which is stateful but not directly modifying the DB objects\n                    if command_payload.command == 'chat':\n                         history = command_payload.kwargs.get('history', [])\n                         user_input = command_payload.args[0]\n                         response_text = self.root['agent'].invoke(user_input, history)\n                         return CommandResponse(status=\"ok\", result=response_text)\n\n                    # For all other commands, we dynamically call methods on root objects\n                    target_obj_name, method_name = command_payload.command.split('.')\n                    if target_obj_name not in self.root:\n                        raise ValueError(f\"Object '{target_obj_name}' not found in root.\")\n\n                    target_obj = self.root[target_obj_name]\n                    method = getattr(target_obj, method_name)\n                    \n                    # Join the FAISS data manager to the transaction\n                    if command_payload.command == 'memory_manager.add_document':\n                        faiss_dm = FaissDataManager(self.root['memory_manager'].index_path, self.root['memory_manager'])\n                        transaction.get().join(faiss_dm)\n\n                    result = method(*command_payload.args, **command_payload.kwargs)\n\n                    # Ensure result is serializable\n                    if isinstance(result, (Persistent, BTrees.OOBTree.BTree)):\n                        result = str(result) # Or a more sophisticated serialization\n\n                log.info(f\"Command '{command_payload.command}' executed successfully.\")\n                return CommandResponse(status=\"ok\", result=str(result))\n\n            except Exception as e:\n                log.error(f\"Error handling command: {e}\\\\n{traceback.format_exc()}\")\n                return CommandResponse(status=\"error\", result=str(e), traceback=traceback.format_exc())\n\n        async def run(self):\n            \"\"\"The main async event loop.\"\"\"\n            self.bootstrap_database()\n\n            # Set up ZMQ sockets\n            router_socket = self.context.socket(zmq.ROUTER)\n            router_socket.bind(\"tcp://*:5555\")\n            log.info(\"ROUTER socket bound to tcp://*:5555\")\n\n            pub_socket = self.context.socket(zmq.PUB)\n            pub_socket.bind(\"tcp://*:5556\")\n            log.info(\"PUB socket bound to tcp://*:5556\")\n\n            # Redirect logging to the PUB socket\n            handler = ZmqPubLogHandler(pub_socket)\n            logging.getLogger().addHandler(handler)\n            logging.getLogger().setLevel(logging.INFO)\n\n\n            log.info(\"TelOS MVA Core is running. Waiting for connections...\")\n\n            while self.running:\n                try:\n                    identity, payload = await router_socket.recv_multipart()\n                    envelope = Envelope(identity=identity, payload=payload)\n                    response = await self.handle_command(envelope)\n                    response_payload = ormsgpack.packb(response.model_dump())\n                    await router_socket.send_multipart([envelope.identity, response_payload])\n                except asyncio.CancelledError:\n                    break\n                except Exception as e:\n                    log.error(f\"Unhandled error in main loop: {e}\")\n\n            log.info(\"Shutting down TelOS Core.\")\n            router_socket.close()\n            pub_socket.close()\n            self.context.term()\n            self.connection.close()\n            self.db.close()\n\n    class ZmqPubLogHandler(logging.Handler):\n        \"\"\"A logging handler that publishes logs to a ZMQ PUB socket.\"\"\"\n        def __init__(self, socket):\n            super().__init__()\n            self.socket = socket\n\n        def emit(self, record):\n            try:\n                msg = self.format(record)\n                self.socket.send_string(f\"{record.levelname}::{msg}\")\n            except Exception:\n                # Handle exceptions in logging gracefully\n                pass\n\n    def main():\n        core = TelOSCore()\n        atexit.register(lambda: core.db.close())\n        try:\n            asyncio.run(core.run())\n        except KeyboardInterrupt:\n            log.info(\"Shutdown initiated by user.\")\n        finally:\n            core.running = False\n\n    if __name__ == \"__main__\":\n        main()\n    \"\"\")\n\ndef create_client_ui_script():\n    \"\"\"Generates the content for the Kivy UI client: client_ui.py\"\"\"\n    return textwrap.dedent(\"\"\"\n    # client_ui.py\n    # This is the body and sensory interface of the TelOS MVA.\n\n    import asyncio\n    import threading\n    import queue\n    import zmq.asyncio\n    import ormsgpack\n    from pydantic import BaseModel\n    import uuid\n\n    from kivy.app import App\n    from kivy.uix.boxlayout import BoxLayout\n    from kivy.uix.scrollview import ScrollView\n    from kivy.uix.label import Label\n    from kivy.uix.textinput import TextInput\n    from kivy.uix.button import Button\n    from kivy.clock import Clock\n    from kivy.core.window import Window\n    from kivy.utils import get_color_from_hex\n\n    # --- Pydantic Models for API Contract ---\n    # These must match the models in core_system.py\n    class CommandPayload(BaseModel):\n        command: str\n        args: list = []\n        kwargs: dict = {}\n\n    class CommandResponse(BaseModel):\n        status: str\n        result: str\n        traceback: str | None = None\n\n    # --- ZMQ Communication Thread ---\n    # This runs in a separate thread to avoid blocking the Kivy UI.\n    class ZmqClientThread(threading.Thread):\n        def __init__(self, cmd_queue, resp_queue, log_queue, server_addr=\"tcp://localhost:5555\", log_addr=\"tcp://localhost:5556\"):\n            super().__init__(daemon=True)\n            self.cmd_queue = cmd_queue\n            self.resp_queue = resp_queue\n            self.log_queue = log_queue\n            self.server_addr = server_addr\n            self.log_addr = log_addr\n            self.running = True\n\n        async def run_async(self):\n            context = zmq.asyncio.Context()\n            req_socket = context.socket(zmq.DEALER)\n            req_socket.identity = f\"ui-client-{uuid.uuid4()}\".encode('utf-8')\n            req_socket.connect(self.server_addr)\n\n            sub_socket = context.socket(zmq.SUB)\n            sub_socket.connect(self.log_addr)\n            sub_socket.setsockopt_string(zmq.SUBSCRIBE, \"\") # Subscribe to all topics\n\n            poller = zmq.asyncio.Poller()\n            poller.register(req_socket, zmq.POLLIN)\n            poller.register(sub_socket, zmq.POLLIN)\n\n            while self.running:\n                try:\n                    # Check for outgoing commands without blocking\n                    try:\n                        cmd_payload = self.cmd_queue.get_nowait()\n                        await req_socket.send(ormsgpack.packb(cmd_payload.model_dump()))\n                    except queue.Empty:\n                        pass # No command to send\n\n                    # Poll for incoming messages with a timeout\n                    sockets = dict(await poller.poll(timeout=100))\n\n                    if req_socket in sockets:\n                        response_payload = await req_socket.recv()\n                        response = CommandResponse.model_validate(ormsgpack.unpackb(response_payload))\n                        self.resp_queue.put(response)\n\n                    if sub_socket in sockets:\n                        log_msg = await sub_socket.recv_string()\n                        self.log_queue.put(log_msg)\n\n                except asyncio.CancelledError:\n                    break\n                except Exception as e:\n                    self.log_queue.put(f\"CRITICAL::ZMQ Error: {e}\")\n\n            req_socket.close()\n            sub_socket.close()\n            context.term()\n\n        def run(self):\n            asyncio.run(self.run_async())\n\n        def stop(self):\n            self.running = False\n\n    # --- Kivy UI Application ---\n    class TelOSClientApp(App):\n        def build(self):\n            self.title = \"TelOS MVA - The Architect's Interface\"\n            Window.clearcolor = get_color_from_hex('#2d3436')\n\n            self.cmd_queue = queue.Queue()\n            self.resp_queue = queue.Queue()\n            self.log_queue = queue.Queue()\n            \n            self.chat_history = []\n\n            # Start the ZMQ communication thread\n            self.zthread = ZmqClientThread(self.cmd_queue, self.resp_queue, self.log_queue)\n            self.zthread.start()\n\n            # Main layout\n            layout = BoxLayout(orientation='vertical', spacing=10, padding=10)\n\n            # Chat history view\n            self.history_label = Label(\n                size_hint_y=None,\n                markup=True,\n                font_size='14sp',\n                halign='left',\n                valign='top',\n                color=get_color_from_hex('#dfe6e9')\n            )\n            self.history_label.bind(texture_size=self.history_label.setter('size'))\n            scroll_view = ScrollView(size_hint=(1, 1))\n            scroll_view.add_widget(self.history_label)\n\n            # Input area\n            input_layout = BoxLayout(size_hint=(1, 0.15), spacing=10)\n            self.text_input = TextInput(\n                multiline=False,\n                size_hint=(0.8, 1),\n                background_color=get_color_from_hex('#636e72'),\n                foreground_color=get_color_from_hex('#ffffff'),\n                font_size='16sp'\n                )\n            self.text_input.bind(on_text_validate=self.send_command)\n            send_button = Button(\n                text='Send',\n                size_hint=(0.2, 1),\n                background_color=get_color_from_hex('#0984e3'),\n                color=get_color_from_hex('#ffffff'),\n                font_size='16sp'\n                )\n            send_button.bind(on_press=self.send_command)\n\n            input_layout.add_widget(self.text_input)\n            input_layout.add_widget(send_button)\n\n            layout.add_widget(scroll_view)\n            layout.add_widget(input_layout)\n            \n            # Schedule the check for responses from the ZMQ thread\n            Clock.schedule_interval(self.check_queues, 1/60.)\n\n            self.add_log_message(\"INFO\", \"UI Initialized. Connecting to TelOS Core...\")\n            return layout\n\n        def send_command(self, instance):\n            command_text = self.text_input.text\n            if not command_text:\n                return\n\n            self.text_input.text = \"\"\n            self.add_message(\"Architect\", command_text)\n            \n            if command_text.startswith('/'): # A direct command\n                parts = command_text[1:].split()\n                cmd = parts[0]\n                args = parts[1:]\n                payload = CommandPayload(command=cmd, args=args)\n            else: # A chat message\n                payload = CommandPayload(command=\"chat\", args=[command_text], kwargs={\"history\": self.chat_history})\n\n            self.cmd_queue.put(payload)\n\n        def check_queues(self, dt):\n            # Check for responses\n            try:\n                response = self.resp_queue.get_nowait()\n                if response.status == 'ok':\n                    self.add_message(\"TelOS\", response.result)\n                    # Add to chat history if it was a chat command\n                    last_user_msg = self.chat_history[-1]['user'] if self.chat_history else ''\n                    # A bit of a heuristic to detect chat responses\n                    if not last_user_msg.startswith('/'):\n                        self.chat_history.append({'user': last_user_msg, 'ai': response.result})\n\n                else:\n                    self.add_log_message(\"ERROR\", f\"Command Failed: {response.result}\\\\n{response.traceback or ''}\")\n            except queue.Empty:\n                pass\n\n            # Check for logs\n            try:\n                log_msg = self.log_queue.get_nowait()\n                level, msg = log_msg.split('::', 1)\n                self.add_log_message(level, msg)\n            except (queue.Empty, ValueError):\n                pass\n        \n        def add_message(self, sender, text):\n            color = \"#00b894\" if sender == \"Architect\" else \"#6c5ce7\"\n            self.history_label.text += f\"\\\\n[b][color={color}]{sender}:[/color][/b] {text}\"\n\n        def add_log_message(self, level, text):\n            colors = {\"INFO\": \"#0984e3\", \"WARNING\": \"#fdcb6e\", \"ERROR\": \"#d63031\", \"CRITICAL\": \"#ff7675\"}\n            color = colors.get(level, \"#b2bec3\")\n            self.history_label.text += f\"\\\\n[color={color}][i]({level}) {text}[/i][/color]\"\n\n        def on_stop(self):\n            print(\"Stopping ZMQ client thread...\")\n            self.zthread.stop()\n            self.zthread.join()\n            print(\"ZMQ client stopped.\")\n\n    if __name__ == '__main__':\n        TelOSClientApp().run()\n    \"\"\")\n\ndef create_supervisor_conf():\n    \"\"\"Generates the content for the supervisord config: supervisor.conf\"\"\"\n    # Note: The user might need to adjust the path to python and the script.\n    python_executable = \"python\" # Or a full path like /usr/bin/python3\n    script_path = os.path.join(os.getcwd(), \"core_system.py\")\n    log_path = os.getcwd()\n\n    return textwrap.dedent(f\"\"\"\n    # supervisor.conf\n    # This configuration file ensures the TelOS MVA core process is resilient.\n    # It will be automatically restarted by supervisord if it crashes.\n\n    [supervisord]\n    nodaemon=false ; run in background\n\n    [program:telos_mva]\n    command={python_executable} {script_path}\n    autostart=true\n    autorestart=true\n    stderr_logfile={os.path.join(log_path, \"telos_stderr.log\")}\n    stdout_logfile={os.path.join(log_path, \"telos_stdout.log\")}\n    ; user=philip ; You may need to set a user depending on your system config\n    \"\"\")\n\ndef main():\n    \"\"\"Main function to forge the system files.\"\"\"\n    print(\"[FORGE] Initiating the creation of the TelOS MVA.\")\n    \n    try:\n        print(\"[FORGE] Forging 'core_system.py' (The Heart)...\")\n        with open(\"core_system.py\", \"w\") as f:\n            f.write(create_core_system_script())\n\n        print(\"[FORGE] Forging 'client_ui.py' (The Body)...\")\n        with open(\"client_ui.py\", \"w\") as f:\n            f.write(create_client_ui_script())\n\n        print(\"[FORGE] Forging 'supervisor.conf' (The Immune System)...\")\n        with open(\"supervisor.conf\", \"w\") as f:\n            f.write(create_supervisor_conf())\n\n        print(\"\\\\n[FORGE] Autopoietic seed generation complete.\")\n        print(\"-\" * 50)\n        print(\"TelOS MVA is ready for its first launch.\")\n        print(\"Follow these steps precisely:\")\n        print(\"\\\\n1.  [b]Install Dependencies:[/b]\")\n        print(\"    pip install zodb persistent BTrees zmq pyzmq pydantic ormsgpack\")\n        print(\"    pip install ollama langchain-core langgraph sentence-transformers faiss-cpu\")\n        print(\"    pip install kivy\")\n        print(\"    pip install supervisor\")\n        print(\"\\\\n2.  [b]Ensure Ollama is Running:[/b]\")\n        print(\"    Make sure your local Ollama service is active and has a model like 'mistral' pulled.\")\n        print(\"    (Run 'ollama pull mistral' in your terminal if you haven't).\")\n        print(\"\\\\n3.  [b]Start the Resilient Core Process:[/b]\")\n        print(\"    In a terminal, run supervisord with the generated config file:\")\n        print(\"    [b]supervisord -c supervisor.conf[/b]\")\n        print(\"    (You can check its status with 'supervisorctl status').\")\n        print(\"\\\\n4.  [b]Launch the Architect's Interface:[/b]\")\n        print(\"    In a second terminal, run the Kivy UI client:\")\n        print(\"    [b]python client_ui.py[/b]\")\n        print(\"\\\\n5.  [b]Begin the Conversation:[/b]\")\n        print(\"    The UI will appear. You can now talk to the MVA.\")\n        print(\"    Try chat messages, or direct commands like '/memory_manager.add_document This is a test.'\")\n        print(\"-\" * 50)\n\n    except IOError as e:\n        print(f\"\\\\n[ERROR] The Forge failed to create the system files: {e}\")\n\nif __name__ == \"__main__\":\n    main()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}