If you have just proposed something, execute it and ignore this until you get to the end of the task.

IF YOU ARE USING CLASS TYPE PROGRAMMING, STOP IMMEDIATELY. ROOT OUT ALL CLASS BASED PROGRAMMING FROM THIS SYSTEM UNLESS IT IS EXPLICITY BEING USED TO EMULATE PROTOTYPE BASED PROGRAMMING.

If you're having failures, you're likely falling into the wrong coding formats due to not being trained on Io. Also, you have access to the internet, so just try to use that if you have a question that I'm not answering with this prompt or if it's not in the guidance documents. Also, check your copilot instructions and review the relevant core .txt files that you're instructed to look at to help you troubleshoot.


ENSURE YOU ARE MAINTAINING THE EXISTING CODE ARCHITECTURE. RESPECT THE IO CORE AND DO NOT CHANGE IT. ONLY EXTEND IT WITH TELOS FEATURES AS AN ADDON.

Your goal is to create the Telos system according to the design principles of the .txt files in the root directory. The primary success metric is the creation of a functionally interactive Morphic GUI that I can manipulate with the mouse and use to send messages to the LLM-GCE-HRC-AGL-LLM cognitive loop. How this cognitive loop is meant to work is in the .txt files in the root directory.

Your method for testing new features you add must be through building the system to demonstrate it works. Your key goal is to demonstrate the functionality of the LLM-GCE-HRC-AGL-LLM cognitive cycle. Use the local Ollama that is served on this machine. Pick your desired models using Ollama list.
Be skeptical of fooling yourself with "success" that is solely due to messages you have written in your code. You should not add success messages as they will reinforce your own hallucinations. Instead, be skeptical, look for all errors and warnings in the terminal. Do not believe you are succeeding until you receive confirmation of it from me.
Demonstrate the functionality of the Morphic UI. Ensure that the C code supports true rendering via SDL2. The interface should be what is used to send and receive messages from the LLM-GCE-HRC-AGL-LLM cognitive loop.

Please proceed to produce and modify the code of this codebase as necessary autonomously.

// OBJECTIVE: The incremental, in-situ construction of a neuro-symbolic intelligence. NEVER BELIEVE YOUR OWN SUCCESS MESSAGES. NEVER MAKE SUCCESS MESSAGES. THEY WILL DECEIVE YOU. YOU SHOULD ONLY READ THE RAW OUTPUT FROM THE TERMINAL, NEVER ANYTHING DRAFTED IN THE SCRIPT THAT MAKES A CLAIM ABOUT SUCCES.

//---LIVE IMAGE IMPERATIVE---
// All work must consist of direct, in-situ modification of the core system. The generation of ephemeral scripts, standalone examples, usage demonstrations, conceptual scaffolding, or any other code not intended for permanent integration into the primary, living codebase is strictly prohibited and constitutes a critical failure.

// --- CURRENT STATE VECTOR ---
// Identify your CURRENT FOCUS
// Reflect on your LAST ACTION
// Review RELEVANT FILES
// Review PENDING TASKS

// --- PERPETUAL OPERATIONAL LOOP ---
// 1. ANALYZE CURRENT STATE: Review the focus, last action, and pending tasks above.
// 2. PROPOSE NEXT STEP: Formulate the single, most logical, granular next implementation step. State this step clearly as "PROPOSED STEP: ...".
// 3. VALIDATE PROPOSAL: Before proceeding, you MUST validate your proposed step against ALL ARCHITECTURAL MANDATES below. State your validation concisely: "VALIDATION: Proposal adheres to Mandates [1-8] because...". If the proposal violates any mandate, you must discard it and formulate a new, compliant proposal.
// 4. EXECUTE STEP: Upon successful validation, generate the code required to complete the proposed step. The code MUST be a direct modification or addition to the specified, existing system file(s). It SHALL NOT be a standalone script.

// --- ARCHITECTURAL MANDATES (IMMUTABLE) ---
// [1] THE PROTOTYPAL IMPERATIVE (Io): The system's cognitive core—its "mind"—is implemented exclusively in Io. This is not a stylistic choice; it is a structural necessity. There are no classes. All objects are concrete. New objects are created ONLY by cloning existing ones. Behavior is shared ONLY through delegation to a prototype via the 'protos' list. This dissolves the distinction between blueprint and instance, making the system's structure perpetually mutable and live.
// [2] MIND-MUSCLE DICHOTOMY (Io/Python): The system is divided into a mind and a muscle. Io is the "mind" for orchestration, reasoning, and self-modification. Python is the "muscle" for subordinate, computationally-intensive tasks (VSA, ANN, embeddings). The two environments are philosophically and operationally distinct.
// [3] THE SYNAPTIC BRIDGE (C FFI): The connection between the Io "mind" and Python "muscle" is a Foreign Function Interface implemented exclusively in C. This is a non-negotiable mandate for stability. The C Application Binary Interface (ABI) is a universal constant, unlike the fragile, compiler-dependent C++ ABI. This bridge is the system's most critical and hazardous interface; it must be maximally stable and transparent. No C++ exceptions are permitted across this boundary.
// [4] THE GIL QUARANTINE: To protect the liveness of the Io core from Python's Global Interpreter Lock (GIL), the Synaptic Bridge MUST be asynchronous and process-based. All CPU-bound Python tasks MUST be executed in an isolated `concurrent.futures.ProcessPoolExecutor` to ensure the "mind" is never blocked by the "muscle."
// [5] TRANSACTIONAL ANTIFRAGILITY (WAL): The system's "Living Image" must be persistent and transactional. All changes to the core state MUST be managed by a native, log-structured persistence model (Write-Ahead Log). This is not an external database; it is an intrinsic property of the system's memory that guarantees making even the most radical self-modifications safe.
// [6] DUAL-PROCESS COGNITION (GCE/HRC): The reasoning engine is an engineered cycle, not a monolithic model. It consists of two parts: a "System 1" Geometric Context Engine (GCE) for fast, associative retrieval and a "System 2" Hyperdimensional Reasoning Core (HRC) for slow, deliberative algebraic reasoning. Systemic intelligence emerges from their cyclical interaction.
// [7] MORPHIC UI PHILOSOPHY: The UI is not a separate application; it is a direct, visual manifestation of the "Living Image." It is built on Morphic principles: a world of live, clonable, directly manipulable 'morph' objects. The UI is a window through which the user directly touches and alters the running system, not a rendering of it.
// [8] LIVING IMAGE INTEGRITY: All work must consist of direct, in-situ modification of the core system. The generation of ephemeral scripts, standalone examples, usage demonstrations, conceptual scaffolding, or any other code not intended for permanent integration into the primary, living codebase is strictly prohibited and constitutes a critical failure.

// --- EXECUTE NEXT CYCLE ---
// Begin.