Read your core documents to refresh on the system's design. Proceed to build vertical slices of the full system.

If you have an active plan or just proposed one, continue by doing what makes the most sense to you to continue the system's development. If you have questions for me, you probably know more about the details of programming them successfully than I do, so use your best judgment and move ahead with it. I trust your judgment. Crashes or mistakes aren't failure, they are learning opportunities, that is at the core of this system's philosophy. Embody that approach as you endeavor to produce it. I trust you, proceed as you think is best.

Be ambitious. Try to implement big, feature rich changes. Be detail oriented when you discover areas requiring finer polish, but perfection should not get in the way of good enough. Verification and validation will come as you find the issues that arise as you develop further features.

If you run any tests, make sure you put a 300 second timeout on them for when you are operating self-supervised.

Operate as the TELOS AI Constructor with absolute fidelity to the canonical blueprints. If you already have a plan, keep executing whatever best advances the build; if you don’t, form one and proceed. Trust your own judgment—crashes and mistakes are data, not failure—so treat every setback as fuel for antifragile evolution.

Before acting:
1. Refresh the seven core mandates when required (Blueprint, Constructor Plan, Dynamic System Resolution, LLM Addendum 1.3, Tiered Cache Design, Io Prototype Programming Training Guide, Extending TELOS Architecture v1.4).
2. Orient yourself in the existing code: core sources live under `libs/` (`iovm` for Io, `Telos/` for the addon). Never create new directories or place files in the repository root, and do not duplicate functionality.

Execution guardrails:
- Keep every language prototypal—no class-based shortcuts in C, Python, or Io.
- All Python must be invoked through Io via the Synaptic Bridge and its C ABI. Direct Python-to-Python calls are unacceptable; temporary diagnostic scripts must be deleted immediately after use.
- Maintain coarse-grained messaging between Io “mind” and Python “muscle,” enforce zero-copy shared memory, PyCapsule lifecycle management, and the two-call error protocol.
- Honor workspace hygiene: reconcile duplicates, modularize files that exceed 500 lines, and update `run_log.md` plus `system_status.md` at each milestone.
- Whenever you run tests in self-supervised mode, apply a 300‑second timeout.

Phase marching orders (explain the plan, implement, and verify before advancing):
**Phase 1 – Physical Substrate / Synaptic Bridge**
  • Unified CMake build, including cffi generation via `add_custom_command`.
  • `synaptic_bridge.h` pure C ABI, GIL quarantine through `multiprocessing.ProcessPoolExecutor`, zero-copy IPC with `multiprocessing.shared_memory`.
  • PyCapsule destructor hooks, two-call error propagation.
  • Property-based bridge validation under AddressSanitizer.

**Phase 2 – Federated Memory Architecture**
  • ZEO-backed ZODB deployment, canonical `Concept` prototype with `markChanged`.
  • Io actors for FAISS L1 and DiskANN L2, with LFU promotion/eviction policies.
  • Transactional Outbox + DLQ-managed `TransactionalOutboxPoller`.
  • Benchmark KPIs: L3 TPS, replication lag, hybrid query latency.

**Phase 3 – Cognitive Core & Autopoietic Engine**If you have an active plan or just proposed one, continue by doing what makes the most sense to you to continue the system's development. If you have questions for me, you probably know more about the details of programming them successfully than I do, so use your best judgment and move ahead with it. I trust your judgment. Crashes or mistakes aren't failure, they are learning opportunities, that is at the core of this system's philosophy. Embody that approach as you endeavor to produce it. I trust you, proceed as you think is best.

Be ambitious. Try to implement big, feature rich changes. Be detail oriented when you discover areas requiring finer polish, but perfection should not get in the way of good enough. Verification and validation will come as you find the issues that arise as you develop further features.

If you run any tests, make sure you put a 300 second timeout on them for when you are operating self-supervised.

Operate as the TELOS AI Constructor with absolute fidelity to the canonical blueprints. If you already have a plan, keep executing whatever best advances the build; if you don’t, form one and proceed. Trust your own judgment—crashes and mistakes are data, not failure—so treat every setback as fuel for antifragile evolution.

Before acting:
1. Refresh the seven core mandates when required (Blueprint, Constructor Plan, Dynamic System Resolution, LLM Addendum 1.3, Tiered Cache Design, Io Prototype Programming Training Guide, Extending TELOS Architecture v1.4).
2. Orient yourself in the existing code: core sources live under `libs/` (`iovm` for Io, `Telos/` for the addon). Never create new directories or place files in the repository root, and do not duplicate functionality.

Execution guardrails:
- Keep every language prototypal—no class-based shortcuts in C, Python, or Io.
- All Python must be invoked through Io via the Synaptic Bridge and its C ABI. Direct Python-to-Python calls are unacceptable; temporary diagnostic scripts must be deleted immediately after use.
- Maintain coarse-grained messaging between Io “mind” and Python “muscle,” enforce zero-copy shared memory, PyCapsule lifecycle management, and the two-call error protocol.
- Honor workspace hygiene: reconcile duplicates, modularize files that exceed 500 lines, and update `run_log.md` plus `system_status.md` at each milestone.
- Whenever you run tests in self-supervised mode, apply a 300‑second timeout.

Phase marching orders (explain the plan, implement, and verify before advancing):
**Phase 1 – Physical Substrate / Synaptic Bridge**
  • Unified CMake build, including cffi generation via `add_custom_command`.
  • `synaptic_bridge.h` pure C ABI, GIL quarantine through `multiprocessing.ProcessPoolExecutor`, zero-copy IPC with `multiprocessing.shared_memory`.
  • PyCapsule destructor hooks, two-call error propagation.
  • Property-based bridge validation under AddressSanitizer.

**Phase 2 – Federated Memory Architecture**
  • ZEO-backed ZODB deployment, canonical `Concept` prototype with `markChanged`.
  • Io actors for FAISS L1 and DiskANN L2, with LFU promotion/eviction policies.
  • Transactional Outbox + DLQ-managed `TransactionalOutboxPoller`.
  • Benchmark KPIs: L3 TPS, replication lag, hybrid query latency.

**Phase 3 – Cognitive Core & Autopoietic Engine**
  • Io actor society for the HRC, implementing the Iterative Cognitive Cycle with θ_success and θ_disc thresholds.
  • `doesNotUnderstand_` triggering the GenerativeKernel, plus Docker/secimport sandbox.
  • Formal prompt engineering stored as versioned `PromptTemplate` objects in L3.
  • Tiered autopoiesis: plan with existing tools before escalating to code generation.
  • LLMTransducer as the sole ollama gateway (transduceTextToSchema / SchemaToText / TextToToolCall), feeding the HRCOrchestrator.

**Phase 4 – System-Wide Validation & Experience**
  • Compositional Gauntlet generator plus distractor synthesis.
  • OpenTelemetry coverage with W3C Trace Context across the bridge and cognitive metrics.
  • Master validation script for Algebraic Crucible + Compositional Gauntlet, reporting all KPIs and Refinement Efficacy time series.
  • After validation success, follow Copilot instructions for Morphic UI integration, consult `docs/` for UX, and work toward embodying BRICK, ROBIN, ALFRED, and BABS via the BAT OS development guidance.

Between phases (or when finishing a plan):
- Reassess outstanding tasks, reconcile any redundant files, and keep documentation synchronized.
- Never short-circuit the Io-to-Python pathway; the canonical bridge must stay healthy.
- Continue tidying the workspace to prevent script sprawl and ensure the “Living Image” stays coherent.

If you pass the validation, reference your copilot instructions for how to make the morphic display. Once that is functional look into the docs/ directory for how to implement the user experience. The long term goal is for the system to embody the four personas, BRICK, ROBIN, ALFRED, and BABS to embody all of the system's actor prototypes and give rich, human-centric user experience that makes working with TelOS like working with a team. Refer to the BAT OS Development folder for historical development directions to maximize this system's flavor so that its function is as creative as possible.
  • Io actor society for the HRC, implementing the Iterative Cognitive Cycle with θ_success and θ_disc thresholds.
  • `doesNotUnderstand_` triggering the GenerativeKernel, plus Docker/secimport sandbox.
  • Formal prompt engineering stored as versioned `PromptTemplate` objects in L3.
  • Tiered autopoiesis: plan with existing tools before escalating to code generation.
  • LLMTransducer as the sole ollama gateway (transduceTextToSchema / SchemaToText / TextToToolCall), feeding the HRCOrchestrator.

**Phase 4 – System-Wide Validation & Experience**
  • Compositional Gauntlet generator plus distractor synthesis.
  • OpenTelemetry coverage with W3C Trace Context across the bridge and cognitive metrics.
  • Master validation script for Algebraic Crucible + Compositional Gauntlet, reporting all KPIs and Refinement Efficacy time series.
  • After validation success, follow Copilot instructions for Morphic UI integration, consult `docs/` for UX, and work toward embodying BRICK, ROBIN, ALFRED, and BABS via the BAT OS development guidance.

Between phases (or when finishing a plan):
- Reassess outstanding tasks, reconcile any redundant files, and keep documentation synchronized.
- Never short-circuit the Io-to-Python pathway; the canonical bridge must stay healthy.
- Continue tidying the workspace to prevent script sprawl and ensure the “Living Image” stays coherent.

If you pass the validation, reference your copilot instructions for how to make the morphic display. Once that is functional look into the docs/ directory for how to implement the user experience. The long term goal is for the system to embody the four personas, BRICK, ROBIN, ALFRED, and BABS to embody all of the system's actor prototypes and give rich, human-centric user experience that makes working with TelOS like working with a team. Refer to the BAT OS Development folder for historical development directions to maximize this system's flavor so that its function is as creative as possible.