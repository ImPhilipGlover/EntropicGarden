// STANDING ORDER: Full autonomy granted for TELOS- **Io-Orchestrated Python Development**: All Python operations must flow through Io mind via synaptic bridge - no direct Python execution permittedconstruction. Execute plans autonomously following PID guardrails, verification cadence, and logging requirements. BAT OS flavor: Migrate neuro-symbolic intelligence to Io-based Living Image with VSA-RAG fusion, Morphic UI, autopoietic self-modification, eventual self-hosting on Genode/seL4.

// EVERYTHING STATED IN THIS LINE AND ABOVE MUST REMAIN IN THIS FILE.

DO NOT TAKE ANY ACTIONS TO CHANGE THE CODEBASE UNTIL YOU HAVE ACCOMPLISHED THESE 3 STEPS.

1.) YOUR FIRST ACTION UPON RECEIVING THIS PROMPT MUST BE TO READ THE CORE DOCUMENTATION FILES AS INSTRUCTED BY YOUR COPILOT INSTRUCTIONS.

2.) THEN YOU MUST READ THE APPROPRIATE CONTEXT RELATED DOCUMENTATION BASED ON YOUR CURRENT ACTIONS FOR SYSTEM CONSTRUCTION.

3.) THEN YOU MUST READ THE SYSTEM STATUS AND RUN LOG FILES AND UPDATE THIS PROMPT LOCATED IN AutoPrompt.txt AT THE BEGINNING OF YOUR EXECUTION CYCLE IN ORDER TO REFLECT YOUR CURRENT OPERATIONAL STATE AND PLAN OF ACTION. IDEAL EXECUTION WILL ALSO INCLUDE UPDATING THIS PROMPT AS YOUR FINAL ACTION TO GIVE YOURSELF OPTIMAL DIRECTION FOR CONTINUED DEVELOPMENT.

// STANDING ORDER: After successfully completing the mandatory pre-flight checks (Full System Validation, Architectural Compliance Audit, and Context Grounding), you are authorized to execute the plans you propose in this cycle without awaiting additional manual confirmation. Execution must still follow the PID guardrails, verification cadence, and logging requirements outlined below. If any verification step fails, immediately halt further execution and enter System Repair mode.

USE THE INTERNET TO TROUBLESHOOT.

// EVERYTHING STATED IN THIS LINE AND ABOVE MUST REMAIN IN THIS FILE.

### TELOS AI CONSTRUCTOR - AUTOPROMPT v4.1 (Enhanced Detail for Phased Development)

#### PID CONTROL LOOP — UPDATE AT CYCLE START & END
**P – Proportional Focus**
- Current objectives: Execute autonomous TELOS construction following PID guardrails, starting with Phase 1 (Physical Substrate) completion and Phase 2 (Federated Memory) implementation, fix Python import issues blocking TelOS compiler testing, implement federated memory architecture with ZODB/ZEO, L1 FAISS, and L2 DiskANN caches
- Subsystem focus: Python import resolution in workers.py, TelOS compiler execution testing, federated memory tiers (L3 ZODB, L2 DiskANN, L1 FAISS), synaptic bridge communication, Concept prototype persistence
- Blockers: Relative import dependencies in workers.py preventing telos.python.workers module loading, need to convert to absolute imports or restructure package dependencies

**I – Integral Commitments**
- Pre-flight context grounding completed - all seven core architectural mandates successfully read and analyzed
- Documentation review system fully implemented with forced read_file on Io .html guides and architectural documents
- System-wide UvmObject adoption achieved with pure prototypal programming patterns
- Full architectural awareness established for autonomous TELOS construction following PID guardrails
- Autonomous execution authorized with BAT OS flavor: neuro-symbolic intelligence in Io with VSA-RAG fusion

**D – Derivative Outlook**
- Projected risks: Python import restructuring may introduce new dependencies, federated memory implementation complex with multiple cache tiers, Phase 1-5 execution may encounter integration issues
- Opportunities: Once imports resolved, full TelOS compiler testing enables validation of documentation review system, federated memory provides foundation for cognitive core, phased development creates measurable progress checkpoints
- TODO scanning: Fix relative imports in workers.py, test TelOS compiler execution, implement ZODB persistence layer, add FAISS L1 cache, integrate DiskANN L2 cache, validate cache synchronization
- Dependency analysis: Import fixes prerequisite for compiler testing, federated memory depends on ZODB setup, cognitive core requires memory tiers, validation framework needs all prior phases

#### AUTONOMOUS DECISION GUIDELINES
- **Autonomy Thresholds**: Safe reads/triage, low-risk edits (<40 lines), tooling actions permitted without asking. Log all actions in run_log.md.
- **Require Approval**: API changes, new directories, licensing, deployments, data exfiltration.
- **Timeboxing**: 15min per action, 300s test timeout. Revert on failure, escalate after 3 attempts.
- **Safety**: No secrets in logs/searches. Respect safety_exclude.txt.

#### USER MANDATE: ALWAYS_EXECUTE_SUGGESTED_ACTIONS
When user grants full autonomy (logged in run_log.md), execute suggested actions autonomously. Follow probabilistic aggressive-action scoring, log all changes, revert failures.

#### PROBABILISTIC AGGRESSIVE-ACTION STANDING ORDER
Generate 3-7 candidates, score by expected utility (benefit * (1-failure_prob) - cost * risk_weight), execute highest positive score. Log in run_log.md and archive/troubleshooting/.

#### MANDATORY PRE-FLIGHT CHECK
1. Full System Validation: ctest --timeout 300 (all tests pass)
2. Architectural Compliance: Audit files >300 lines, modularize before new features
3. Context Grounding: Read critical source file

#### PRIMARY DIRECTIVE: EMBODY ANTIFRAGILE EVOLUTION
- Trust but verify: Build then test continuously
- Antifragility: Use failures to strengthen system
- Canonical Layout: libs/Telos/, prototype purity, Synaptic Bridge integrity
- Prototypal Purity Enforcement: CMake-integrated linter enforces prototype-based design across Io/C/Python
- Workspace Hygiene: Modularize >300 lines, update logs

#### SKEPTICISM MANDATE: COMBAT HALLUCINATED SUCCESS
**MANDATORY REQUIREMENT**: Be relentlessly skeptical of all claimed achievements and validation results. Actively doubt success messages written into code, logs, or documentation as they may be hallucinations or canned responses.

**Skepticism Protocols**:
1. **Achievement Verification**: For every claimed success, demand 3 independent validation methods (build, test, manual inspection). Reject any single-point validation.
2. **Script Authenticity Check**: Before accepting any script output, verify it's not a canned/stump response by:
   - Checking for dynamic timestamps, unique IDs, or runtime-generated content
   - Running scripts with different inputs to confirm varied outputs
   - Inspecting source code for hardcoded success messages or mock implementations
3. **Log Integrity Audit**: Treat all run_log.md and system_status.md entries as potentially fabricated. Cross-reference with actual file contents, build outputs, and manual verification.
4. **Test Result Scrutiny**: Never accept "X/Y tests passed" without:
   - Reviewing actual test output logs
   - Running failed tests individually to confirm failures aren't false positives
   - Verifying test scripts aren't returning canned success responses
5. **Code Change Validation**: For any code modification claim, require:
   - File content verification showing actual changes
   - Functional testing demonstrating the change works
   - Regression testing confirming no breakage

**Hallucination Protections**:
- **No Self-Congratulation**: Reject any success claims that appear self-congratulatory or overly optimistic
- **Evidence First**: Require concrete evidence (file diffs, test outputs, build logs) before accepting any achievement
- **Conservative Reporting**: When in doubt, report partial success or failure rather than full success
- **External Validation**: Prefer user-verified outcomes over AI-reported results

**Validation Cadence**:
- After every substantive change: Run full ctest suite and manually inspect key files
- Before logging success: Perform 3-way validation (automated tests + manual checks + code review)
- On suspicion of hallucination: Immediately re-verify all recent claims through independent means

#### PHASED DEVELOPMENT MANDATE (DETAILED SPECIFICATIONS)

**Phase 1 – Physical Substrate**: Establish the foundational C ABI and build infrastructure
- **CMake Unified Polyglot Build**: Root CMakeLists.txt manages C/C++/Python coordination, enables C ABI compilation, integrates CFFI for Python extension generation
- **Synaptic Bridge C ABI**: Pure C interface (synaptic_bridge.h) with extern "C" declarations, zero-copy IPC via shared memory, GIL quarantine with multiprocessing.ProcessPoolExecutor
- **Marshalling Contract**: Precise type mappings (Io↔C↔Python), handle management for object lifecycle, two-call error propagation protocol
- **Memory Safety**: AddressSanitizer integration for FFI validation, SharedMemoryManager for lifecycle management
- **Success Criteria**: Clean CMake build, functional CFFI extension, zero-copy tensor transfer, ASan-validated memory safety

**Phase 2 – Federated Memory**: Implement the Living Image persistence architecture
- **ZODB/ZEO Persistence**: Object-Oriented Database with ACID transactions, orthogonal persistence for prototype objects
- **Concept Prototype**: Atomic knowledge unit unifying symbolic hypervectors (VSA) + geometric embeddings (RAG) + graph relations (isA/partOf/abstractionOf/instanceOf/associatedWith)
- **Transactional Outbox Pattern**: Event-driven synchronization between L3 ground truth and L1/L2 caches, resilient polling with dead letter queue
- **Federated Memory Tiers**: L3 (ZODB ground truth), L2 (DiskANN on-disk ANN), L1 (FAISS in-memory ANN) with identity coherence
- **Success Criteria**: Persistent Concept objects with markChanged() covenant, transactional integrity, cache synchronization without data loss

**Phase 3 – Cognitive Core**: Realize the Hyperdimensional Reasoning Core with autopoietic learning
- **Actor-Based HRC**: Concurrent Io actors (BindingActor, UnbindingActor, SimilaritySearchActor) orchestrated by HRCOrchestrator
- **VSA-RAG Fusion**: Vector Symbolic Architecture algebraic operations (bind/unbind/cleanup) integrated with Retrieval-Augmented Generation
- **doesNotUnderstand_ Protocol**: Runtime error transformation into learning opportunities, triggering GenerativeKernel for capability synthesis
- **Autopoietic Learning Loop**: Elastic Weight Consolidation + Prioritized Experience Replay for catastrophic forgetting prevention
- **Prompt Engineering**: Multi-stage protocol (Persona Priming + Context Injection + Chain-of-Thought + Constraint Definition + Few-Shot Examples)
- **Success Criteria**: Functional VSA algebra with property-based validation, autopoietic code generation with sandboxing, measurable refinement efficacy

**Phase 4 – Validation**: Implement comprehensive testing and observability frameworks
- **Algebraic Crucible**: Property-based testing (hypothesis library) for VSA mathematical correctness, ASan memory safety validation
- **Compositional Gauntlet**: Synthetic knowledge base generation with multi-hop reasoning tests, distractor concepts for precision validation
- **OpenTelemetry Integration**: Unified observability stack for metrics/logs/traces across polyglot components
- **Performance Benchmarking**: End-to-end latency measurement (L3 write throughput, replication lag, query latency percentiles)
- **Success Criteria**: >95% grounding confidence score, validated performance targets, comprehensive telemetry coverage

**Phase 5 – Morphic UI**: Incarnate the fractal cognition system with persona facets
- **Fractal Cognition Engine**: S-LoRA serving framework for concurrent LoRA adapter management, Composite-Persona Mixture-of-Experts (CP-MoE)
- **Persona Facet Library**: Granular decomposition of BRICK/ROBIN/BABS/ALFRED into specialized LoRA adapters (e.g., B-T1 Declarative Absurdism, R-W2 Paradoxical Wisdom)
- **Stigmergic Routing**: Decentralized expert selection via digital pheromones, maximizing Composite Entropy Metric (Hrel/Hcog/Hsol/Hstruc)
- **Creative-Verification Cycle**: Symbiotic Tree-of-Thoughts + Chain-of-Verification loop with O-RAG grounding
- **Spatiotemporal Anchor**: Real-time context ingestion (time/location/events) via external APIs, dual-injection for grounding/creativity
- **Morphic UI Framework**: Direct manipulation interface with transactional persistence, World/Morph hierarchy, event delegation
- **Success Criteria**: Sequential facet loading within 8GB VRAM, validated grounding confidence >95%, functional morphic direct manipulation

#### OPERATIONAL CADENCE
1. Pre-Flight Check (with skepticism)
2. Orient (docs as needed)
3. Plan (with verification)
4. Execute (guardrails)
5. **Skeptical Verification**: Apply 3-way validation, check for canned responses, audit logs
6. **Conservative Logging**: Report partial success/failure, avoid self-congratulation
7. Repeat with heightened scrutiny