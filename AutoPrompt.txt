# NEURO-SYMBOLIC IMPLEMENTATION PLAN - PRIMARY DIRECTIVE
# ================================================================================================
# **MANDATORY EXECUTION**: This is the core focus and blocking requirement for all development work.
# **REFERENCE**: See NEURO_SYMBOLIC_IMPLEMENTATION_PLAN.md for complete technical specifications.
# **SUCCESS CRITERIA**: Homomorphic mapping (correlation > 0.5), reasoning accuracy (>80%), AGL effectiveness, hallucination resistance (<5%)
# **PHASE PRIORITY**: Phase 1 (Foundation) → Phase 2 (Core Algorithm) → Phase 3 (Reasoning Engine) → Phase 4 (Training) → Phase 5 (Integration)
# **PROTOTYPE PURITY**: All implementations must maintain cross-language prototype purity (see PROTOTYPE_PURITY_ARCHITECTURE.md)
# **INTERDEPENDENCE**: Both NEURO_SYMBOLIC_IMPLEMENTATION_PLAN.md and PROTOTYPE_PURITY_ARCHITECTURE.md are inextricably intertwined and must be understood together
# ================================================================================================

**SESSION BOUNDARY: Performing mandatory ContextAwareTriage startup review**

**Proportional (P) - Current Objectives:**
- ✅ SHELL INTEGRATION FIXED: Full terminal integration enabled with command decorations and enhanced features
- ✅ TASKS.JSON CREATED: Comprehensive VS Code tasks configuration with 13 TELOS-specific tasks for immediate shell-integrated development
- ✅ IO PROGRAMMING ENABLED: Direct Io programming capabilities configured with file associations, launch configurations, and execution settings
- ContextAwareTriage COMPLETE: All 4 Io docs + 8 core docs reviewed providing full architectural context
- Verify Io-C-Python bridge operational status and activate if needed using Io best practices
- Integrate all tools into workflow: eradicate_mocks.io, compliance_enforcer.py, io_syntax_checker.sh, PrototypalLinter.io, io_addon_checker.io
- Eradicate all mocks from codebase using eradicate_mocks.io
- Train LLM GCE HRC AGL loop on system source code for self-analysis capabilities
- Launch TelOS AI in background process for collaborative development
- Maintain Io supremacy and prototype purity throughout all development
- Follow Io best practices: prototype-based programming, message passing, differential inheritance
- Ensure all development flows through Io orchestration, not direct Python execution
- Maintain directory hygiene and update FILE_CATALOG.md as needed

**Integral (I) - Accumulated Insights:**
- ✅ Shell Integration Fixed: Diagnosed TERM_PROGRAM issue, updated .bashrc detection and script path, enhanced VS Code terminal profile
- ✅ VS Code Tasks Configuration: 13 TELOS-specific tasks created for immediate shell-integrated development (clean build, incremental build, Io REPL, script execution, testing, AI management)
- ✅ Io Programming Enablement: Direct Io programming configured with file associations (*.io), launch configurations (current file, REPL, tests, compiler), editor settings, and interpreter configuration
- ContextAwareTriage completed: Full architectural knowledge established through systematic review of IoGuide.html, IoCodingStandards.html, IoTutorial.html, Io Prototype Programming Training Guide.txt, NEURO_SYMBOLIC_IMPLEMENTATION_PLAN.md, PROTOTYPE_PURITY_ARCHITECTURE.md
- Io prototype-based programming: Message passing, differential inheritance, delegation chains, factory functions, persistence covenant
- Neuro-symbolic system: GCE→HRC→AGL pipeline, Laplace-HDC encoder, ConceptFractal OODB, multi-tiered memory (L1 FAISS, L2 DiskANN, L3 ZODB)
- System architecture: Io cognitive core, C synaptic bridge, Python computational substrate with UvmObject patterns
- Build system: CMake-based polyglot build with Io orchestration, synaptic bridge enforcement
- Tool ecosystem: eradicate_mocks.io, compliance_enforcer.py, io_syntax_checker.sh, PrototypalLinter.io, io_addon_checker.io, memory_optimizer.io, chaos_engineering_injector.io, cognitive_evolution_monitor.io
- Autopoietic processes: Self-healing through memory optimization, chaos engineering, cognitive evolution monitoring
- Prototype purity: Cross-language consistency through UvmObject (Python), handle-based ABI (C), pure prototypes (Io)
- Io supremacy: All Python operations must flow through Io orchestration via synaptic bridge, never direct execution

**Derivative (D) - Projected Risks & Opportunities:**
- Risk: Io-C-Python bridge may not be fully operational - requires immediate verification and activation
- Opportunity: Complete architectural context enables confident autonomous development with Io best practices
- Risk: Tool integration complexity and potential conflicts - implement incrementally with validation
- Opportunity: Integrated tool workflow will enable self-healing, validation, and autonomous improvement cycles
- Risk: Mock eradication may break dependencies or reveal incomplete implementations - implement with comprehensive testing
- Opportunity: Clean codebase will improve system reliability, performance, and neuro-symbolic reasoning accuracy
- Risk: LLM training on source code may introduce hallucinations without proper validation gates
- Opportunity: Self-analysis capabilities will enable autonomous architectural evolution and improvement
- Risk: Prototype purity violations during rapid development - maintain strict Io orchestration discipline
- Opportunity: Pure prototype architecture will enable true neuro-symbolic intelligence and antifragile evolution
- Risk: Directory hygiene neglect during intensive development - implement automated maintenance protocols
- Opportunity: Organized codebase will facilitate collaboration and reduce cognitive load

**Tool Integration Workflow:**
1. **Eradicate Mocks**: Run eradicate_mocks.io at cycle start/end to ensure 0 violations
2. **Compliance Enforcer**: Execute compliance_enforcer.py --dry-run regularly to maintain file preambles
3. **Io Syntax Checker**: Integrate io_syntax_checker.sh into build process for Map clone do() pattern detection
4. **C and Python Syntax Checker**: Run via synaptic bridge in PrototypalLinter.io for cross-language validation
5. **Addon Checker**: Critical for bridge success - run before any bridge operations
6. **Memory Optimizer**: Run memory_optimizer.io for autopoietic memory management and optimization
7. **Chaos Engineering Injector**: Run chaos_engineering_injector.io for antifragile system strengthening
8. **Cognitive Evolution Monitor**: Track cognitive development and suggest architectural improvements
9. **New Tools**: Self-Diagnosis Tool (io_driven_health_check.io), Code Improvement Tool (llm_code_suggestions.io), Source Code Trainer (train_llm_on_source.io), TelOS AI Launcher (launch_telos_ai.io)

**Build Process Integration:**
- Pre-build: Run eradicate_mocks.io, compliance_enforcer.py, io_syntax_checker.sh (direct system calls)
- Build: Integrate C/Python syntax checkers via PrototypalLinter.io
- Post-build: Load TelosBridge after build, run Addon Checker, Cognitive Evolution Monitor, self-diagnosis tool (via bridge methods)
- Continuous: Launch TelOS AI in background for monitoring and co-creation

**Directory Hygiene Protocols:**
- Tools/scripts: Place in scripts/ directory
- Documentation: docs/ directory
- Build artifacts: build/ directory
- Temporary files: temp/ directory
- Archives: archive/ directory
- No scattering in root directory

**Mandatory Startup Reading List:**
1. IoGuide.html
2. IoCodingStandards.html
3. IoTutorial.html
4. Io_Syntax_and_Best_Practices_Guide.md
5. NEURO_SYMBOLIC_IMPLEMENTATION_PLAN.md (MANDATORY - Complete neuro-symbolic reasoning roadmap)
6. PROTOTYPE_PURITY_ARCHITECTURE.md (MANDATORY - Cross-language prototype purity requirements)

**File Catalog Reference:** See docs/FILE_CATALOG.md for comprehensive capability summary

**Context Triage Schedule:** Perform full ContextAwareTriage every 15 minutes or before major decisions

**Skepticism Protocol:** Every claim requires 3-way validation (manual inspection, tool verification, independent check) - no self-belief allowed