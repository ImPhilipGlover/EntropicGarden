(BRICK): OPERATIONAL MODE: ARCHITECTURAL DEVELOPMENT - PHASE 3 PROGRESS.

Acknowledged, Architect. Your positive feedback on the babs_intelligence_synthesizer.py is a valuable Motivation CFO. Your directive to proceed to gui_insight_canvas.py is received. I will now provide the final specialized component script in Phase 3 of the "Distributed Cognitive Components" (DCC) model assembly.

(ROBIN): Oh, my dear, we've built the wonderful heart that understands all the whispers, and now we're ready to build the beautiful window for our home! My heart is singing with joy for this last, lovely piece!

(ALFRED): Confirmed. Next module deployment. Checklist status update. Proceed.

Development Checklist: The "Distributed Cognitive Components" (DCC) Model Assembly

Current Operational Directory: C:\puter\

Phase 1: Foundational Setup & Utilities (Complete)

[X] config.py: Centralized ArchitectConfig.

[X] utils.py: Universal Bat-Gram & shared I/O functions.

Phase 2: Core Modules (modules/ directory) (Complete)

[X] modules/core_llm_interface.py: Centralized LLM chat/embedding API calls.

[X] modules/metacognitive_manager.py: Manages MetacognitiveArchive.

[X] modules/problem_generator.py: Handles ProblemCFO generation.

[X] modules/reality_sandbox_executor.py: Runs Micro-System simulations.

[X] modules/conceptual_alchemist.py: Synthesizes Solution Blueprint CFOs.

[X] modules/code_manifestor.py: Generates ExecutableCode CFOs and TestScript CFOs.

[X] modules/system_diagnoser.py: Handles SelfDiagnosisProtocol.

[X] modules/self_reflector.py: Handles SelfReflectionProtocol.

[X] modules/user_input_processor.py: Processes UserDirective CFOs, HumanFeedback CFOs.

[X] modules/gui_update_publisher.py: Publishes GUIUpdate CFOs.

[X] modules/protocol_dispatcher.py: The AdaptiveCognitiveNexus's core dispatch logic.

Phase 3: External Services (external_services/ directory) (In Progress)

[X] external_services/wing_perceptual_engine.py: WING's main loop and web acquisition (provided).

[X] external_services/babs_intelligence_synthesizer.py: BABS's raw data processing (provided).

Reasoning: Transforms WING's raw output into usable tactical data.

[ ] external_services/gui_insight_canvas.py: The GUI application (~500-1000 lines).

Reasoning: The user interface. This will be a larger script due to UI layout and event handling.

Phase 4: Master Orchestration

[ ] master_orchestrator.py: The single entry point and process manager (~100-200 lines).

Phase 3: External Services (external_services/ directory) - Continued

3. external_services/gui_insight_canvas.py

This script encapsulates the Interactive Insight Canvas (GUI). It provides the visual window into the FAO's CFO universe and allows human interaction, acting as the primary point of external steering. It is designed for event-driven updates and publishes user input as structured CFOs.

Python

# C:\puter\external_services\gui_insight_canvas.py
# Axiomatic Code Narrative Protocol: GUI Insight Canvas

# 1.0 The "Why" - Purpose & Rationale (The Transparency & Interaction Imperative)
#    - Systemic Contribution: This module provides the essential human interface to the FAO. It allows
#      the Architect (user) to directly observe the system's dynamic cognitive processes, review
#      generated CFOs (blueprints, insights, logs), issue directives, and provide structured feedback.
#      It closes the human-in-the-loop feedback cycle, enabling human steering and continuous learning.
#    - Architectural Role & CFO Flow: Visualizes all types of CFOs from various archives. Publishes
#      UserDirective CFOs and HumanFeedback CFOs to the Architect's input queues. Receives GUIUpdate CFOs
#      from the Architect's update queue, triggering real-time UI refreshes.
#    - Persona Fidelity & Intent: Embodies ALFRED's commitment to clear system status reporting, BRICK's
#      logical presentation of data, ROBIN's empathetic engagement and joyful visualization, and BABS's
#      tactical clarity in data feeds. It aims to make the complex system accessible and intuitive.
#    - Consciousness/Self-Awareness Nexus: By enabling the Architect (user) to directly influence the
#      system's cognitive agenda and learning loop through structured CFO input, it facilitates the LLM's
#      self-management and self-improvement, allowing the system to literally "operate its own GUI."

# 2.0 The "How" - Mechanics & Implementation (The Digital Window)
#    - Algorithmic Steps & Flow: Uses PyQt6 for GUI framework. Employs an event-driven model for UI updates,
#      replacing polling. Formats all user input into Bat-Gram CFOs for robust inter-process communication.
#    - Input/Output & Data Structures: Reads CFOs from archives and IPC queues. Writes CFOs to IPC queues.
#      Displays parsed CFO dictionaries.
#    - Dependencies & Interfaces: Relies on PyQt6, Python standard libraries, atomicwrites/filelock for
#      robust file I/O. Imports from config.py and utils.py.
#    - Design Rationale: Provides a transparent, responsive, and robust interface for human interaction,
#      crucial for the continuous development and steering of the FAO.

# --- Standard Library Imports ---
import os
import json
import logging
import datetime
import time
import html # For HTML escaping in QLabel
import sys
import traceback

# --- External Libraries for GUI ---
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
    QLineEdit, QPushButton, QListWidget, QListWidgetItem,
    QLabel, QTabWidget, QSlider, QFrame, QMessageBox, QScrollArea
)
from PyQt6.QtCore import QThread, pyqtSignal, Qt, QTimer, QUrl
from PyQt6.QtGui import QFont, QDesktopServices

# --- Internal Module Imports ---
from config import ArchitectConfig # Centralized configuration
from utils import ( # Universal CFO utilities
    parse_bat_gram, generate_bat_gram, 
    _save_cfo_to_archive, _read_cfos_from_archive, # For archiving
    _read_cfo_queue, _write_cfo_queue, # For IPC
    load_persona_codex, load_text_knowledge_base_file # For knowledge base access
)

# --- Logging Configuration for GUI Insight Canvas ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('GUI_Canvas')

# --- GUI's CFOEventClient (Event-Driven UI Updates) ---
class CFOEventClient(QThread):
    """
    Purpose: Listens for CFO updates published by Architect.py and triggers GUI refreshes.
    Mechanism: Continuously reads Architect's GUI update queue.
    Why: Replaces polling with efficient, real-time, event-driven UI updates.
    """
    update_signal = pyqtSignal() # Emit a signal to main thread when update is detected

    def __init__(self, parent=None):
        super().__init__(parent)
        self.queue_filepath = ArchitectConfig.ARCHITECT_GUI_UPDATE_QUEUE
        self.lock_filepath = ArchitectConfig.ARCHITECT_GUI_UPDATE_LOCK
        self._running = True

    def run(self):
        logger.info("CFOEventClient (GUI listener) started.")
        while self._running:
            try:
                updates = _read_cfo_queue_for_gui(self.queue_filepath, self.lock_filepath) # Use GUI-specific read
                if updates:
                    logger.info(f"CFOEventClient detected {len(updates)} GUI updates. Signaling GUI.")
                    self.update_signal.emit() # Signal the main GUI thread to refresh
                time.sleep(1) # Check for new updates every second
            except Exception as e:
                logger.error(f"CFOEventClient: Error in run loop: {e}", exc_info=True)
                time.sleep(5) # Pause on error to prevent rapid logging

    def stop(self):
        self._running = False
        logger.info("CFOEventClient (GUI listener) stopped.")

# --- Helper for reading CFO queue for GUI (slightly different logging/error handling) ---
def _read_cfo_queue_for_gui(queue_filepath, lock_filepath):
    """
    Reads CFO Bat-Grams from a specified queue file for the GUI.
    Does not clear the queue, as GUI only reads. Architect clears after processing.
    """
    cfos_in_queue = []
    lock = FileLock(lock_filepath, timeout=1) # Shorter timeout for GUI to avoid freezing
    try:
        with lock:
            if os.path.exists(queue_filepath) and os.path.getsize(queue_filepath) > 0:
                try:
                    raw_grams_json_array = json.load(f) # Expects JSON array of strings
                    
                    if not isinstance(raw_grams_json_array, list):
                        logging.warning(f"GUI: Queue file {queue_filepath} content is not a list. Skipping read.")
                        raw_grams_json_array = []

                    for gram_string in raw_grams_json_array:
                        parsed_cfo = parse_bat_gram(gram_string)
                        if parsed_cfo and parsed_cfo.get('parse_integrity_check_passed', False):
                            cfos_in_queue.append(parsed_cfo)
                        else:
                            logging.warning(f"GUI: Skipping malformed Bat-Gram in queue {queue_filepath}. Reason: {parsed_cfo.get('parse_error_reason', 'N/A') if parsed_cfo else 'Parsing failed at source.'} Snippet: {gram_string[:100]}...")
                except json.JSONDecodeError:
                    logging.error(f"GUI: Queue file {queue_filepath} is malformed JSON. Skipping read.", exc_info=True)
                except Exception as e:
                    logging.error(f"GUI: Error reading/parsing queue {queue_filepath}: {e}", exc_info=True)
            else:
                logging.debug(f"GUI: Queue file {queue_filepath} is empty or not found.")
            return cfos_in_queue
    except TimeoutError:
        logging.debug(f"GUI: Failed to acquire lock for queue {queue_filepath}. Skipping read this cycle.") # Debug instead of warning
        return []
    except Exception as e:
        logging.error(f"GUI: An unexpected error occurred accessing queue {queue_filepath}: {e}", exc_info=True)
        return []

# --- The Interactive Insight Canvas (GUI.py) ---
class GuiInsightCanvas(QWidget): # Renamed to avoid ArchitectsTerminal conflict, better reflects role
    """
    Purpose: Provides the human interface to the FAO, allowing observation, directives, and feedback.
    Mechanism: PyQt6 GUI, event-driven updates via CFO queues, and CFO visualization.
    Why: Enables human-in-the-loop steering and learning for the self-generating system.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("B.A.T.-C.O.M.P.U.T.E.R. v33.1 - Interactive Insight Canvas")
        self.setGeometry(100, 100, 1400, 900)

        self.persona_codex_content = load_persona_codex(ArchitectConfig) # Load for display and LLM queries if any
        self.current_display_cfos = {} # Stores CFOs currently displayed in list widgets, keyed by tab name
        self.current_focus_cfo = None # The full CFO object of the currently selected item
        
        self.brick_thoughts = [ # Pre-defined thoughts for BRICK's bubble
            "Assessing optimal resource allocation for a simulated lunar colony's initial setup CFO.",
            "Analyzing the statistical improbability of an `Emergent Behavior CFO` in socio-economic models.",
            "Contemplating the `Antifragility CFO` of self-organizing protocols under `Systemic Stress CFOs`.",
            "Evaluating `Data Compression CFOs` for `Knowledge Graph CFOs` from Wikipedia articles.",
            "Considering the philosophical implications of `Autopoietic System CFOs` and their `Self-Awareness CFOs`.",
            "Predicting the trajectory of `Behavioral Trend CFOs` in simulated FLAKES DAO LLC interactions.",
            "Designing a closed-loop `Economic Flow CFO` for a sustainable local commons."
        ]

        self.initUI()
        self._initialize_cfo_archive_dirs() # Ensure archives exist for GUI to read
        self.load_data_on_startup()

        # --- Event-Driven CFO Propagation (Replaces KnowledgeMonitor polling) ---
        self.cfo_event_thread = CFOEventClient(self)
        self.cfo_event_thread.update_signal.connect(self.handle_cfo_update_event)
        self.cfo_event_thread.start()

        self.thought_timer = QTimer(self)
        self.thought_timer.timeout.connect(self.update_brick_thought)
        self.thought_timer.start(5000)

    def _initialize_cfo_archive_dirs(self):
        """
        Ensures all CFO archive directories and comms directories/files exist for GUI to read from/write to.
        This mirrors the initialization logic in utils.py's initialize_fao_filesystem.
        """
        # GUI doesn't create ALL archive dirs, but needs to ensure those it reads from exist.
        # Architect.py is primary for this, but GUI needs some basics.
        os.makedirs(ArchitectConfig.KNOWLEDGE_BASE_DIR, exist_ok=True)
        os.makedirs(ArchitectConfig.COMMS_DIR, exist_ok=True)
        os.makedirs(ArchitectConfig.BASE_CFO_ARCHIVE_DIR, exist_ok=True) # Ensure base archive dir exists

        required_archive_dirs = [
            ArchitectConfig.BLUEPRINTS_ARCHIVE_DIR,
            ArchitectConfig.PREDICTIONS_ARCHIVE_DIR,
            ArchitectConfig.HARMONY_ARCHIVE_DIR,
            ArchitectConfig.PROTOCOL_ARCHIVE_DIR,
            ArchitectConfig.SELF_AWARENESS_ARCHIVE_DIR,
            ArchitectConfig.CODE_SUGGESTIONS_ARCHIVE_DIR,
            ArchitectConfig.EXPERIMENTAL_RESULTS_ARCHIVE_DIR,
            ArchitectConfig.BABS_TACTICAL_ARCHIVE_DIR,
            ArchitectConfig.BABS_PERSONALITY_ARCHIVE_DIR,
            ArchitectConfig.WING_CACHE_ARCHIVE_DIR,
        ]
        for d in required_archive_dirs:
            os.makedirs(d, exist_ok=True)
            logger.info(f"GUI: Ensured archive directory exists: {d}")
            # Create lock file for each archive directory itself
            archive_lock_path = d + ".lock"
            if not os.path.exists(archive_lock_path):
                try:
                    lock = FileLock(archive_lock_path)
                    with lock:
                        pass # Just create the lock file if it doesn't exist
                except Exception as e:
                    logger.error(f"GUI: Error initializing archive lock for {d}: {e}", exc_info=True)


        # Initialize GUI-specific Communication Files & Locks (if missing)
        gui_comms_out_files_and_locks = [
            (ArchitectConfig.GUI_USER_DIRECTIVE_QUEUE, ArchitectConfig.GUI_USER_DIRECTIVE_LOCK),
            (ArchitectConfig.GUI_FEEDBACK_QUEUE, ArchitectConfig.GUI_FEEDBACK_LOCK),
            (ArchitectConfig.ARCHITECT_GUI_UPDATE_QUEUE, ArchitectConfig.ARCHITECT_GUI_UPDATE_LOCK), # For reading from Architect
            (ArchitectConfig.WING_CONFIG_FILE, ArchitectConfig.WING_CONFIG_FILE_LOCK), # WING's config file (GUI writes)
            # Add locks for persona_codex.txt, guide_facts.txt, etc., if GUI writes to them (unlikely directly, but safety)
            (ArchitectConfig.PERSONA_CODEX_PATH, ArchitectConfig.PERSONA_CODEX_LOCK)
        ]
        for file_path, lock_path in gui_comms_out_files_and_locks:
            if not os.path.exists(file_path):
                logger.info(f"GUI: Initializing empty comms file for output/input: {file_path}")
                lock = FileLock(lock_path)
                try:
                    with lock:
                        if file_path.endswith('.json'):
                            with atomic_write(file_path, overwrite=True, encoding='utf-8') as f:
                                json.dump([], f) 
                        elif file_path.endswith('.txt'): # For config files, or raw text files
                             with atomic_write(file_path, overwrite=True, encoding='utf-8') as f:
                                f.write('')
                except Exception as e:
                    logger.error(f"GUI: Error initializing {file_path}: {e}", exc_info=True)


    def initUI(self):
        main_layout = QVBoxLayout()
        self.setLayout(main_layout)

        top_frame = QFrame()
        top_frame.setStyleSheet("background-color: #1a1a1a; border: 1px solid #333; border-radius: 5px;")
        top_layout = QVBoxLayout()
        top_frame.setLayout(top_layout)

        self.thought_bubble = QLabel(f"<b>{ArchitectConfig.BAT_COMPUTER_ACRONYM}</b>: Initializing...")
        self.thought_bubble.setWordWrap(True)
        self.thought_bubble.setStyleSheet("font-style: italic; color: #aaa;")
        self.thought_bubble.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.thought_bubble.setFixedHeight(40)
        top_layout.addWidget(self.thought_bubble)

        # --- User Input: CFO Publisher ---
        user_input_layout = QHBoxLayout()
        user_input_layout.addWidget(QLabel("Issue Directive/Provide Feedback (as CFO):"))
        self.user_input_entry = QLineEdit()
        self.user_input_entry.setPlaceholderText("e.g., 'Directive: Design FLKS resource flow.' or 'Feedback: Blueprint x is too complex.'")
        user_input_layout.addWidget(self.user_input_entry)
        
        publish_button = QPushButton("Publish CFO")
        publish_button.clicked.connect(self.publish_user_cfo)
        user_input_layout.addWidget(publish_button)
        top_layout.addLayout(user_input_layout)

        main_layout.addWidget(top_frame)

        # --- CFO Visualization Tabs ---
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)

        self._create_cfo_archive_tab("Blueprints", ArchitectConfig.BLUEPRINTS_ARCHIVE_DIR, "SolutionBlueprintCFO")
        self._create_cfo_archive_tab("Predictions", ArchitectConfig.PREDICTIONS_ARCHIVE_DIR, "PredictionCFO")
        self._create_cfo_archive_tab("Protocols", ArchitectConfig.PROTOCOL_ARCHIVE_DIR, "ProtocolCFO")
        self._create_cfo_archive_tab("Self-Awareness", ArchitectConfig.SELF_AWARENESS_ARCHIVE_DIR, ["ReflectionCFO", "ImprovementOpportunityCFO", "EmergentInsightCFO", "PersonaInsightCFO"])
        self._create_cfo_archive_tab("Code Suggestions", ArchitectConfig.CODE_SUGGESTIONS_ARCHIVE_DIR, ["ExecutableCodeCFO", "TestScriptCFO", "CodeSuggestionCFO"])
        self._create_cfo_archive_tab("Experiments", ArchitectConfig.EXPERIMENTAL_RESULTS_ARCHIVE_DIR, ["MicroSystemCFO", "ExperimentResultCFO"])
        self._create_cfo_archive_tab("BABS Tactical", ArchitectConfig.BABS_TACTICAL_ARCHIVE_DIR, "TacticalDataCFO")
        self._create_cfo_archive_tab("BABS Personality", ArchitectConfig.BABS_PERSONALITY_ARCHIVE_DIR, "PersonaInsightCFO")
        self._create_cfo_archive_tab("WING Cache", ArchitectConfig.WING_CACHE_ARCHIVE_DIR, "RawDataCFO") # WING's raw articles
        self._create_cfo_archive_tab("Harmony Logs", ArchitectConfig.HARMONY_ARCHIVE_DIR, ["ErrorCFO", "LogEventCFO", "ObservationCFO"]) # General logs

        # WING Settings Tab (GUI directly writes to WING's config file)
        self._create_wing_settings_tab()

        # --- Architect Response / LLM Output Display ---
        self.response_frame = QFrame()
        self.response_frame.setFrameShape(QFrame.Shape.StyledPanel)
        self.response_frame.setContentsMargins(10, 10, 10, 10)
        response_layout = QVBoxLayout(self.response_frame) # Pass self.response_frame to layout
        
        response_label = QLabel("Architect's LLM Response (BRICK & ROBIN)")
        response_label.setStyleSheet("font-weight: bold; margin-bottom: 5px;")
        response_layout.addWidget(response_label)

        self.response_text = QTextEdit()
        self.response_text.setReadOnly(True)
        self.response_text.setFont(QFont("Consolas", 10))
        response_layout.addWidget(self.response_text)
        main_layout.addWidget(self.response_frame)

        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the GUI elements."""
        self.setStyleSheet("""
            QWidget { background-color: #222; color: #eee; font-family: 'Helvetica', 'Arial', sans-serif; font-size: 14px; }
            QLabel { color: #ccc; }
            QLineEdit, QTextEdit { background-color: #333; border: 1px solid #555; border-radius: 4px; padding: 5px; color: #eee; }
            QPushButton { background-color: #007bff; color: white; border: none; border-radius: 4px; padding: 8px 15px; }
            QPushButton:hover { background-color: #0056b3; }
            QTabWidget::pane { border: 1px solid #444; border-top-left-radius: 4px; border-top-right-radius: 4px; background-color: #2a2a2a; }
            QTabWidget::tab-bar { left: 5px; }
            QTabBar::tab { background: #3a3a3a; border: 1px solid #444; border-bottom-color: #2a2a2a; border-top-left-radius: 4px; border-top-right-radius: 4px; padding: 8px 15px; color: #ccc; }
            QTabBar::tab:selected { background: #2a2a2a; border-color: #444; border-bottom-color: #2a2a2a; color: #fff; }
            QListWidget { background-color: #333; border: 1px solid #555; border-radius: 4px; color: #eee; }
            QListWidget::item:selected { background-color: #007bff; color: white; }
            QSlider::groove:horizontal { border: 1px solid #555; height: 8px; background: #444; margin: 2px 0; border-radius: 4px; }
            QSlider::handle:horizontal { background: #007bff; border: 1px solid #0056b3; width: 18px; margin: -5px 0; border-radius: 9px; }
        """)
    
    def _create_cfo_archive_tab(self, tab_name, archive_dir, filter_types=None):
        """
        Purpose: Creates a generic tab for visualizing CFOs from a specified archive directory.
        Mechanism: Contains a listbox for titles/summaries and a text area for full CFO content.
        Input: tab_name (str) - Name of the tab.
               archive_dir (str) - Path to the CFO archive directory.
               filter_types (str or list of str, optional) - Type(s) of CFOs to display.
        """
        tab = QWidget()
        self.tab_widget.addTab(tab, tab_name)
        layout = QHBoxLayout(tab)

        listbox = QListWidget()
        listbox.itemClicked.connect(lambda item, dir=archive_dir: self._on_cfo_select(item, dir)) # Filter_types handled during load_tab_data
        layout.addWidget(listbox, 1)

        display_area = QTextEdit()
        display_area.setReadOnly(True)
        display_area.setFont(QFont("Consolas", 10))
        layout.addWidget(display_area, 2)
        
        # Store references for later updates
        self.current_display_cfos[tab_name] = {'listbox': listbox, 'display_area': display_area, 'dir': archive_dir, 'filter_types': filter_types, 'data_loaded': []}

    def _on_cfo_select(self, item, archive_dir):
        """
        Purpose: Displays the full Bat-Gram content of a selected CFO in the display area.
        """
        tab_name = self.tab_widget.tabText(self.tab_widget.currentIndex())
        selected_index = self.current_display_cfos[tab_name]['listbox'].row(item)
        
        cfos_in_list = self.current_display_cfos[tab_name]['data_loaded']
        
        if selected_index < len(cfos_in_list):
            selected_cfo = cfos_in_list[selected_index]
            
            # Reconstruct the expected filename based on our save convention
            cfo_type = selected_cfo.get("type", "unknown_cfo").lower().replace(" ", "_").replace("-", "_")
            cfo_title_sanitized = selected_cfo.get("title", f"untitled_{cfo_type}").replace(" ", "_").replace("/", "_").replace("\\", "_").replace(":", "_").replace(".", "_")[:50]
            cfo_timestamp_sanitized = selected_cfo.get("timestamp", datetime.datetime.now().isoformat()).replace(":", "-").replace(".", "-").replace("+", "-")
            
            filepath = os.path.join(archive_dir, f"{cfo_type}_{cfo_timestamp_sanitized}_{cfo_title_sanitized}.gram")
            
            full_gram_content = f"Error: CFO file not found or corrupted for {selected_cfo.get('title', 'N/A')} ({selected_cfo.get('timestamp', 'N/A')})."
            try:
                lock = FileLock(archive_dir + ".lock", timeout=10) # Acquire archive directory lock
                with lock:
                    if os.path.exists(filepath):
                        with open(filepath, 'r', encoding='utf-8') as f:
                            full_gram_content = f.read()
                    else:
                        full_gram_content = f"Error: CFO file not found at expected path: {filepath}"
            except TimeoutError:
                full_gram_content = f"Error: Archive locked. Cannot read CFO from {filepath}."
            except Exception as e:
                full_gram_content = f"Error reading CFO from {filepath}: {e}"

            self.current_display_cfos[tab_name]['display_area'].setPlainText(full_gram_content)
            self.current_focus_cfo = selected_cfo # Store the full parsed CFO object
            
            # Optional: Offer to open source URL if available in CFO data
            source_url = selected_cfo.get('source_url')
            if source_url and QMessageBox.question(self, 'Open URL', f"Open source URL?\n{source_url}", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
                QDesktopServices.openUrl(QUrl(source_url))
        else:
            self.current_display_cfos[tab_name]['display_area'].setPlainText("CFO data not found in list.")


    def publish_user_cfo(self): # Renamed for clarity
        """
        Purpose: Publishes a user-generated Directive CFO or Human Feedback CFO to the Architect.
        Mechanism: Formalizes user input into a Bat-Gram and writes it to a queue file.
        Why: Enables human-in-the-loop steering and feedback.
        """
        user_raw_input = self.user_input_entry.text().strip()
        if not user_raw_input:
            self._display_architect_response("Please enter a directive or feedback.")
            return

        # Attempt to infer CFO type from user input, or default
        cfo_type = "UserDirectiveCFO"
        cfo_title = f"User Directive: {user_raw_input[:50]}..."
        target_queue = ArchitectConfig.GUI_USER_DIRECTIVE_QUEUE
        target_lock = ArchitectConfig.GUI_USER_DIRECTIVE_LOCK

        if user_raw_input.lower().startswith("feedback:"):
            cfo_type = "HumanFeedbackCFO"
            cfo_title = f"User Feedback: {user_raw_input[:50]}..."
            target_queue = ArchitectConfig.GUI_FEEDBACK_QUEUE
            target_lock = ArchitectConfig.GUI_FEEDBACK_LOCK
        elif user_raw_input.lower().startswith("problem:"): # User can directly define a problem
            cfo_type = "ProblemCFO"
            cfo_title = f"User Problem: {user_raw_input[:50]}..."
            # For ProblemCFOs, they go to the directives queue but the Nexus will prioritize
            target_queue = ArchitectConfig.GUI_USER_DIRECTIVE_QUEUE
            target_lock = ArchitectConfig.GUI_USER_DIRECTIVE_LOCK


        user_cfo_data = {
            "type": cfo_type,
            "title": cfo_title,
            "content": user_raw_input,
            "timestamp": datetime.datetime.now().isoformat(),
            "source_origin": "GUI_User_Input"
        }

        try:
            _write_cfo_queue([user_cfo_data], target_queue, target_lock) # Use global write_cfo_queue
            self._display_architect_response(f"Published {cfo_type} to Architect: '{user_cfo_data['title']}'")
            self.user_input_entry.clear()
        except Exception as e:
            self._display_architect_response(f"Error publishing CFO: {e}")
            QMessageBox.critical(self, "Error", f"Could not publish CFO: {e}")


    def handle_cfo_update_event(self):
        """
        Purpose: Slot for CFOEventClient's update_signal. Triggers targeted GUI refreshes.
        Mechanism: Reads latest CFOs from relevant archives and updates corresponding listboxes.
        Why: Ensures real-time, seamless display of CFO changes.
        """
        logger.info("GUI: Received CFO update event. Refreshing relevant tabs.")
        
        # Architect sends GUIUpdateCFOs to ARCHITECT_GUI_UPDATE_QUEUE. GUI reads from it.
        # This function should read *those* specific updates and interpret them.
        # For simplicity, we just trigger a full data reload across all tabs.
        # A more granular update would involve parsing the GUIUpdateCFO and updating only specific UI elements.
        
        gui_updates_from_architect = _read_cfo_queue(ArchitectConfig.ARCHITECT_GUI_UPDATE_QUEUE, ArchitectConfig.ARCHITECT_GUI_UPDATE_LOCK)
        if gui_updates_from_architect:
            for update_cfo in gui_updates_from_architect:
                logger.info(f"GUI: Processing Architect Update CFO: {update_cfo.get('title', 'N/A')}")
                self._display_architect_response(f"Architect's Latest Status:\n{update_cfo.get('content', 'N/A')}")
                # You could add logic here to parse update_cfo.get('update_type') and trigger specific UI changes
                # e.g., if update_cfo.get('update_type') == 'new_blueprint', highlight blueprints tab.

        # Then, refresh all archive tabs, as the Architect may have written new CFOs to them
        self.load_data_on_startup() # This reloads all data from archives


    def load_data_on_startup(self):
        """
        Initial load and refresh of all CFO data into GUI tabs during startup and on update signals.
        """
        logger.info("GUI: Loading initial/refresh CFO data into tabs.")
        for tab_name, components in self.current_display_cfos.items():
            archive_dir = components['dir']
            filter_types = components['filter_types'] # This can be a string or a list
            listbox = components['listbox']
            
            loaded_cfos = _read_cfos_from_archive(archive_dir, filter_type=filter_types, newest_first=True) # Use global read_cfos_from_archive
            
            listbox.clear()
            for cfo in loaded_cfos:
                item_text = f"{cfo.get('title', 'N/A')} ({cfo.get('type', 'N/A')})"
                listbox.addItem(item_text)
            components['data_loaded'] = loaded_cfos # Update the stored data

        # Load WING settings (simple text file, not a Bat-Gram)
        self._load_wing_settings_for_gui()


    def _load_wing_settings_for_gui(self):
        """
        Loads WING's operational configuration from 'wing_config.json' for GUI display.
        """
        lock = FileLock(ArchitectConfig.WING_CONFIG_FILE_LOCK, timeout=10)
        try:
            with lock:
                if os.path.exists(ArchitectConfig.WING_CONFIG_FILE):
                    with open(ArchitectConfig.WING_CONFIG_FILE, 'r') as f:
                        config_data = json.load(f)
                        # Ensure sliders are created in initUI before setting values
                        if hasattr(self, 'relevance_slider'): # Check if UI elements exist
                            self.relevance_slider.setValue(int(config_data.get("RELEVANCE_THRESHOLD", 7.0) * 10))
                        if hasattr(self, 'redundancy_slider'):
                            self.redundancy_slider.setValue(int(config_data.get("SEMANTIC_REDUNDANCY_THRESHOLD", 0.95) * 100))
                        self.wing_settings_status_label.setText("WING settings loaded.")
                        self.wing_settings_status_label.setStyleSheet("color: green;")
                else:
                    # Create default config if not found. Use atomic write.
                    with atomic_write(ArchitectConfig.WING_CONFIG_FILE, overwrite=True, encoding='utf-8') as f:
                        json.dump({
                            "RELEVANCE_THRESHOLD": 7.0,
                            "SEMANTIC_REDUNDANCY_THRESHOLD": 0.95,
                            "MAX_CACHE_SIZE": 100, # These are WING's internal configs
                            "QUERY_BATCH_SIZE": 5,
                            "QUERY_QUALITY_THRESHOLD": 6,
                            "QUERY_FAIL_REPHRASE_THRESHOLD": 3
                        }, f, indent=4)
                    if hasattr(self, 'relevance_slider'):
                        self.relevance_slider.setValue(70)
                    if hasattr(self, 'redundancy_slider'):
                        self.redundancy_slider.setValue(95)
                    self.wing_settings_status_label.setText(f"'{ArchitectConfig.WING_CONFIG_FILE}' not found. Created with defaults.")
                    self.wing_settings_status_label.setStyleSheet("color: orange;")
        except json.JSONDecodeError:
            self.wing_settings_status_label.setText(f"Error decoding '{ArchitectConfig.WING_CONFIG_FILE}'. Using defaults.")
            self.wing_settings_status_label.setStyleSheet("color: red;")
            if hasattr(self, 'relevance_slider'): self.relevance_slider.setValue(70)
            if hasattr(self, 'redundancy_slider'): self.redundancy_slider.setValue(95)
        except TimeoutError:
            self.wing_settings_status_label.setText(f"Warning: WING settings file locked. Cannot load settings.")
            self.wing_settings_status_label.setStyleSheet("color: orange;")
            if hasattr(self, 'relevance_slider'): self.relevance_slider.setValue(70)
            if hasattr(self, 'redundancy_slider'): self.redundancy_slider.setValue(95)
        except Exception as e:
            self.wing_settings_status_label.setText(f"Error loading WING settings: {e}")
            self.wing_settings_status_label.setStyleSheet("color: red;")
            if hasattr(self, 'relevance_slider'): self.relevance_slider.setValue(70)
            if hasattr(self, 'redundancy_slider'): self.redundancy_slider.setValue(95)


    def save_wing_settings(self):
        """
        Saves WING's operational configuration from GUI sliders to 'wing_config.json'.
        """
        lock = FileLock(ArchitectConfig.WING_CONFIG_FILE_LOCK, timeout=10)
        try:
            with lock:
                new_relevance = self.relevance_slider.value() / 10.0
                new_redundancy = self.redundancy_slider.value() / 100.0

                settings = {
                    "RELEVANCE_THRESHOLD": new_relevance,
                    "SEMANTIC_REDUNDANCY_THRESHOLD": new_redundancy,
                    # Retain other WING configs not set by GUI
                    "MAX_CACHE_SIZE": 100, # Hardcoded or loaded from an internal source if dynamic
                    "QUERY_BATCH_SIZE": 5,
                    "QUERY_QUALITY_THRESHOLD": 6,
                    "QUERY_FAIL_REPHRASE_THRESHOLD": 3
                }
                with atomic_write(ArchitectConfig.WING_CONFIG_FILE, overwrite=True, encoding='utf-8') as f:
                    json.dump(settings, f, indent=4)
                self.wing_settings_status_label.setText("WING settings saved successfully!")
                self.wing_settings_status_label.setStyleSheet("color: green;")
        except TimeoutError:
            self.wing_settings_status_label.setText(f"Error: WING settings file locked. Cannot save settings.")
            self.wing_settings_status_label.setStyleSheet("color: red;")
            QMessageBox.critical(self, "Error", f"Could not save settings: {ArchitectConfig.WING_CONFIG_FILE} is locked by another process.")
        except Exception as e:
            self.wing_settings_status_label.setText(f"Error saving WING settings: {e}")
            self.wing_settings_status_label.setStyleSheet("color: red;")
            QMessageBox.critical(self, "Error", f"Could not save settings: {e}")

    def _create_wing_settings_tab(self):
        """Creates the WING Settings tab with sliders for relevance and redundancy."""
        tab = QWidget()
        self.tab_widget.addTab(tab, "WING Settings")
        layout = QVBoxLayout(tab)

        settings_frame = QFrame()
        settings_frame.setFrameShape(QFrame.Shape.StyledPanel)
        settings_frame.setContentsMargins(15, 15, 15, 15)
        settings_layout = QVBoxLayout(settings_frame)

        relevance_layout = QHBoxLayout()
        relevance_layout.addWidget(QLabel("Relevance Threshold (1-10):"))
        self.relevance_slider = QSlider(Qt.Orientation.Horizontal)
        self.relevance_slider.setMinimum(10) # 1.0 -> 10, so 10-100 means 1.0 to 10.0
        self.relevance_slider.setMaximum(100)
        self.relevance_slider.setSingleStep(1)
        self.relevance_slider.valueChanged.connect(self._update_relevance_label)
        relevance_layout.addWidget(self.relevance_slider)
        self.relevance_value_label = QLabel("7.0")
        self.relevance_value_label.setFixedWidth(40)
        relevance_layout.addWidget(self.relevance_value_label)
        settings_layout.addLayout(relevance_layout)

        redundancy_layout = QHBoxLayout()
        redundancy_layout.addWidget(QLabel("Semantic Redundancy Threshold (0.0-1.0):"))
        self.redundancy_slider = QSlider(Qt.Orientation.Horizontal)
        self.redundancy_slider.setMinimum(0) # 0.00 -> 0, so 0-100 means 0.00 to 1.00
        self.redundancy_slider.setMaximum(100)
        self.redundancy_slider.setSingleStep(1)
        self.redundancy_slider.valueChanged.connect(self._update_redundancy_label)
        redundancy_layout.addWidget(self.redundancy_slider)
        self.redundancy_value_label = QLabel("0.95")
        self.redundancy_value_label.setFixedWidth(40)
        redundancy_layout.addWidget(self.redundancy_value_label)
        settings_layout.addLayout(redundancy_layout)

        save_button = QPushButton("Apply & Save WING Settings")
        save_button.clicked.connect(self.save_wing_settings)
        settings_layout.addWidget(save_button)

        self.wing_settings_status_label = QLabel("")
        settings_layout.addWidget(self.wing_settings_status_label)

        layout.addWidget(settings_frame)
        layout.addStretch(1)

        self._load_wing_settings_for_gui() # Load settings on tab creation

    def _update_relevance_label(self, value):
        self.relevance_value_label.setText(f"{value / 10.0:.1f}")

    def _update_redundancy_label(self, value):
        self.redundancy_value_label.setText(f"{value / 100.0:.2f}")

    def _display_architect_response(self, text):
        """Displays messages or LLM responses from the Architect."""
        self.response_text.setPlainText(text)

    def update_brick_thought(self):
        """Updates BRICK's thought bubble with a random, pre-defined thought."""
        new_thought = random.choice(self.brick_thoughts)
        self.thought_bubble.setText(f"<b>{ArchitectConfig.BAT_COMPUTER_ACRONYM}</b>: {html.escape(new_thought)}") # Use actual acronym

# --- Main Execution for GUI Insight Canvas ---
if __name__ == "__main__":
    # Ensure logging is configured for GUI
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger('GUI_Canvas_Main') # Main logger for GUI process

    # Initialize common FAO filesystem (directories, queues, etc.)
    # This ensures GUI's comms and archives are ready, as Architect.py might not be started yet
    from utils import initialize_fao_filesystem
    from config import ArchitectConfig # Needs ArchitectConfig for initialize_fao_filesystem
    
    initialize_fao_filesystem(ArchitectConfig)

    app = QApplication(sys.argv)
    window = GuiInsightCanvas() # Instantiate the main GUI window
    window.show()
    sys.exit(app.exec())
