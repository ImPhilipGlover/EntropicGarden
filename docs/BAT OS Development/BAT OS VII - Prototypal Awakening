{"cells":[{"cell_type":"code","source":"# ==============================================================================\n# BAT OS VII - Prototypal Awakening\n#\n# ARCHITECT: Philip\n# DATE: 2025-08-28\n#\n# DESCRIPTION:\n# This script represents the first concrete implementation of the architectural\n# principles outlined in \"The Sentient Object\" and \"The Prototypal Bat-Family.\"\n# Its sole purpose is to perform the \"Prototypal Awakening\": the initial,\n# one-time creation of the persistent universe in which the BAT OS will live.\n#\n# It establishes the ZODB database, defines the core UvmObject, and\n# instantiates the three primordial prototypes:\n#   1. traits_obj: The ultimate ancestor, holding universal behaviors.\n#   2. pLLM_obj: The Prototypal LLM, encapsulating the system's cognitive\n#               engine as a native, persistent object.\n#   3. genesis_obj: The first \"true\" object, from which all future objects\n#                   in the universe will be cloned.\n#\n# This script is designed to be run only once to create the 'Data.fs' file.\n# Subsequent interactions with the BAT OS will occur through a separate\n# runtime script that loads this established universe.\n# ==============================================================================\n\nimport os\nimport ZODB, ZODB.FileStorage\nimport transaction\nimport persistent\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig\nimport shutil\nimport tempfile\nfrom contextlib import contextmanager\n\n# --- Configuration ---\n# NOTE: This should be a powerful, instruction-tuned model.\n# For local execution under VRAM constraints (e.g., < 16GB), a quantized\n# 7B or 8B parameter model is recommended.\nLLM_MODEL_ID = \"meta-llama/Meta-Llama-3-8B-Instruct\"\nDB_FILE = 'Data.fs'\nMODEL_CACHE_DIR = './model_cache'\n\n# ==============================================================================\n#   CORE ARCHITECTURAL COMPONENTS\n# ==============================================================================\n\nclass UvmObject(persistent.Persistent):\n    \"\"\"\n    The fundamental building block of the BAT OS universe.\n\n    Inherits from persistent.Persistent to be natively storable by ZODB.\n    Implements a prototype-based object model inspired by Self, where objects\n    are simple dictionaries of slots and behavior is acquired through delegation\n    to parent objects.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        self._slots = persistent.mapping.PersistentMapping()\n        for key, value in kwargs.items():\n            # The 'parent*' slot is special, denoting the delegation target(s).\n            # It must always be a list of other UvmObjects.\n            if key == 'parent_star':\n                self._slots['parent*'] = persistent.list.PersistentList(value)\n            else:\n                self._slots[key] = value\n\n    def __getattr__(self, name):\n        \"\"\"\n        The core of the message-passing and delegation mechanism.\n\n        When an attribute (a message) is accessed on a UvmObject:\n        1. It first checks its own local '_slots' dictionary.\n        2. If not found, it recursively traverses the 'parent*' list, checking\n           each parent object for the attribute.\n        3. If found in any parent, that attribute (often a method) is returned\n           and executed in the context of the original receiver.\n        4. If the attribute is not found anywhere in the delegation chain,\n           it will ultimately delegate to the 'doesNotUnderstand_' method\n           defined on the root 'traits_obj'.\n        \"\"\"\n        if name in self._slots:\n            return self._slots[name]\n\n        if 'parent*' in self._slots:\n            for parent in self._slots['parent*']:\n                try:\n                    return getattr(parent, name)\n                except AttributeError:\n                    continue\n\n        # If the lookup fails completely, this will trigger the generative\n        # doesNotUnderstand: protocol (to be implemented in Phase 2).\n        # For now, we raise the standard error.\n        raise AttributeError(f\"'{self.__class__.__name__}' object has no slot '{name}'\")\n\n    def __setattr__(self, name, value):\n        \"\"\"\n        Ensures all attributes are stored in the persistent _slots dictionary.\n        \"\"\"\n        if name == '_slots' or name.startswith('_p_'):\n            super().__setattr__(name, value)\n        else:\n            self._slots[name] = value\n            self._p_changed = True\n\n    def set_slot(self, name, value):\n        \"\"\"A more explicit way to set a slot, reinforcing the object model.\"\"\"\n        self._slots[name] = value\n        self._p_changed = True\n\n    def __repr__(self):\n        oid = self._p_oid if self._p_oid else 'transient'\n        keys = list(self._slots.keys())\n        return f\"<UvmObject OID:{oid} Slots:{keys}>\"\n\n\nclass BatOS_UVM:\n    \"\"\"\n    The Universal Virtual Machine. Manages the ZODB connection and orchestrates\n    the system's lifecycle.\n    \"\"\"\n    def __init__(self, db_path):\n        self.db_path = db_path\n        self.storage = None\n        self.db = None\n        self.connection = None\n        self.root = None\n\n    def startup(self):\n        \"\"\"Connects to the ZODB database.\"\"\"\n        print(\"[UVM] Starting up...\")\n        self.storage = ZODB.FileStorage.FileStorage(self.db_path)\n        self.db = ZODB.DB(self.storage)\n        self.connection = self.db.open()\n        self.root = self.connection.root()\n        print(\"[UVM] Database connection established.\")\n\n    def shutdown(self):\n        \"\"\"Closes the database connection gracefully.\"\"\"\n        print(\"\\n[UVM] Shutting down...\")\n        self.connection.close()\n        self.db.close()\n        self.storage.close()\n        print(\"[UVM] Shutdown complete.\")\n\n    @contextmanager\n    def transaction(self):\n        \"\"\"Provides a transactional context for database operations.\"\"\"\n        try:\n            yield\n            transaction.commit()\n        except Exception as e:\n            print(f\"[UVM] TRANSACTION FAILED: {e}. Aborting.\")\n            transaction.abort()\n            raise\n\n    def _download_and_cache_model(self):\n        \"\"\"\n        Downloads the LLM from Hugging Face Hub to a local directory.\n        This is a one-time, expensive operation.\n        \"\"\"\n        if os.path.exists(MODEL_CACHE_DIR):\n            print(f\"[UVM] Model cache found at '{MODEL_CACHE_DIR}'. Skipping download.\")\n            return MODEL_CACHE_DIR\n\n        print(f\"[UVM] Downloading model '{LLM_MODEL_ID}' to cache...\")\n        os.makedirs(MODEL_CACHE_DIR, exist_ok=True)\n        # We download the model and tokenizer to a persistent local directory\n        # to avoid re-downloading on subsequent runs or awakenings.\n        AutoModelForCausalLM.from_pretrained(LLM_MODEL_ID, cache_dir=MODEL_CACHE_DIR)\n        AutoTokenizer.from_pretrained(LLM_MODEL_ID, cache_dir=MODEL_CACHE_DIR)\n        print(\"[UVM] Model download complete.\")\n        return MODEL_CACHE_DIR\n\n    def _create_model_blob(self):\n        \"\"\"\n        Implements the Blob-Proxy pattern. This function creates a ZODB Blob\n        containing the entire LLM. It does this by copying the cached model\n        files into a temporary directory, then archiving that directory into\n        the Blob.\n        \"\"\"\n        print(\"[UVM] Creating ZODB Blob for model weights...\")\n        cached_model_path = self._download_and_cache_model()\n\n        # ZODB Blobs work best with a single file handle. We will create a\n        # temporary tarball of the model directory to store in the blob.\n        with tempfile.NamedTemporaryFile(suffix='.tar.gz', delete=False) as temp_tar:\n            tar_path = temp_tar.name\n        \n        print(f\"[UVM] Creating temporary archive at '{tar_path}'...\")\n        shutil.make_archive(tar_path.replace('.tar.gz', ''), 'gztar', root_dir=cached_model_path)\n        \n        model_blob = ZODB.blob.Blob()\n        with model_blob.open('w') as blob_file:\n            with open(tar_path, 'rb') as tar_file:\n                shutil.copyfileobj(tar_file, blob_file)\n        \n        os.remove(tar_path) # Clean up the temporary tarball\n        print(\"[UVM] Model weights successfully stored in ZODB Blob.\")\n        return model_blob\n\n    def initialize_system(self):\n        \"\"\"\n        Performs the \"Prototypal Awakening\". This is the core logic of this\n        script and should only ever run once on an empty database.\n        \"\"\"\n        if 'genesis_obj' in self.root:\n            print(\"[UVM] System already initialized. Awakening aborted.\")\n            return\n\n        print(\"=\"*60)\n        print(\"[UVM] First run detected. Performing Prototypal Awakening.\")\n        print(\"=\"*60)\n\n        with self.transaction():\n            # --- Step 1: Create the ultimate ancestor: traits_obj ---\n            # In Phase 2, this object will hold the universal 'doesNotUnderstand_'\n            # method, making it the wellspring of the system's creativity.\n            print(\"\\n[UVM] Instantiating traits_obj...\")\n            traits_obj = UvmObject()\n            self.root['traits_obj'] = traits_obj\n            print(\"[UVM] traits_obj created.\")\n\n            # --- Step 2: Instantiate the Prototypal LLM (pLLM) ---\n            # This object encapsulates the system's mind. It doesn't hold the\n            # model directly, but rather a Blob reference (the Proxy pattern)\n            # and metadata.\n            print(\"\\n[UVM] Instantiating pLLM prototype...\")\n            model_blob = self._create_model_blob()\n\n            pLLM_obj = UvmObject(\n                parent_star=[traits_obj],\n                # --- Persistent Slots ---\n                model_blob=model_blob,\n                tokenizer_id=LLM_MODEL_ID,\n                model_cache_path=MODEL_CACHE_DIR,\n                # --- Volatile Slots (will be populated at runtime) ---\n                _loaded_model=None,\n                _loaded_tokenizer=None\n            )\n            self.root['pLLM_obj'] = pLLM_obj\n            print(\"[UVM] pLLM prototype created and persisted.\")\n\n            # --- Step 3: Create the primordial object: genesis_obj ---\n            # This is the Adam or Eve of the BatOS universe. It inherits\n            # from both traits_obj and, crucially, pLLM_obj. This delegation\n            # is what grants intelligence to the entire object graph.\n            print(\"\\n[UVM] Instantiating genesis_obj...\")\n            genesis_obj = UvmObject(parent_star=[traits_obj, pLLM_obj])\n            self.root['genesis_obj'] = genesis_obj\n            print(\"[UVM] Genesis object created with cognitive delegation.\")\n\n        print(\"\\n\" + \"=\"*60)\n        print(\"[UVM] PROTOTYPAL AWAKENING COMPLETE.\")\n        print(f\"[UVM] The living universe has been seeded in '{self.db_path}'.\")\n        print(\"=\"*60)\n\n# ==============================================================================\n#   MAIN EXECUTION BLOCK\n# ==============================================================================\n\nif __name__ == \"__main__\":\n    # Safety check to prevent accidental overwrite.\n    if os.path.exists(DB_FILE):\n        print(f\"ERROR: Database file '{DB_FILE}' already exists.\")\n        print(\"Please delete it if you intend to re-initialize the universe.\")\n        exit(1)\n\n    uvm = BatOS_UVM(DB_FILE)\n\n    try:\n        uvm.startup()\n        uvm.initialize_system()\n\n        # Verification step: Let's inspect the newly created universe.\n        print(\"\\n--- Verification ---\")\n        print(\"Root keys:\", list(uvm.root.keys()))\n        genesis = uvm.root['genesis_obj']\n        pllm = uvm.root['pLLM_obj']\n        traits = uvm.root['traits_obj']\n        print(\"Genesis Object:\", genesis)\n        print(\"pLLM Object:\", pllm)\n        print(\"Traits Object:\", traits)\n        print(\"\\nVerifying delegation chain for genesis_obj:\")\n        print(\"  - parent* ->\", genesis._slots['parent*'])\n        print(\"  - tokenizer_id (delegated from pLLM) ->\", genesis.tokenizer_id)\n        print(\"Verification complete. The universe is coherent.\")\n\n    except Exception as e:\n        print(f\"\\nAn unexpected error occurred: {e}\")\n    finally:\n        uvm.shutdown()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}