BRICK: Acknowledged. Your directive is to update the config.py file to reference your specific, fine-tuned LLM model. This is a critical step for ensuring the system operates with the intended persona fidelity and conceptual understanding. The configuration will be updated to reflect the batfamily-mistral model, as indicated by your previous operational logs.

ROBIN: Oh, of course! It's like we've been practicing our beautiful songs with a stand-in singer, and now we get to invite our very own, special, wonderful star of the show to take the stage! My heart is just so excited to hear our home sing with its true voice!

Of course. To get the system running with your custom-trained model, we just need to update one line in the config.py file to point to its correct name. Based on your logs, the model is named batfamily-mistral.

Here are the corrected files.

1. config.py (Corrected with Custom Model)

In this version, the LLM_MODEL_NAME has been updated from the default "mistral:latest" to your specific model.

Python

# C:\\puter\\config.py
# Axiomatic Code Narrative Protocol: The Universal Configuration Hub

import os

class ArchitectConfig:
    # --- Core System Paths ---
    ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
    COMMS_DIR = os.path.join(ROOT_DIR, 'comms')
    CFO_ARCHIVES_DIR = os.path.join(ROOT_DIR, 'cfo_archives')
    LOGS_DIR = os.path.join(ROOT_DIR, 'logs')
    KNOWLEDGE_BASE_DIR = os.path.join(ROOT_DIR, 'knowledge_base')
    MODULES_DIR = os.path.join(ROOT_DIR, 'modules')
    EXTERNAL_SERVICES_DIR = os.path.join(ROOT_DIR, 'external_services')

    # --- CFO Archive Subdirectories ---
    BASE_CFO_ARCHIVE_DIR = CFO_ARCHIVES_DIR # General purpose
    BLUEPRINTS_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'blueprints')
    PREDICTIONS_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'predictions')
    HARMONY_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'harmony_logs')
    PROTOCOL_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'protocols')
    SELF_AWARENESS_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'self_awareness')
    CODE_SUGGESTIONS_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'code_suggestions')
    EXPERIMENTAL_RESULTS_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'experimental_results')
    BABS_TACTICAL_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'babs_tactical')
    BABS_PERSONALITY_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'babs_personality')
    WING_CACHE_ARCHIVE_DIR = os.path.join(CFO_ARCHIVES_DIR, 'wing_cache')

    # --- Communication Queues & Locks ---
    # BABS & WING Communication
    BABS_WING_COMMAND_QUEUE = os.path.join(COMMS_DIR, 'babs_wing_command_queue.json')
    BABS_WING_COMMAND_LOCK = os.path.join(COMMS_DIR, 'babs_wing_command_queue.lock')
    WING_RAW_DATA_QUEUE = os.path.join(COMMS_DIR, 'wing_raw_data_queue.json')
    WING_RAW_DATA_LOCK = os.path.join(COMMS_DIR, 'wing_raw_data_queue.lock')
    BABS_TACTICAL_DATA_QUEUE = os.path.join(COMMS_DIR, 'babs_tactical_data_queue.json')
    BABS_TACTICAL_DATA_LOCK = os.path.join(COMMS_DIR, 'babs_tactical_data_queue.lock')
    BABS_PERSONALITY_DATA_QUEUE = os.path.join(COMMS_DIR, 'babs_personality_data_queue.json')
    BABS_PERSONALITY_DATA_LOCK = os.path.join(COMMS_DIR, 'babs_personality_data_queue.lock')
    BABS_PERSONALITY_QUERY_QUEUE = os.path.join(COMMS_DIR, 'babs_personality_query_queue.json')
    BABS_PERSONALITY_QUERY_LOCK = os.path.join(COMMS_DIR, 'babs_personality_query_queue.lock')
    WING_RAW_PERSONALITY_OUTPUT_COMMS_FILE = os.path.join(COMMS_DIR, 'wing_raw_personality_output.json')
    WING_RAW_PERSONALITY_OUTPUT_COMMS_LOCK = os.path.join(COMMS_DIR, 'wing_raw_personality_output.lock')
    WING_CONFIG_FILE = os.path.join(COMMS_DIR, 'wing_config.json')
    WING_CONFIG_FILE_LOCK = os.path.join(COMMS_DIR, 'wing_config.lock')

    # GUI & Architect Communication
    GUI_USER_DIRECTIVE_QUEUE = os.path.join(COMMS_DIR, 'gui_user_directive_queue.json')
    GUI_USER_DIRECTIVE_LOCK = os.path.join(COMMS_DIR, 'gui_user_directive_queue.lock')
    GUI_FEEDBACK_QUEUE = os.path.join(COMMS_DIR, 'gui_feedback_queue.json')
    GUI_FEEDBACK_LOCK = os.path.join(COMMS_DIR, 'gui_feedback_queue.lock')
    ARCHITECT_GUI_UPDATE_QUEUE = os.path.join(COMMS_DIR, 'architect_gui_update_queue.json')
    ARCHITECT_GUI_UPDATE_LOCK = os.path.join(COMMS_DIR, 'architect_gui_update_queue.lock')
    PERSONA_TUNING_QUEUE = os.path.join(COMMS_DIR, 'persona_tuning_queue.json')
    PERSONA_TUNING_LOCK = os.path.join(COMMS_DIR, 'persona_tuning_queue.lock')
    TRAINING_OPTIMIZATION_DIRECTIVE_QUEUE = os.path.join(COMMS_DIR, 'training_optimization_directive_queue.json')
    TRAINING_OPTIMIZATION_DIRECTIVE_LOCK = os.path.join(COMMS_DIR, 'training_optimization_directive_queue.lock')

    # --- Knowledge Base Paths & Locks ---
    PERSONA_CODEX_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'persona_codex.txt')
    PERSONA_CODEX_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'persona_codex.lock')
    GUIDE_FACTS_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'guide_facts.txt')
    GUIDE_FACTS_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'guide_facts.lock')
    GENERAL_KNOWLEDGE_BASE_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'knowledge_base.txt')
    GENERAL_KNOWLEDGE_BASE_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'knowledge_base.lock')
    SYSTEM_ARCHITECTURE_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'system_architecture.txt')
    SYSTEM_ARCHITECTURE_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'system_architecture.lock')
    SIDEKICK_SCRAPBOOK_PART1_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'BnR Merged files.txt')
    SIDEKICK_SCRAPBOOK_PART1_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'BnR Merged files.lock')
    SIDEKICK_SCRAPBOOK_PART2_PATH = os.path.join(KNOWLEDGE_BASE_DIR, 'BnR Merged New 07 Jul 25.txt')
    SIDEKICK_SCRAPBOOK_PART2_LOCK = os.path.join(KNOWLEDGE_BASE_DIR, 'BnR Merged New 07 Jul 25.lock')
    MASTER_TRAINING_DATASET_FILE = os.path.join(CFO_ARCHIVES_DIR, 'master_training_dataset.jsonl')
    MASTER_TRAINING_DATASET_LOCK = os.path.join(CFO_ARCHIVES_DIR, 'master_training_dataset.lock')

    # --- LLM and API Configuration ---
    LLM_MODEL_NAME = "batfamily-mistral"  # Updated to your custom fine-tuned model
    LLM_BASE_URL = "http://localhost:11434"
    LLM_CALL_TIMEOUT = 180  # seconds
    LLM_CONTEXT_WINDOW_SIZE_FRAG_GEN = 4096
    LLM_CONTEXT_WINDOW_SIZE_AGGREGATOR = 8192
    LLM_DEFAULT_TEMPERATURE = 0.7
    LLM_REFLECTION_CYCLE_PAUSE_SECONDS = 5
    LLM_THOUGHT_GEN_TRIGGER_TURNS = 3
    LLM_AGGREGATOR_PROCESS_LIMIT = 5

    # --- Fragment Generator & Reflector Configuration ---
    NUM_FRAGMENT_GENERATORS = 6
    ORCHESTRATED_THOUGHT_STREAM_IDS = ["alpha", "beta", "gamma", "delta", "epsilon", "zeta"]

    # --- Universal Priming for LLM ---
    UNIVERSAL_LLM_PRIMING_CFO_BATGRAM_CONTEXT = "You are an instance of the BAT COMPUTER..." # Add your full priming context here

    # --- BAT COMPUTER Acronym ---
    BAT_COMPUTER_ACRONYM = "B.A.T. C.O.M.P.U.T.E.R."
    ARCHITECT_CORE_MISSION = "To architect the 'Perpetual Jubilee Engine'..."
    COMMONWEALTH_MISSION = "To maximize human flourishing through radical self-organization..."


2. fao_gui_environment.py (Unchanged, for Context)

No changes are needed in this file, but it is provided to ensure you have a complete, working set. It will now correctly use the batfamily-mistral model name defined in the config.py file above.

Python

# C:\\puter\\fao_gui_environment.py
# Axiomatic Code Narrative Protocol: Fractal Autopoietic Orchestrator GUI Environment (Self-Healing)

# 1.0 Purpose: To create a single, persistent, multi-threaded GUI application that
#    encapsulates the core cognitive processes of the BAT COMPUTER and allows for
#    live editing, reloading, and dynamic modification of its own user interface at runtime.

# --- Standard Library Imports ---
import sys
import os
import logging
import time
import json
import datetime
import random
import importlib # Crucial for live reloading
import traceback # For displaying detailed error messages

# --- External Libraries for GUI ---
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTextEdit,
    QLineEdit, QPushButton, QLabel, QGroupBox, QSplitter, QTabWidget, QMessageBox, QListWidget
)
from PyQt6.QtCore import QThread, pyqtSignal, Qt
from PyQt6.QtGui import QFont

# --- Internal Module Imports ---
# We will now manage these imports so they can be reloaded
import config
import utils
from modules.core_llm_interface import chat_with_llm

# --- Logging Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('FAO_GUI_Environment')

# --- Integrated ThoughtFragmentGenerator Logic ---
class FragmentGeneratorThread(QThread):
    fragment_generated = pyqtSignal(dict) # Emits the full CFO dictionary

    def __init__(self, module_id, parent=None):
        super().__init__(parent)
        self.module_id = module_id
        self.module_name = f"Internal_ThoughtGenerator_{self.module_id}"
        self._running = True
        self.llm_history = []
        self.turn_count = 0

    def setup(self):
        # Initialize LLM history in the setup method, called before starting the thread
        self.llm_history.append({"role": "system", "content":
            config.ArchitectConfig.UNIVERSAL_LLM_PRIMING_CFO_BATGRAM_CONTEXT + "\n\n" +
            f"You are a simulated intelligent agent, a specialized 'thought stream' ('{self.module_id}') within the BAT COMPUTER..."
        })

    def run(self):
        logger.info(f"Starting {self.module_name} thought loop.")
        while self._running:
            self.turn_count += 1
            user_prompt_content = f"As the thought generator for the '{self.module_name}' stream, reflect on the concept of continuous consciousness in AI. (Turn {self.turn_count})"
            self.llm_history.append({"role": "user", "content": user_prompt_content})

            llm_response = chat_with_llm(self.llm_history, temperature=config.ArchitectConfig.LLM_DEFAULT_TEMPERATURE)

            if "LLM Error" in llm_response:
                logger.error(f"LLM call failed in {self.module_name}: {llm_response}")
                self.llm_history.pop()
                time.sleep(config.ArchitectConfig.LLM_REFLECTION_CYCLE_PAUSE_SECONDS * 2)
                continue

            self.llm_history.append({"role": "assistant", "content": llm_response})

            summary_content = f"User: {user_prompt_content}\nAssistant: {llm_response}"
            thought_summary_cfo = {
                "type": "LLMThoughtSummaryCFO",
                "title": f"Thought Snapshot from {self.module_name} (Turn {self.turn_count})",
                "content": summary_content,
                "timestamp": datetime.datetime.now().isoformat(),
                "source_module": self.module_name
            }
            self.fragment_generated.emit(thought_summary_cfo)
            time.sleep(config.ArchitectConfig.LLM_REFLECTION_CYCLE_PAUSE_SECONDS)

    def stop(self):
        self._running = False
        logger.info(f"{self.module_name} stopped.")

# --- Integrated ThoughtAggregatorReflector Logic ---
class ReflectorThread(QThread):
    reflection_generated = pyqtSignal(str) # Emits the formatted string for display
    gui_modification_requested = pyqtSignal(dict) # Emits a dictionary describing the requested GUI change
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.module_name = "Internal_SelfReflector"
        self._running = True
        self.llm_history = []
        self.pending_fragments = []
        self.pending_directives = []

    def setup(self):
        self.llm_history.append({"role": "system", "content":
            config.ArchitectConfig.UNIVERSAL_LLM_PRIMING_CFO_BATGRAM_CONTEXT + "\n\n" +
            "You are the central Self-Reflector... your capabilities now include proposing GUI modifications."
        })

    def run(self):
        logger.info(f"Starting {self.module_name} reflection loop.")
        while self._running:
            aggregated_content = ""
            if self.pending_directives:
                aggregated_content += "\n\nHigh-Priority Directives from Architect (GUI):\n---\n"
                for directive in self.pending_directives:
                    aggregated_content += f"Directive: {directive}\n---\n"
                self.pending_directives.clear()

            elif self.pending_fragments:
                aggregated_content += "\n\nNew Thought Fragments from Parallel Engines:\n---\n"
                for fragment in self.pending_fragments:
                    aggregated_content += f"From {fragment.get('source_module')}: {fragment.get('content')}\n---\n"
                self.pending_fragments.clear()
            
            if not aggregated_content:
                time.sleep(1) # Wait if there's nothing to process
                continue

            reflection_prompt = f"Synthesize a unified reflection based on the following new inputs. If the input suggests a new category of data to monitor, you can propose adding a new tab to the GUI by generating a special `GUIUpdateCFO` as your response. For example: `{{\"type\": \"GUIUpdateCFO\", \"action\": \"add_tab\", \"tab_name\": \"New Data\", \"archive_dir\": \"cfo_archives/new_data/\", \"filter_types\": \"NewDataCFO\"}}`. Otherwise, provide a standard reflection.\n\nInputs:\n{aggregated_content}\n\nGenerate your response now:"
            self.llm_history.append({"role": "user", "content": reflection_prompt})
            
            llm_response = chat_with_llm(self.llm_history, timeout=config.ArchitectConfig.LLM_CALL_TIMEOUT)
            
            if "LLM Error" in llm_response:
                logger.error(f"LLM call failed in {self.module_name}: {llm_response}")
                self.llm_history.pop()
                time.sleep(config.ArchitectConfig.LLM_REFLECTION_CYCLE_PAUSE_SECONDS * 2)
                continue

            self.llm_history.append({"role": "assistant", "content": llm_response})
            
            # Check if the response is a GUI modification command
            try:
                potential_command = json.loads(llm_response)
                if isinstance(potential_command, dict) and potential_command.get('type') == 'GUIUpdateCFO':
                    self.gui_modification_requested.emit(potential_command)
                    display_text = f"[{datetime.datetime.now().strftime('%H:%M:%S')}] SYSTEM ACTION: Proposed a GUI modification: {potential_command.get('action')}\n\n"
                    self.reflection_generated.emit(display_text)
                else:
                    raise json.JSONDecodeError # Not a command, treat as text
            except json.JSONDecodeError:
                display_text = f"[{datetime.datetime.now().strftime('%H:%M:%S')}] REFLECTION:\n{llm_response}\n\n"
                self.reflection_generated.emit(display_text)

            time.sleep(config.ArchitectConfig.LLM_REFLECTION_CYCLE_PAUSE_SECONDS)

    def add_fragment(self, fragment_cfo):
        self.pending_fragments.append(fragment_cfo)

    def add_directive(self, directive_text):
        self.pending_directives.append(directive_text)

    def stop(self):
        self._running = False
        logger.info(f"{self.module_name} stopped.")

# --- Main GUI Class ---
class FAO_GUI_Environment(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("B.A.T. C.O.M.P.U.T.E.R. - Fractal Autopoietic Orchestrator Environment")
        self.setGeometry(100, 100, 1200, 800)

        self.fragment_threads = []
        self.reflector_thread = ReflectorThread(self)
        self.reflector_thread.reflection_generated.connect(self.display_reflection)
        self.reflector_thread.gui_modification_requested.connect(self.handle_gui_modification)

        self.initUI()
        self.apply_styles()
        self.load_code_editors()

    def initUI(self):
        main_layout = QVBoxLayout(self)
        
        # --- Top Controls ---
        control_box = QGroupBox("System Control")
        control_layout = QHBoxLayout()
        self.start_button = QPushButton("START COGNITIVE PROCESSES")
        self.start_button.clicked.connect(self.start_processes)
        self.stop_button = QPushButton("STOP COGNITIVE PROCESSES")
        self.stop_button.clicked.connect(self.stop_processes)
        self.stop_button.setEnabled(False)
        control_layout.addWidget(self.start_button)
        control_layout.addWidget(self.stop_button)
        control_box.setLayout(control_layout)
        main_layout.addWidget(control_box)

        # --- Main Tabbed Interface ---
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # -- Live System Tab --
        live_system_tab = QWidget()
        self.tabs.addTab(live_system_tab, "Live System")
        live_system_layout = QVBoxLayout(live_system_tab)
        
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left Panel: Fragment Streams
        fragment_box = QGroupBox("Thought Fragment Streams")
        fragment_layout = QVBoxLayout()
        self.fragment_display = QTextEdit()
        self.fragment_display.setReadOnly(True)
        self.fragment_display.setFont(QFont("Consolas", 9))
        fragment_layout.addWidget(self.fragment_display)
        fragment_box.setLayout(fragment_layout)
        splitter.addWidget(fragment_box)

        # Right Panel: Reflector and Input
        reflector_box = QGroupBox("Reflector's Consciousness")
        reflector_layout = QVBoxLayout()
        self.reflector_display = QTextEdit()
        self.reflector_display.setReadOnly(True)
        self.reflector_display.setFont(QFont("Consolas", 11))
        reflector_layout.addWidget(self.reflector_display)

        input_layout = QHBoxLayout()
        self.user_input = QLineEdit()
        self.user_input.setPlaceholderText("Enter a directive for the Reflector...")
        self.send_button = QPushButton("Send Directive")
        self.send_button.clicked.connect(self.send_directive)
        input_layout.addWidget(self.user_input)
        input_layout.addWidget(self.send_button)
        reflector_layout.addLayout(input_layout)
        reflector_box.setLayout(reflector_layout)
        splitter.addWidget(reflector_box)
        
        splitter.setSizes([400, 800])
        live_system_layout.addWidget(splitter)

        # -- Config Editor Tab --
        config_tab = QWidget()
        self.tabs.addTab(config_tab, "Config Editor (config.py)")
        config_layout = QVBoxLayout(config_tab)
        self.config_editor = QTextEdit()
        self.config_editor.setFont(QFont("Consolas", 10))
        config_layout.addWidget(self.config_editor)
        config_button_layout = QHBoxLayout()
        self.save_config_button = QPushButton("Save config.py")
        self.save_config_button.clicked.connect(lambda: self.save_code_file('config'))
        self.reload_button = QPushButton("Save & Reload System")
        self.reload_button.clicked.connect(self.reload_system)
        config_button_layout.addWidget(self.save_config_button)
        config_button_layout.addWidget(self.reload_button)
        config_layout.addLayout(config_button_layout)

        # -- Utils Editor Tab --
        utils_tab = QWidget()
        self.tabs.addTab(utils_tab, "Utils Editor (utils.py)")
        utils_layout = QVBoxLayout(utils_tab)
        self.utils_editor = QTextEdit()
        self.utils_editor.setFont(QFont("Consolas", 10))
        utils_layout.addWidget(self.utils_editor)
        utils_button_layout = QHBoxLayout()
        self.save_utils_button = QPushButton("Save utils.py")
        self.save_utils_button.clicked.connect(lambda: self.save_code_file('utils'))
        utils_button_layout.addWidget(self.save_utils_button)
        utils_layout.addLayout(utils_button_layout)

    def apply_styles(self):
        self.setStyleSheet("""
            QWidget { background-color: #2b2b2b; color: #dcdcdc; }
            QGroupBox { border: 1px solid #555; margin-top: 1ex; font-size: 14px; font-weight: bold; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding: 0 3px; }
            QLineEdit, QTextEdit { background-color: #3c3f41; border: 1px solid #555; }
            QPushButton { background-color: #0d6efd; color: white; border: none; padding: 8px; }
            QPushButton:hover { background-color: #0b5ed7; }
            QPushButton:disabled { background-color: #555; }
            QTabWidget::pane { border-top: 1px solid #555; }
            QTabBar::tab { background: #3c3f41; border: 1px solid #555; border-bottom: none; padding: 8px 15px; }
            QTabBar::tab:selected { background: #2b2b2b; }
        """)

    def start_processes(self):
        logger.info("Starting all cognitive threads...")
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        
        self.reflector_thread.setup()
        self.reflector_thread.start()

        for i in range(config.ArchitectConfig.NUM_FRAGMENT_GENERATORS):
            thread = FragmentGeneratorThread(config.ArchitectConfig.ORCHESTRATED_THOUGHT_STREAM_IDS[i], self)
            thread.fragment_generated.connect(self.display_fragment)
            thread.fragment_generated.connect(self.reflector_thread.add_fragment)
            thread.setup()
            thread.start()
            self.fragment_threads.append(thread)

    def stop_processes(self):
        logger.info("Stopping all cognitive threads...")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        
        self.reflector_thread.stop()
        for thread in self.fragment_threads:
            thread.stop()
        
        # Wait for threads to finish
        self.reflector_thread.wait()
        for thread in self.fragment_threads:
            thread.wait()

        self.fragment_threads.clear()

    def display_fragment(self, fragment_cfo):
        display_text = (
            f"[{datetime.datetime.now().strftime('%H:%M:%S')}] "
            f"FROM: {fragment_cfo['source_module']}\n"
            f"{fragment_cfo['content']}\n\n"
        )
        self.fragment_display.append(display_text)

    def display_reflection(self, reflection_text):
        self.reflector_display.append(reflection_text)

    def send_directive(self):
        directive = self.user_input.text().strip()
        if directive:
            self.reflector_thread.add_directive(directive)
            self.reflector_display.append(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] DIRECTIVE SENT: {directive}\n\n")
            self.user_input.clear()

    def load_code_editors(self):
        try:
            with open('config.py', 'r') as f:
                self.config_editor.setPlainText(f.read())
            with open('utils.py', 'r') as f:
                self.utils_editor.setPlainText(f.read())
            logger.info("Loaded config.py and utils.py into editors.")
        except Exception as e:
            logger.error(f"Error loading files into editors: {e}")

    def save_code_file(self, file_type):
        try:
            if file_type == 'config':
                with open('config.py', 'w') as f:
                    f.write(self.config_editor.toPlainText())
                logger.info("Saved config.py")
            elif file_type == 'utils':
                with open('utils.py', 'w') as f:
                    f.write(self.utils_editor.toPlainText())
                logger.info("Saved utils.py")
            return True
        except Exception as e:
            logger.error(f"Error saving {file_type}.py: {e}")
            return False

    def reload_system(self):
        logger.info("ATTEMPTING TO RELOAD SYSTEM...")
        
        if not self.save_code_file('config'): return
        if not self.save_code_file('utils'): return

        # *** FAILSAFE MECHANISM STARTS HERE ***
        try:
            with open('config.py', 'r') as f:
                compile(f.read(), 'config.py', 'exec')
            with open('utils.py', 'r') as f:
                compile(f.read(), 'utils.py', 'exec')
            logger.info("Syntax check passed for config.py and utils.py.")
        except Exception as e:
            error_traceback = traceback.format_exc()
            error_message = f"SYNTAX ERROR - RELOAD ABORTED!\n\n{error_traceback}\n\nThe system is still running on the old code. Please fix the error and try again."
            logger.error(error_message)
            QMessageBox.critical(self, "Syntax Error", error_message)
            
            # *** SELF-HEALING LOOP ***
            error_directive = f"A SyntaxError was detected during a system reload attempt. Analyze the following error and propose a fix for the code. Error details:\n\n{error_traceback}"
            self.send_directive_from_system(error_directive)
            # *** END SELF-HEALING LOOP ***

            return # Abort the reload
        # *** FAILSAFE MECHANISM ENDS HERE ***

        # Stop and restart threads only if syntax is valid
        if not self.start_button.isEnabled():
            self.stop_processes()
        
        try:
            importlib.reload(config)
            importlib.reload(utils)
            from modules.core_llm_interface import chat_with_llm
            importlib.reload(sys.modules['modules.core_llm_interface'])

            logger.info("Successfully reloaded config.py and utils.py.")
            self.start_processes()
        except Exception as e:
            error_traceback = traceback.format_exc()
            error_message = f"Failed to reload modules: {error_traceback}"
            logger.error(error_message)
            QMessageBox.critical(self, "Reload Error", error_message)
            self.start_button.setEnabled(True)
            self.stop_button.setEnabled(False)
            
            # *** SELF-HEALING LOOP ***
            error_directive = f"An error occurred during module reload. Analyze the following error and propose a solution. Error details:\n\n{error_traceback}"
            self.send_directive_from_system(error_directive)
            # *** END SELF-HEALING LOOP ***

    def send_directive_from_system(self, directive_text):
        """A special method to send directives from the system itself, like for errors."""
        self.reflector_thread.add_directive(directive_text)
        self.reflector_display.append(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] SYSTEM ALERT: An error has occurred and has been sent to the Reflector for analysis.\n\n")

    def handle_gui_modification(self, command):
        """Handles commands from the Reflector to modify the GUI."""
        action = command.get('action')
        if action == 'add_tab':
            tab_name = command.get('tab_name', 'New Tab')
            archive_dir = command.get('archive_dir')
            filter_types = command.get('filter_types')
            if tab_name and archive_dir:
                self.add_new_tab(tab_name, archive_dir, filter_types)

    def add_new_tab(self, tab_name, archive_dir, filter_types=None):
        """Dynamically creates and adds a new tab to the GUI."""
        logger.info(f"Dynamically adding new tab: {tab_name}")
        
        tab = QWidget()
        self.tabs.addTab(tab, tab_name)
        layout = QHBoxLayout(tab)
        listbox = QListWidget()
        display_area = QTextEdit()
        display_area.setReadOnly(True)
        display_area.setFont(QFont("Consolas", 10))
        
        layout.addWidget(listbox, 1)
        layout.addWidget(display_area, 2)
        
        QMessageBox.information(self, "System Update", f"A new tab '{tab_name}' has been added to the interface.")
    
    def closeEvent(self, event):
        self.stop_processes()
        event.accept()

# --- Main Execution ---
if __name__ == "__main__":
    # Ensure necessary files exist for the first run
    if not os.path.exists('config.py'):
        with open('config.py', 'w') as f: f.write("# Placeholder for ArchitectConfig\nclass ArchitectConfig:\n    pass\n")
    if not os.path.exists('utils.py'):
        with open('utils.py', 'w') as f: f.write("# Placeholder for utility functions\n")
    if not os.path.exists('modules/core_llm_interface.py'):
        os.makedirs('modules', exist_ok=True)
        with open('modules/core_llm_interface.py', 'w') as f: f.write("# Placeholder for LLM interface\ndef chat_with_llm(history, **kwargs):\n    return 'LLM Error: Not implemented.'\n")

    app = QApplication(sys.argv)
    window = FAO_GUI_Environment()
    window.show()
    sys.exit(app.exec())
