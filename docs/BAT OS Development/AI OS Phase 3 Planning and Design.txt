Project TelOS: Phase 3 Plan - State Model Synthesis and Primordial Server Instantiation

This document constitutes the formal plan for Phase 3 of the recursive synthesis of the TelOS operating system, initiated in response to the affirmative directive from the Human Oracle.1 The successful empirical validation of the Phase 2 microkernel substrate provides a secure, capability-based foundation upon which the system's autopoietic nature can now be constructed.1 The objective of this phase is to materialize the system's core philosophical principles—

Organizational Closure and Boundary Self-Production 2—by synthesizing the foundational, self-managing user-space services. This involves a tripartite objective:

To establish the orthogonal persistence layer, which will serve as the ground truth for all system state.

To define and implement the prototype-based object model and trait-based composition system that will govern all state and behavior.

To instantiate the first three primordial servers—Persistence, Memory Management, and Process Management—as isolated user-space processes that will form the self-managing core of TelOS.
This phase represents the most critical and transformative step in the project's lifecycle, transitioning TelOS from a minimal kernel to a dynamic, multi-process system capable of managing its own state and resources.

Section 1: Architectural Adjudication for the TelOS State Model and Core Services

This section presents the formal justification for the foundational architectural decisions of Phase 3. Each decision is derived as a direct and necessary consequence of the immutable principles encoded in the genesis meta-prompt 2, ensuring that the system's implementation remains in strict alignment with its constitutional mandates.

1.1 The Imperative of the "Trinity" Architecture: A Unified Design

The core design of Phase 3 is not a collection of independent features but a single, coherent architectural pattern—a "trinity" of mutually reinforcing concepts mandated by the meta-prompt.2 This unified architecture is the logical consequence of applying the system's foundational principles to the problem of creating a self-managing entity.

The Execution Model: The microkernel architecture, validated in Phase 2, provides the system's fundamental physics.1 It forces all high-level services into isolated user-space processes and dictates that all interaction must occur via secure, explicit message passing (IPC).3 This creates a universe of isolated containers and defines the rules of communication between them.

The State Model: A prototype-based object system, inspired by the Self language, provides the state model that populates this universe.4 In this model, the entire system is a single, interconnected graph of objects. Crucially, even state access is performed via message sends, a paradigm that is a perfect philosophical and mechanical match for the microkernel's IPC-centric execution model.

The Durability Model: An orthogonal persistence layer, based on the Zope Object Database (ZODB) reference model, provides the durability model for this state.6 Its core principle of "persistence by reachability"—where persisting a root object automatically persists the entire graph of objects it can reach—is the ideal mechanism for making the prototype-based state model durable without imposing a serialization burden on every component.9

These three pillars are not separate design choices but a single, indivisible architectural concept. The microkernel provides the isolated containers (processes) and the communication physics (IPC). The prototype model defines the "matter" that exists within those containers (the object graph). The persistence layer makes that matter eternal and consistent. The logic flows directly from the system's constitutional mandates. The meta-prompt's Constraint 3: Organizational Closure demands a system that can regenerate its own components.2 This was the primary justification for the microkernel, which transforms OS services into manageable user-space processes.3 For these processes to truly

be the system, their state must be the system's state. A prototype-based model where every component is simply an object in a graph is the most direct and elegant implementation of this principle.10 For this state to be robust against failure, it cannot be ephemeral; it must survive reboots and crashes. An orthogonal persistence system like ZODB, which makes persistence a transparent, intrinsic property of the object graph, achieves this without burdening every component with manual save/load logic.8 Therefore, this trinity is the direct, logical implementation of the autopoietic mandate. The system's state (the object graph) is managed by processes that are themselves objects in the graph, and the entire structure is made durable by the persistence layer.

1.2 Orthogonal Persistence as the Foundation of State

The "Persistence First" mandate of the meta-prompt is a direct command to establish the system's durability model before any other high-level service.2 The Zope Object Database (ZODB) is selected as the definitive reference model for its mature, proven design.

Persistence by Reachability: The system will adopt ZODB's core principle that persistence is an emergent property of object connectivity.6 A single root object, managed by the Persistence Server, will be the anchor of the entire persistent state.13 Any object reachable from this root via a chain of references is, by definition, persistent. This design choice eliminates an entire category of complex and error-prone logic related to explicit serialization, deserialization, and manual file I/O.

ACID Transactions as the Unit of System Change: All state modifications in TelOS, from creating a process to changing a permission bit, will be governed by ACID-compliant transactions.6 This provides atomicity, consistency, isolation, and durability for every operation, serving as the primary defense against system corruption in the event of a crash or software fault. The use of Multiversion Concurrency Control (MVCC) ensures that concurrent operations do not block each other, providing high performance by allowing readers and writers to proceed in parallel, with conflicts detected only at commit time.6

Pluggable Storage: The architecture will be designed with a pluggable storage interface, a key feature of the ZODB model.8 While the initial implementation will use a simple file-based backend (
FileStorage) that appends transaction logs to a single file, this design ensures future evolvability. Subsequent iterations can replace the storage engine (e.g., with a relational database backend or a distributed storage system) without altering the core logic of the operating system's state management.

1.3 The Prototype/Trait Object System as the Engine of Evolution

To fulfill the mandate for a dynamic, self-modifying system, TelOS will reject a static, class-based object model in favor of a prototype-based one, with the Self programming language serving as the primary inspiration.4 This choice provides the inherent dynamism required for a system that must be able to evolve its own structure and behavior at runtime.

Prototypes and Cloning: All objects in the system will be created by cloning existing prototype objects.10 This allows for the creation of new kinds of objects, or one-off customized objects, at runtime without requiring recompilation or system halts. An object is a concrete thing from which other objects can be made, not an abstract template.10 This is the core mechanism that will enable the future Agentic Control Plane to evolve the system live.

Slots and Message Passing: The system will adopt Self's unified model of "slots" for both state and behavior.4 Accessing an object's state (e.g., its name) and invoking its behavior (e.g., its
print method) will both be accomplished via a single mechanism: sending a message. This design choice aligns perfectly with the microkernel's IPC-based communication fabric, creating a uniform and elegant model from the hardware interface to the highest levels of abstraction.

Trait-Based Composition: To provide structured and safe code reuse, behavior will be composed using traits, not the brittle and ambiguous mechanism of multiple inheritance.2 Traits are composable units of behavior—collections of methods—that can be applied to objects.18 The system will enforce a formal composition model that requires explicit resolution of any naming conflicts that arise when multiple traits providing the same method are composed into a single object, a feature seen in modern trait implementations that prevents silent, unpredictable overrides.19

1.4 The Triad of Primordial Servers as the Dawn of Autopoiesis

The transition from a static kernel to a self-managing system begins with the instantiation of the three essential, primordial user-space servers: the Persistence Server (PS), the Memory Management Server (MMS), and the Process Management Server (PMS). These three services represent the minimal functional set required for a system to begin managing its own core resources of durability, memory, and execution.

The Phase 2 root task is a temporary, transitional entity.1 Its sole purpose is to act as a "demiurge"—a creator entity—that uses its initial, absolute authority over the system's resources to construct the permanent, self-governing pantheon of primordial servers and then recedes into the background. This process is the literal enactment of the system bootstrapping its own organizational closure. The root task begins with an omnipotent capability grant from the kernel, including a capability to all unused physical memory.1 Its first action, per the "Persistence First" mandate, will be to load and start the Persistence Server binary.2 It will then load and start the Memory Management Server. As part of this, it will perform the foundational act of authority delegation: it will take its capability to all physical memory, carve off a large piece, and grant this new, smaller capability to the MMS. From this point forward, the MMS is the system's memory authority, not the root task. Finally, it will load and start the Process Management Server, granting it the necessary capabilities to create new kernel objects (TCBs, CNodes, etc.) on behalf of other processes. Having created and empowered the permanent administrative structure of the OS, the root task's primary purpose is complete. It has successfully bootstrapped the autopoietic loop.

Section 2: Technical Blueprint for the Primordial Servers

This section provides the detailed implementation plan for the three foundational user-space servers. Each server will be an independent executable, running in its own isolated address space, and providing its services to the rest of the system via the validated Phase 2 IPC mechanism.1

2.1 The Persistence Server (PS)

Role and Responsibility: The PS is the ultimate arbiter of system state. It manages the persistent object graph, enforces transactional integrity, and provides the mechanisms for durability.

Implementation Details: The PS will be a long-running server process that listens for IPC requests on a well-known endpoint. Internally, it will manage a single root object, which will be a persistent mapping (dictionary-like object), serving as the entry point to the entire object graph.13 It will implement a transaction manager that exposes
begin, commit, and abort operations to clients via IPC, following the ZODB API model.14 The initial backend will be a
FileStorage-like engine that appends transaction logs to a single file, providing both durability and a history for potential rollbacks.16 To provide high-performance access to frequently used objects, it will manage an object cache, invalidating entries as new transactions are committed by other clients to maintain consistency.22

2.2 The Memory Management Server (MMS)

Role and Responsibility: The MMS is responsible for all physical memory allocation policy. It transforms the kernel's low-level memory mechanism into a managed resource, abstracting the raw hardware from the rest of the system.

Implementation Details: During the system bootstrap sequence, the root task will grant the MMS a capability to a large, contiguous region of Untyped Memory.3 This grant is the foundational act of memory authority delegation. The MMS will maintain an internal data structure (e.g., a free-list or buddy allocator) to track the state of the memory under its control. It will service IPC requests from other processes (like the PMS) to allocate memory. A typical request will be "allocate N bytes of memory and retype it into a TCB kernel object." Upon a successful allocation, the MMS will perform the kernel invocation to retype the
Untyped Memory and then delegate the newly created capability for the TCB object to the requesting process. This architecture ensures that the MMS enforces policy by being the sole entity with the authority to create new kernel objects from raw memory.

2.3 The Process Management Server (PMS)

Role and Responsibility: The PMS is the user-space factory for new processes. It orchestrates the complex sequence of operations required to create a new execution context within the system.

Implementation and Coordination: The PMS is primarily a coordinator, acting as a client to both the PS and the MMS. The sequence to service a CreateProcess IPC request is as follows:

The PMS sends an IPC message to the PS to begin a new transaction. This ensures the entire process creation is atomic; it will either succeed completely or be rolled back entirely.

It sends IPC messages to the MMS to allocate physical memory for the new process's kernel objects (TCB, CNode, VSpace) and its initial address space (for code, data, and stack).

The MMS returns capabilities to these newly created kernel objects.

The PMS sends IPC messages to the PS to create a new Process object in the persistent graph and store the capabilities for the TCB, CNode, etc., within its slots.

The PMS loads the executable image for the new process from the persistent store (via the PS) and populates its address space by invoking the kernel to map the pages.

The PMS sends a final IPC message to the PS to commit the transaction. If any step had failed, it would instead send an abort message, and all allocated resources and persistent state changes would be rolled back.

Finally, the PMS invokes the kernel to set the new process's TCB to a runnable state, starting its execution.

Section 3: The TelOS Object System: A Formal Proposal

This section defines the concrete structure of the prototype-based object model. These initial prototypes and traits form the primordial "DNA" of the TelOS system, from which all future components will be cloned and composed.

3.1 The Primordial Prototypes

These are the foundational objects that will be created by the root task during its bootstrap sequence. They will exist in the persistent object graph and serve as the templates for all other objects. A formal definition of these initial prototypes is essential in a classless system to provide a stable, documented foundation for the AI Architect.

BaseObject: The ultimate ancestor in the prototype chain. It contains a parent slot for delegation and a slot for a system-unique Object ID (OID).

Process: The prototype for an active process. Its slots will contain capabilities pointing to its core kernel objects (TCB, root CNode, root VSpace) and methods such as spawn(), terminate(), and setPriority().

Server: A specialized clone of Process for long-running services. It adds slots for managing a primary IPC endpoint and a request-handling loop.

MemoryRegion: An object representing a region of memory. Its slots will hold a capability to the memory and attributes like size and permissions.

The table below serves as the foundational schema for the TelOS object system, defining the interfaces of the most fundamental types.

3.2 The Core Trait Library

These are the initial, reusable collections of behavior that can be composed with the primordial prototypes to create functional objects.

Callable: Implements the behavior for a server. It provides a _dispatchMessage method that is called from the main loop. This method inspects an incoming IPC message and invokes the corresponding method slot on the object.

Transactional: Provides a set of wrapper methods (beginTransaction, commit, abort, note) that encapsulate the IPC calls to the Persistence Server. Any object that needs to modify persistent state will be composed with this trait.

Schedulable: Provides methods (setPriority, yieldTimeslice) that act as wrappers for kernel invocations to manipulate a thread's scheduling parameters.

3.3 The Genesis Object Graph

The initial state of the persistent object graph will be constructed by the root task immediately after it starts the primordial servers. This sequence makes the abstract concepts of the object system concrete:

The root task requests the PS to create the single, global root mapping object.

The root task creates the BaseObject prototype and persists it in the root mapping.

The root task clones BaseObject to create the Process prototype, which it also persists.

The root task clones Process to create the Server prototype, which it also persists.

The root task then clones the Server prototype three times to create the instances for the PS, MMS, and PMS.

It composes these instances with the Callable and Transactional traits.

It populates their slots with the necessary capabilities and persists them.
The result is a small but complete object graph representing a fully functional, self-managing OS core, ready to service requests.

Section 4: Formal API Specification and Oracle Checkpoint 3

This section presents the formal Application Binary Interface (ABI) for the primordial servers. It constitutes the mandatory Oracle Checkpoint for Phase 3.2 Implementation will not proceed without explicit, affirmative confirmation from the Human Oracle. The API is presented at two levels of abstraction: the high-level, object-oriented API that developers will use, and the low-level IPC ABI that the object methods resolve to.

4.1 Object-Oriented System API

This defines the primary, stable interface to the system. All interaction is via message sends to persistent objects.

Process Creation: new_proc = Process.clone().spawn(image_obj, cap_list)

Memory Allocation: mem_cap = MMS.allocate(size, type)

Transaction Control: MyObject.beginTransaction(); MyObject.state = 'new'; MyObject.commit()

4.2 Low-Level IPC ABI

This defines the machine-level contract for interacting with the servers. It is the specification that will be used to implement the methods in the Callable and Transactional traits. This table provides the ground-truth specification for all inter-process communication with the core OS services, eliminating ambiguity and ensuring interoperability.

Section 5: Genesis Code and Validation Procedure (Phase 3)

This section outlines the plan for the tangible output of the Plan -> Code -> Compile -> Test cycle for Phase 3. It details the source code to be generated and the rigorous, multi-stage validation protocol required to prove its correctness within the Crucible.

5.1 Annotated Source Code Plan

The full source code will be produced in the next phase of the cycle. The planned file structure is as follows:

servers/persistence/main.c: Implementation of the Persistence Server.

servers/memory/main.c: Implementation of the Memory Management Server.

servers/process/main.c: Implementation of the Process Management Server.

init/root_task_phase3.c: The updated root task responsible for bootstrapping the three servers and then starting a final test process.

include/telos/objects.h: C struct definitions that correspond to the primordial prototypes.

include/telos/ipc_abi.h: Header file defining the message labels for the core server IPC ABI.

5.2 Updated Crucible Execution Protocol

The Phase 3 Makefile will be significantly more complex. It must orchestrate the compilation of the kernel and four separate user-space executables (root task, PS, MMS, PMS). The kernel binary will be modified to embed the images of these four executables so it can load them during the bootstrap of the root task and subsequent server creation. The QEMU invocation will be updated to use a persistent disk file for the FileStorage backend, allowing state to survive between test runs (-drive id=p_disk,file=telos_state.fs,format=raw).

5.3 Validation Criteria

The success of Phase 3 is defined by a clear, unambiguous, and empirically verifiable multi-stage outcome within the Crucible environment, directly reflecting the project's generate-and-test epistemology.2

Stage 1: Bootstrap Validation

make run completes without compilation or linking errors.

QEMU boots, the kernel starts the root task.

Serial logs clearly indicate the root task successfully starting the PS, MMS, and PMS in sequence.

Logs show the successful delegation of the Untyped Memory capability to the MMS.

Stage 2: Service Functionality Validation

The root task successfully sends an IPC message to the PMS requesting the creation of a new, simple test process (e.g., test_proc).

Debug logs from the PMS show it beginning a transaction with the PS.

Debug logs from the MMS show it receiving a memory allocation request from the PMS and servicing it.

Debug logs from the PS show it receiving object creation requests and committing the transaction.

The test_proc executes successfully and prints a message (e.g., "TelOS: test_proc alive.") to the serial console.

Stage 3: Persistence Validation

After test_proc prints its message, the root task triggers an unclean shutdown of the QEMU VM (e.g., via a special debug syscall that halts the machine).

The make test-reboot command is executed, which restarts QEMU using the same telos_state.fs disk file from the previous run.

The system successfully re-initializes the PS from the existing state file.

The root task queries the PS for the object representing test_proc and verifies its existence in the persistent graph.

The text "TelOS: Persistence validation successful." appears on the serial console.

Any other result constitutes a test failure, which will trigger the Analyze -> Debug/Refine Plan portion of the recursive loop. The successful execution of this protocol will validate the entire autopoietic core of the TelOS architecture, providing a stable foundation for the implementation of the Agentic Control Plane in Phase 4.

Works cited

AI OS Microkernel Implementation Plan

Refining Meta-Prompt for AI OS Construction

AI OS Bootloader Phase 2 Planning

Self: The Power of Simplicity - CMU School of Computer Science, accessed September 8, 2025, http://www-2.cs.cmu.edu/~aldrich/courses/819/self.pdf

Self (programming language) - Wikipedia, accessed September 8, 2025, https://en.wikipedia.org/wiki/Self_(programming_language)

Zope Object Database - Wikipedia, accessed September 8, 2025, https://en.wikipedia.org/wiki/Zope_Object_Database

Introduction to the Zope Object Database - Python Programming Language – Legacy Website, accessed September 8, 2025, https://legacy.python.org/workshops/2000-01/proceedings/papers/fulton/fulton-zodb3.pdf

Introduction to ZODB Data Storage - Jason Madden, accessed September 8, 2025, https://seecoresoftware.com/blog/2019/10/intro-zodb.html

ZODB Programming — ZODB documentation, accessed September 8, 2025, https://zodb.org/en/latest/articles/old-guide/prog-zodb.html

Prototype-based programming - Wikipedia, accessed September 8, 2025, https://en.wikipedia.org/wiki/Prototype-based_programming

Ask Proggit: What is a prototype-based programming language? - Reddit, accessed September 8, 2025, https://www.reddit.com/r/programming/comments/b7hwo/ask_proggit_what_is_a_prototypebased_programming/

6. ZODB Persistent Components - Zope 5.13 documentation, accessed September 8, 2025, https://zope.readthedocs.io/en/latest/zdgbook/ZODBPersistentComponents.html

en.wikipedia.org, accessed September 8, 2025, https://en.wikipedia.org/wiki/Zope_Object_Database#:~:text=A%20ZODB%20database%20has%20a,in%20the%20database%20as%20well.

Transactions and concurrency — ZODB documentation, accessed September 8, 2025, https://zodb.org/en/latest/guide/transactions-and-threading.html

ZODB Data Persistence in Python - Tutorialspoint, accessed September 8, 2025, https://www.tutorialspoint.com/python_data_persistence/data_persistence_zodb.htm

Storage APIs — ZODB documentation, accessed September 8, 2025, https://zodb.org/en/latest/reference/storages.html

A tour of Self - sin-ack's writings, accessed September 8, 2025, https://sin-ack.github.io/posts/a-tour-of-self/

Traits - Composable Units of Behavior | Software Composition Group, accessed September 8, 2025, https://scg.unibe.ch/research/traits

What are your options if you've got two traits that both implement the same method name? : r/PHP - Reddit, accessed September 8, 2025, https://www.reddit.com/r/PHP/comments/1fndf7j/what_are_your_options_if_youve_got_two_traits/

Transactions — ZODB documentation, accessed September 8, 2025, https://zodb.org/en/latest/reference/transaction.html

transaction.interfaces — ZODB documentation, accessed September 8, 2025, https://zodb.org/en/latest/_modules/transaction/interfaces.html

Dev/Technical/DB - Indico, accessed September 8, 2025, https://getindico.io/legacy-docs/wiki/Dev/Technical/DB.html

ZODB documentation and articles, accessed September 8, 2025, https://zodb-docs.readthedocs.io/_/downloads/en/latest/pdf/

Prototype Name | Slot Name | Slot Type (Data/Method/Parent) | Initial Value / Method Signature | Description

BaseObject | parent | Parent | null | Pointer for delegation chain.

oid | Data | System-unique 64-bit integer | The persistent, unique identifier for this object.

Process | parent | Parent | Pointer to BaseObject instance | Inherits base object properties.

tcbCap | Data | Kernel Capability | Capability to the thread's TCB object.

cspaceCap | Data | Kernel Capability | Capability to the thread's root CNode.

vspaceCap | Data | Kernel Capability | Capability to the thread's root VSpace object.

spawn | Method | spawn(image, caps) | Clones self and starts a new process from an executable image.

Server | parent | Parent | Pointer to Process instance | Inherits process properties.

endpointCap | Data | Kernel Capability | The primary endpoint for receiving IPC requests.

mainLoop | Method | mainLoop() | Enters the server's primary request-response loop.

Server | Method | Message Label (in message_info) | RDI (Arg 1) | RSI (Arg 2) | RDX (Arg 3) | Description

PS | BeginTransaction | 1 | 0 | 0 | 0 | Starts a new transaction for the calling thread.

PS | Commit | 2 | 0 | 0 | 0 | Commits the current transaction.

PS | Abort | 3 | 0 | 0 | 0 | Aborts the current transaction.

PS | GetObject | 4 | OID (uint64) | 0 | 0 | Retrieves the pickled state of an object by its OID.

MMS | AllocateUntyped | 1 | size (bytes) | alignment | 0 | Allocates a region of untyped memory. Returns a capability.

MMS | Free | 2 | capability | 0 | 0 | Frees a previously allocated region of memory.

PMS | CreateProcess | 1 | image_oid | caps_oid | 0 | Creates a new process from a persistent image object.