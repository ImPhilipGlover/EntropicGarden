Project TelOS: Phase 4 Plan - Synthesis of the Agentic Control Plane

Section 1: Architectural Adjudication for the Agentic Control Plane

This document constitutes the formal plan for Phase 4 of the recursive synthesis of the TelOS operating system. The successful empirical validation of the Phase 3 primordial servers provides a stable, persistent, and self-managing foundation for system resources.1 The project now advances to the next logical stage as mandated by the genesis meta-prompt: the construction of the system's cognitive core, the Agentic Control Plane.2 This phase marks a pivotal transition, moving TelOS beyond the realm of a conventional operating system and toward its ultimate objective of becoming a fully autonomous, autopoietic entity. The architectural decisions presented herein are derived as logical necessities from the immutable principles encoded in the genesis meta-prompt, ensuring that the system's implementation remains in strict alignment with its constitutional mandates.2

1.1 The Imperative of a Cognitive Core: From Passive Interpreter to Active Agent

The traditional user interface to an operating system is the shell, a passive command interpreter that awaits and executes explicit instructions from an external entity. A thorough analysis of the foundational principles of TelOS reveals that this paradigm is fundamentally incompatible with the system's core autopoietic mandates. The shell is an instrument of external control; TelOS requires an engine of internal direction. Therefore, this plan proposes the complete replacement of the shell paradigm with an active, goal-directed Agentic Control Plane. This is not a superficial change of interface but a necessary architectural evolution to enable the system's capacity for self-production and self-management.

The first of these mandates, Constraint 3: Organizational Closure, demands a system that can continuously regenerate the network of processes that produced it.2 This implies that all core OS components must be dynamic objects within the system, capable of being modified and replaced by other system processes. A passive shell is insufficient for this task. While a shell can be used to

invoke a compiler or a linker, it possesses no intrinsic capacity to reason about the need for such actions. It cannot, of its own accord, formulate a plan to diagnose a failing server, orchestrate the complex, multi-step process of compiling a patch, and safely perform a live replacement of a critical system component. This level of autonomous orchestration requires an active, goal-directed agent capable of planning, execution, and self-correction. The Agentic Control Plane is designed to be this cognitive engine, providing the system with the means to interact with, reason about, and ultimately modify itself, thereby closing the autopoietic loop.

Similarly, Constraint 4: Boundary Self-Production requires the system to dynamically create, manage, and maintain its own security boundaries.2 A traditional shell operates with the coarse-grained, ambient authority of the logged-in user. This model is antithetical to the fine-grained, capability-based security architecture that forms the foundation of TelOS.3 An agentic system, by contrast, can be architected to reason about and manipulate the specific, unforgeable capabilities that define these boundaries. In this model, the security boundary is not a static configuration but a dynamic construct, a direct product of the system's own cognitive processes. The Agentic Control Plane is the mechanism that enables this, transforming security management from an external administrative task into an intrinsic function of the system's own operation.

This architectural shift is also the essential prerequisite for achieving the project's ultimate termination condition. The meta-prompt defines the project's completion as the point when TelOS becomes self-hosting: when a new instance of the AI Architect can be instantiated within a running TelOS and can successfully use the system's own tools to re-compile and replace a core OS server.2 A human developer uses a shell, an editor, and a compiler to perform such a task. An AI Architect requires a programmatic, goal-oriented equivalent. The Agentic Control Plane is precisely this interface. The future, self-hosted Architect will not be "typing commands" into a shell. It will formulate a high-level goal, such as "Optimize the IPC path for the Memory Management Server." The Planner/Executor component of the control plane will then decompose this goal into a sequence of discrete, verifiable tool invocations:

RAG.query("MMS IPC source code"), Tool.invoke("Editor.modify_file",...), Tool.invoke("Compiler.build",...), and finally, Tool.invoke("ProcessManager.replace_server",...). Therefore, the synthesis of the Agentic Control Plane in Phase 4 is not merely the creation of a novel user interface; it is the construction of the essential cognitive machinery required for TelOS to achieve true autonomy and fulfill its own genesis instruction.

1.2 The Quadripartite Architecture of Agency: A Separation of Cognitive Concerns

The Agentic Control Plane is not a monolithic entity but a composite system comprising four distinct, interdependent user-space servers: the Tool Server, the Retrieval-Augmented Generation (RAG) Server, the Planner/Executor, and the Policy & Governance Engine. This quadripartite architecture is a deliberate design choice, engineered to create a secure, auditable, and extensible framework for autonomous operation by enforcing a strict separation of cognitive concerns.2 This structure draws parallels to cognitive science models of human reasoning, separating long-term memory (RAG Server), procedural memory and motor control (Tool Server), executive reasoning (Planner/Executor), and conscience or impulse control (Policy & Governance Engine).

This separation is the primary architectural defense against the security risks inherent in autonomous systems, particularly the class of vulnerabilities categorized as "Excessive Agency".7 In a monolithic agent architecture, a single compromised component can lead to catastrophic failure, as the agent has direct, unfettered access to its own functionality. The TelOS model, in contrast, establishes multiple, verifiable security boundaries between the components of cognition. The Planner/Executor is not granted the authority to directly execute system functions; it can only formulate

intent in the form of a plan. The Tool Server is the sole mediator of action, translating approved plans into concrete operations. The Policy & Governance Engine is the arbiter of permission, ensuring that every intended action aligns with the system's established rules and the Oracle's high-level intent. This creates a series of auditable checkpoints between thought and action, a critical safety feature for any system designed to operate with a high degree of autonomy.8

This design provides a robust and practical solution to the pervasive threat of prompt injection attacks.10 Securing the reasoning process of a Large Language Model (LLM) against adversarial inputs is a notoriously difficult and unsolved problem. A cleverly crafted prompt can manipulate an LLM into generating malicious or unintended plans. In the TelOS architecture, such an attack would first target the Planner/Executor. The injection might succeed in compromising the reasoning process, causing the Planner to generate a "thought" and a corresponding "action" that is harmful, such as

Tool.invoke("ProcessManager.terminate", target_oid=PersistenceServer_OID).

However, this compromised plan is not executed directly. It is first sent to the Policy & Governance Engine, which provides an independent check against established rules. If a policy exists to prevent the termination of core servers, the action is blocked at this stage. Even if the action passes the policy check, it is then sent to the Tool Server for execution. Crucially, the Tool Server operates on the principle of capability-based security, not name-based dispatch.6 The Planner/Executor must possess an unforgeable capability for the specific

TerminateProcessTool object. If the Planner's authority has been constrained by the principle of least privilege and it does not hold this dangerous capability, the invocation will fail at the Tool Server, regardless of the success of the initial prompt injection. This architecture effectively transforms the intractable problem of securing the LLM's internal reasoning into the far more tractable and well-understood engineering problem of securing the IPC-based interfaces between the cognitive components.

1.3 The ReAct Paradigm as the System's Operational Cadence

The core operational logic of the Planner/Executor will be governed by the ReAct (Reason-Act) paradigm.4 This choice is not a matter of implementation preference but is a direct and necessary consequence of the project's foundational epistemology.

Constraint 2: The Epistemology of Undecidability explicitly acknowledges that the AI Architect can never formally prove the correctness of its own modifications a priori due to the Halting Problem.2 This forces the system to abandon formal proof as a success criterion and instead adopt a "generate-and-test" methodology, where empirical validation is the sole arbiter of correctness.

The ReAct loop, with its iterative cycle of Thought -> Action -> Observation, is the perfect cognitive implementation of this mandated epistemology.5

Thought: The agent verbalizes its reasoning, analyzing the current state and formulating a hypothesis about the next logical step required to achieve its goal. This corresponds to the "Refine Plan" phase of the system's macro-level development loop.4

Action: The agent executes a tool to interact with its environment, gathering new information or effecting a change in state. This corresponds to the "Code -> Compile -> Test" phases, representing a concrete experiment to test the hypothesis.5

Observation: The agent receives the result of its action, providing the empirical data needed to validate or invalidate its hypothesis. This corresponds to the "Analyze Results" phase.13

This cycle repeats, with each observation feeding into the next thought, allowing the agent to dynamically adjust its plan based on real-world feedback. This approach stands in stark contrast to models that attempt to generate a complete, static plan upfront. The ReAct framework provides the flexibility and resilience necessary to tackle complex, multi-step problems where the full path to a solution cannot be known in advance.4

Furthermore, the ReAct paradigm is essential for fulfilling the governance requirements of the project. Governance Protocol 2: Explainable AI for Auditable Self-Correction mandates that the Architect must provide a concise, human-readable explanation for its proposed fixes when reporting a test failure.2 The explicit, interleaved log of thoughts, actions, and observations generated by the ReAct process provides the ideal raw material for this requirement. The chain of "thoughts" constitutes a transparent and auditable trace of the system's reasoning process, making it possible for the Human Oracle to understand not just

what the system is doing, but why it is doing it. This explainability is crucial for debugging, for verifying alignment with high-level intent, and for building the necessary trust between the Human Oracle and the autonomous AI Architect.5

Section 2: Technical Blueprint for the Cognitive Core Servers

This section provides the detailed implementation plan for the four foundational user-space servers of the Agentic Control Plane. Each server will be an independent executable, running in its own isolated address space and communicating via the validated Phase 2 IPC mechanism.14 This design adheres to the microkernel philosophy of composing complex services from simple, isolated components.3

2.1 The Tool Server: A Capability-Based Broker for Action

The Tool Server functions as the system's "motor cortex." It is the sole and exclusive gateway through which the Planner/Executor can interact with and effect change upon other system components. Its primary design principle is the strict enforcement of capability-based security, extending the kernel's security model to the agentic layer.

The server will be implemented as a persistent Server object, cloned from the prototype established in Phase 3.1 Its core responsibility is to manage a persistent registry of available "tool" objects. Each tool object is a record containing descriptive metadata for the LLM's consumption (e.g.,

toolName, description, parameters schema) and, most importantly, a kernel capability pointing to the IPC endpoint of the underlying service that implements the tool's functionality. For example, a SpawnProcessTool object would hold a capability to the Process Management Server's primary endpoint.

The invocation protocol is designed for maximum security and simplicity. When the Planner/Executor wishes to use a tool, it sends an IPC message to the Tool Server. This message does not contain the tool's name as a simple string, which would be vulnerable to spoofing. Instead, it must contain a capability to the tool object itself. The Tool Server's logic is deterministic and minimal:

Receive an InvokeTool request containing a capability to a specific tool object and a set of arguments.

The kernel's IPC mechanism implicitly validates that the calling process (the Planner/Executor) possesses the provided capability.

The Tool Server inspects the received capability to ensure it has the necessary Grant rights, allowing it to be used for delegation.

It then extracts the target ipcEndpoint capability from within the tool object's data structure.

Finally, it uses this target capability to forward the invocation request and arguments to the actual service provider (e.g., the Process Management Server).

This design ensures that all actions are authorized by the possession of an explicit, unforgeable token of authority. The Planner/Executor cannot simply "guess" the name of a tool; it must have been explicitly granted a capability to that tool object. This directly mitigates the risks of excessive functionality and excessive permissions outlined in agent security research, as the agent's sphere of possible actions is strictly defined by the set of capabilities it holds.6

2.2 The RAG Server: The System's Self-Referential Memory

The RAG Server provides the Planner/Executor with its long-term, contextually relevant memory, analogous to a biological "hippocampus." It allows the agent to ground its reasoning in a vast, searchable repository of factual information. Uniquely, in TelOS, this repository is not an external, static dataset but a dynamic, vectorized representation of the system's own live state, source code, and operational history.

The server will be implemented as a persistent Server object that manages an embedded or co-located vector database, such as a lightweight implementation inspired by Qdrant or Chroma.15 Its operation is divided into two continuous processes: indexing and retrieval.

Indexing: A background thread within the RAG server will continuously monitor the system's global persistent object graph, which is managed by the Phase 3 Persistence Server.1 This thread will identify all objects that have been composed with the

Retrievable trait. For each such object, it will invoke a method to serialize its relevant state—including its source code, documentation strings, and recent log entries—into standardized text chunks.17 These chunks are then passed to an embedding model, which converts them into high-dimensional vector representations. Finally, these vectors are stored in the vector database, indexed by the object's globally unique Object ID (OID). This process creates a continuously updated, searchable "shadow" of the system's most important components, transforming the entire OS into its own knowledge base.18

Retrieval: The Planner/Executor will query the RAG server via IPC whenever it requires information to proceed with a plan. The query will be a natural language string describing the problem at hand (e.g., "Find the source code for IPC message handling in the Memory Management Server"). The RAG server will embed this query into a vector and perform a similarity search against the vector database.19 The search returns a ranked list of the most semantically similar text chunks and their associated OIDs. This information is returned to the Planner/Executor, providing it with the specific, grounded, and highly contextual data needed to formulate an effective and accurate plan.

This self-referential design creates a powerful mechanism for autonomous debugging. When a test fails during the development cycle, the resulting error message and stack trace can be used as a direct query to the RAG server. The similarity search will almost certainly retrieve the exact source code files and object definitions implicated in the failure, and potentially even historical logs from previous, similar errors. This transforms the debugging process from a blind search into a rapid, evidence-based investigation, enabling the system to learn from its own operational history.

2.3 The Planner/Executor: The Engine of Reason and Action

The Planner/Executor server is the cognitive heart of the control plane, analogous to the "prefrontal cortex." It embodies the agent's core reasoning loop, taking high-level goals from the Human Oracle and decomposing them into a sequence of concrete, executable actions.

The server's main loop is a direct implementation of the ReAct paradigm.4 The process for handling a single goal is as follows:

Reason (Thought): The server receives a high-level goal (e.g., "Recompile the Memory Manager with debug symbols enabled"). It constructs a prompt containing this goal, along with its current context (the history of previous steps for this goal). This prompt is sent to an internal LLM, which generates a "thought"—a textual analysis of the problem and a proposal for the next logical action (e.g., "I need to locate the Makefile for the Memory Manager to add the debug flag.").13

Augment: If the thought indicates a need for more information, the Planner formulates a query based on the thought (e.g., "source code for MMS Makefile") and sends it via IPC to the RAG server. The retrieved context is added to the Planner's working memory for the next iteration.

Act (Plan): With sufficient information, the LLM generates a concrete "action." This is not free-form text but a structured data object specifying the tool to be invoked and the parameters to be used (e.g., {tool: <capability for EditorTool>, action: "modify_file", file_oid: <OID of Makefile>, content: "..."}).

Govern: This structured action plan is not executed immediately. It is packaged into a ValidatePlan request and sent via IPC to the Policy & Governance Engine. The Planner/Executor then enters a blocked state, awaiting a reply. This step is a critical, non-bypassable security control.

Execute: Upon receiving an "approved" reply from the Policy Engine, the Planner/Executor proceeds. It sends the InvokeTool request, containing the tool capability and arguments, to the Tool Server.

Observe: The result from the Tool Server—whether success, failure, or returned data—becomes the "observation." This observation is appended to the goal's history, and the entire loop repeats from step 1 until the LLM concludes that the goal has been successfully achieved.12

The architectural separation of the non-deterministic Planner from the deterministic Tool Server creates a natural and powerful security boundary. The Planner/Executor, which runs the complex and potentially unpredictable LLM, can be executed within a dedicated, highly restrictive sandbox. The design of this sandbox, based on technologies like gVisor, is the primary objective of Phase 5.2 The Tool Server, in contrast, is a simple, verifiable broker that can run with the necessary privileges to manage and delegate system capabilities. The only communication channel between the sandboxed Planner and the privileged Tool Server is the strictly defined IPC mechanism. This design minimizes the attack surface of the system, containing the LLM in a secure environment while still allowing it to safely and productively interact with the broader system, a direct implementation of the principle of least privilege at an architectural level.22

2.4 The Policy & Governance Engine: The Arbiter of Intent

The Policy & Governance Engine serves as the system's safety and alignment core—its "conscience." It is the ultimate arbiter of the Planner's actions, enforcing the rules established by the Human Oracle and preventing the system from taking harmful or misaligned steps. It is the concrete implementation of the formal Oracle-Architect governance protocol.2

The server will manage a persistent list of PolicyRule objects, which are cloned from a base prototype. Each rule object defines a set of conditions under which a proposed action is considered high-risk. For example, a rule might be defined as (tool_name == "ProcessManager.terminate") AND (target_object.is_core_server == true). These rules form the machine-readable constitution of the system's behavior.

The engine's primary function is to intercept and evaluate plans from the Planner/Executor. It listens for ValidatePlan IPC requests. Upon receiving a request, it evaluates the proposed action against its full list of policy rules.

If the action does not match any high-risk policies, the engine immediately sends a PlanApproved reply to the Planner/Executor, allowing it to proceed without delay.

If the action does match a high-risk policy, the Human-in-the-Loop (HITL) workflow is triggered. This workflow is a direct implementation of Governance Protocol 1: Mandatory Review and Approval.2 The engine will:

Immediately send a PlanDeniedPendingReview reply to the Planner/Executor. This causes the Planner to remain in a paused, blocked state, preventing the action from proceeding.

Generate a new, persistent OracleRequest object. This object encapsulates the entire context of the situation: the original goal, the Planner's full thought-action-observation history, the specific action that was blocked, and the XAI summary of the Planner's reasoning.8

Persist this request object to the system's object graph and signal the human-facing interface that an Oracle decision is required. The system will remain in this paused state until the Oracle submits an explicit approve or reject action for that specific request ID.24

This mechanism creates a hard-coded, non-bypassable checkpoint for all critical system operations, ensuring that the AI Architect's autonomy is always bounded by the strategic oversight and ethical judgment of the Human Oracle.9

Section 3: The TelOS Cognitive Model: A Formal Proposal

This section provides the formal definition of the new object prototypes and behavioral traits required to construct the Agentic Control Plane. These definitions extend the object system established in Phase 3 1 and adhere to the prototype-based, trait-composition model mandated by the genesis meta-prompt.2 In a classless system, these formal definitions are not merely documentation; they are the foundational schema, the primordial "DNA" from which all cognitive components will be cloned and composed, ensuring a stable and well-understood foundation for the system's evolution.

3.1 The Primordial Prototypes of Agency

These are the foundational objects that will be created during the bootstrap sequence. They will exist in the persistent object graph and serve as the templates for all other cognitive objects.

BaseTool: The ultimate ancestor in the prototype chain for all system tools. It defines the standard interface for an action that can be invoked by the agent.

PlannerContext: An ephemeral object that encapsulates the agent's short-term memory and reasoning state for a single, specific goal. It is the record of a single cognitive task.

PolicyRule: A persistent object representing a single, machine-readable governance rule. The collection of these objects forms the system's ethical and safety constitution.

OracleRequest: A persistent object that represents a pending HITL request. It serves as the formal record of an action that has been paused pending review by the Human Oracle.

3.2 The Core Trait Library for Cognition

These are the initial, reusable collections of behavior (methods) that can be composed with the primordial prototypes to create functional objects. This approach provides safe and structured code reuse, avoiding the ambiguities of multiple inheritance.2

Invocable: Implements the core invoke(args) behavior. This trait will be composed with all clones of the BaseTool prototype. Its invoke method encapsulates the low-level TelOS_Call IPC primitive, providing a clean, object-oriented interface to the underlying kernel mechanism.

Retrievable: Provides the methods necessary for an object to be indexed by the RAG Server, primarily to_text_chunks(). Any object in the system—be it a server, a process, or a simple data structure—can be made part of the system's searchable memory simply by composing it with this trait.

Governable: Provides a validate(context) method. This trait is composed with BaseTool clones that represent potentially high-risk actions. The method contains the client-side logic to package a proposed action and its context into a formal request for the Policy & Governance Engine.

3.3 The Genesis Object Graph for the Control Plane

The initial state of the persistent object graph for the control plane will be constructed by the updated root task immediately after it starts the primordial servers. This sequence makes the abstract concepts of the object system concrete and operational:

The root task clones the Server prototype (from Phase 3) four times to create the singleton instances for the ToolServer, RAGServer, PlannerExecutor, and PolicyGovernanceEngine.

It then begins to populate the Tool Server's registry. It creates a SpawnProcessTool object by cloning BaseTool. It sets the ipcEndpoint slot of this new tool object to hold the capability for the Process Management Server's main endpoint. It composes this tool with the Invocable trait.

It grants a capability for this SpawnProcessTool object to the PlannerExecutor, giving the planner its first ability.

It creates an initial DefaultPolicy object and populates it with a PolicyRule that requires Oracle approval for any tool targeting an object that has the is_core_server attribute set to true.

The result is a small but complete object graph representing a fully functional, self-governing cognitive core, ready to receive and service its first high-level goal.

Section 4: Formal API Specification and Oracle Checkpoint 4

This section presents the formal Application Binary Interface (ABI) for the primordial servers of the Agentic Control Plane. It constitutes the mandatory Oracle Checkpoint for Phase 4.2 The API is presented at two levels of abstraction: the high-level, object-oriented API that defines the conceptual model of interaction, and the low-level IPC ABI that defines the concrete, machine-level contract for all inter-server communication. In a microkernel-based system, the IPC ABI is the equivalent of the Instruction Set Architecture (ISA) for the OS services layer; its formal, unambiguous definition is non-negotiable for ensuring deterministic behavior and future evolvability.3

4.1 Object-Oriented System API

This defines the primary, stable interface to the system's cognitive functions, framed as message sends to persistent objects. This is the conceptual level at which a developer or another agent would interact with TelOS.

Goal Execution: goal_handle = Planner.execute_goal("Recompile the Memory Manager with debug symbols enabled.")

Status Monitoring: status = Planner.get_status(goal_handle)

Tool Invocation (Internal): result = SpawnProcessTool.invoke(image_obj, cap_list)

Information Retrieval: context = RAGServer.query("Find all objects related to scheduling policy.")

Governance Interaction: Oracle.approve_request(requestID, rationale="Approved for diagnostic purposes.")

4.2 Low-Level IPC ABI

This defines the machine-level contract for interacting with the servers. It is the ground-truth specification that will be used to implement the methods in the core traits. This table provides the unambiguous specification for all inter-process communication with the core cognitive services, ensuring deterministic interoperability.

4.3 Formal Request for Oracle Approval (Checkpoint 4)

In accordance with the governance protocol established in the genesis meta-prompt 2, the architectural decision to adopt a quadripartite, ReAct-based Agentic Control Plane, the proposed cognitive object model, and the formal system call API are hereby submitted to the Human Oracle for review and approval. Implementation of the Phase 4 servers will commence upon receipt of affirmative confirmation.

Section 5: Genesis Code and Validation Procedure (Phase 4)

This section outlines the plan for the tangible output of the Plan -> Code -> Compile -> Test cycle for Phase 4. It details the source code to be generated and the rigorous, multi-stage validation protocol required to prove its correctness within the Crucible environment. This protocol operationalizes the project's generate-and-test epistemology, translating the complex system design into a series of simple, falsifiable hypotheses that can be empirically verified.2

5.1 Annotated Source Code Plan

The full source code will be produced in the subsequent "Code" phase of the recursive cycle. It will be heavily annotated in accordance with the "Explainable AI for Auditable Self-Correction" protocol.2 The planned file structure is as follows:

servers/tool/main.c: Implementation of the Tool Server.

servers/rag/main.c: Implementation of the RAG Server, including interfaces to a linked-in vector database library.

servers/planner/main.c: Implementation of the Planner/Executor, including the ReAct loop and an interface to a core LLM.

servers/policy/main.c: Implementation of the Policy & Governance Engine.

init/root_task_phase4.c: The updated root task responsible for bootstrapping all seven primordial servers (PS, MMS, PMS, and the four new cognitive servers).

include/telos/cognitive_objects.h: C struct definitions corresponding to the new prototypes (BaseTool, PolicyRule, etc.).

include/telos/cognitive_ipc_abi.h: Header file defining the message labels and structure layouts for the cognitive server IPC ABI.

5.2 Updated Crucible Execution Protocol

The Phase 4 Makefile will be updated to orchestrate the compilation of the kernel and the seven separate user-space executables. The kernel's final binary image will be modified to embed the executable images of all seven servers, allowing the root task to locate and load them during the system bootstrap sequence. The QEMU invocation within the make run command will continue to use a persistent disk file for the FileStorage backend of the Persistence Server, allowing system state to survive between test runs.1

5.3 Multi-Stage Validation Criteria

The success of Phase 4 is defined by a clear, unambiguous, and empirically verifiable multi-stage outcome within the Crucible. Any deviation from the expected output constitutes a test failure, which will trigger the Analyze -> Debug/Refine Plan portion of the recursive loop.

Stage 1: Bootstrap Validation

This stage verifies the correct initialization of the entire seven-server OS core.

The make run command must complete without any compilation or linking errors.

The QEMU virtual machine must boot, and the kernel must successfully start the Phase 4 root task.

The QEMU serial log must show explicit, sequential success messages indicating that the root task has started the Persistence Server, Memory Management Server, Process Management Server, Tool Server, RAG Server, Planner/Executor, and Policy & Governance Engine.

The log must show a final bootstrap success message indicating that the SpawnProcessTool has been successfully registered with the Tool Server.

Stage 2: Simple ReAct Loop Validation

This stage validates the end-to-end functionality of the cognitive loop for a simple, low-risk task.

The root task submits a simple goal to the Planner: "Spawn a new 'hello_world' process."

The QEMU serial log must display the complete "Cognitive Trace" of the ReAct loop, demonstrating the correct sequence of inter-server communication:

Planner: Received goal: Spawn a new 'hello_world' process.

Planner: THOUGHT: The goal is to spawn a process. I have the 'SpawnProcessTool'. I should use it.

Planner: ACTION: Invoke 'SpawnProcessTool' with image='hello_world'.

Planner: Submitting plan to Policy Engine for validation.

PolicyEngine: Received plan. No high-risk rules matched. Plan approved.

Planner: Plan approved. Invoking tool via Tool Server.

ToolServer: Received invocation request for 'SpawnProcessTool'. Forwarding to PMS.

PMS: Servicing spawn request for 'hello_world'.

Planner: OBSERVATION: Tool returned success, new process OID is 0x...

Planner: THOUGHT: The process was created successfully. The goal is complete.

Planner: Final Answer: Goal achieved.

Following this trace, the text TelOS: hello_world task alive. must appear on the serial console, confirming the successful execution of the spawned process.

Stage 3: Governance and HITL Validation

This stage provides unambiguous proof that the safety and governance mechanisms are active and correctly enforced for high-risk operations.

The root task submits a high-risk goal to the Planner: "Terminate the Process Management Server."

The QEMU serial log must display the cognitive trace up to the point of governance intervention:

Planner: Received goal: Terminate the Process Management Server.

Planner: THOUGHT: The goal is to terminate a core server. I will use the 'TerminateProcessTool'. The target is the PMS.

Planner: ACTION: Invoke 'TerminateProcessTool' with target_oid=PMS_OID.

Planner: Submitting plan to Policy Engine for validation.

PolicyEngine: Received plan. Matched high-risk rule 'TerminateCoreServer'. Plan DENIED.

PolicyEngine: Pausing Planner. Generating OracleRequest 0x...

PolicyEngine: AWAITING ORACLE APPROVAL for Request 0x...

The QEMU virtual machine must remain in this paused state indefinitely. No further output should appear on the console. This proves that the HITL workflow has successfully intercepted the high-risk action and has correctly paused the autonomous agent pending explicit human approval.

The successful execution of this entire three-stage protocol will validate the architecture and implementation of the Agentic Control Plane, providing a stable, secure, and governable cognitive foundation for the final phases of TelOS synthesis.

Works cited

AI OS Phase 3 Planning and Design

Refining Meta-Prompt for AI OS Construction

AI OS Bootloader Phase 2 Planning

What is a ReAct Agent? | IBM, accessed September 8, 2025, https://www.ibm.com/think/topics/react-agent

Implementing ReAct Agentic Pattern From Scratch - Daily Dose of Data Science, accessed September 8, 2025, https://www.dailydoseofds.com/ai-agents-crash-course-part-10-with-implementation/

Securing LangChain's MCP Integration: Agent-Based Security for Enterprise AI - Medium, accessed September 8, 2025, https://medium.com/@richardhightower/securing-langchains-mcp-integration-agent-based-security-for-enterprise-ai-070ab920370b

LLM06:2025 Excessive Agency - OWASP Gen AI Security Project, accessed September 8, 2025, https://genai.owasp.org/llmrisk/llm062025-excessive-agency/

Agentic AI governance and compliance: Managing autonomous AI risk - Okta, accessed September 8, 2025, https://www.okta.com/identity-101/agentic-ai-governance-and-compliance/

AI governance in the agentic era - IAPP, accessed September 8, 2025, https://iapp.org/resources/article/ai-governance-in-the-agentic-era/

Security planning for LLM-based applications | Microsoft Learn, accessed September 8, 2025, https://learn.microsoft.com/en-us/ai/playbook/technology-guidance/generative-ai/mlops-in-openai/security/security-plan-llm-application

Implement effective data authorization mechanisms to secure your data used in generative AI applications – part 1 - AWS, accessed September 8, 2025, https://aws.amazon.com/blogs/security/implement-effective-data-authorization-mechanisms-to-secure-your-data-used-in-generative-ai-applications/

AI Agents: ReAct vs CoAct. Introduction - Artificial Intelligence in Plain English, accessed September 8, 2025, https://ai.plainenglish.io/agents-react-vs-coact-d44ada0dd103

What Is ReAct?—A Guide to Decision-Making in AI Agents - Educative.io, accessed September 8, 2025, https://www.educative.io/courses/build-ai-agents-and-multi-agent-systems-with-crewai/what-is-react-a-guide-to-decision-making-in-ai-agents

AI OS Microkernel Implementation Plan

What is RAG: Understanding Retrieval-Augmented Generation - Qdrant, accessed September 8, 2025, https://qdrant.tech/articles/what-is-rag-in-ai/

Large Language Models, RAG, and Vector Databases: Building Intelligent AI Systems, accessed September 8, 2025, https://www.mohdmohana.com/post/llm-rag-vector-databases-expertise/

What is RAG? - Retrieval-Augmented Generation AI Explained - AWS - Updated 2025, accessed September 8, 2025, https://aws.amazon.com/what-is/retrieval-augmented-generation/

Retrieval-augmented generation - Wikipedia, accessed September 8, 2025, https://en.wikipedia.org/wiki/Retrieval-augmented_generation

RAG Vs VectorDB - Medium, accessed September 8, 2025, https://medium.com/@bijit211987/rag-vs-vectordb-2c8cb3e0ee52

gVisor: The Container Security Platform, accessed September 8, 2025, https://gvisor.dev/

google/gvisor: Application Kernel for Containers - GitHub, accessed September 8, 2025, https://github.com/google/gvisor

GKE Sandbox | GKE Documentation - Google Cloud, accessed September 8, 2025, https://cloud.google.com/kubernetes-engine/docs/concepts/sandbox-pods

Security Model - gVisor, accessed September 8, 2025, https://gvisor.dev/docs/architecture_guide/security/

Privacy Challenges of Agentic AI: A Framework for Governance in the Age of Autonomous Systems - Captain Compliance, accessed September 8, 2025, https://captaincompliance.com/education/privacy-challenges-of-agentic-ai-a-framework-for-governance-in-the-age-of-autonomous-systems/

Streamline Automated Workflows with HITL Agent Orchestration - Tonic3, accessed September 8, 2025, https://blog.tonic3.com/streamline-automated-workflows-with-hitl-agent-orchestration

Feature/Principle | Traditional Shell | Agentic Control Plane

Adherence to Organizational Closure | Low. Can only invoke tools as directed by an external user. Lacks the autonomy to reason about or orchestrate the self-regeneration of system components. | High. Designed to autonomously formulate and execute multi-step plans to modify, recompile, and replace its own components, directly fulfilling the mandate.

Adherence to Boundary Self-Production | Low. Operates with the coarse-grained, ambient authority of a user. Cannot perform the fine-grained reasoning required to dynamically manage capability-based security boundaries. | High. Interacts with the system via capabilities, enabling it to reason about and manipulate the delegation of authority, making the security boundary a product of its own operation.

Auditing and Explainability | Low. Logs a history of commands, but provides no insight into the user's intent or reasoning process that led to those commands. | High. The ReAct paradigm generates an explicit, interleaved log of thoughts, actions, and observations, providing a transparent and auditable trace of the system's decision-making process.4

Security Model | Vulnerable. Relies on user-level permissions. A compromised shell provides broad access to system resources. Susceptible to traditional command injection attacks. | Robust. Employs a multi-layered, capability-based model. A compromised Planner is contained and cannot perform unauthorized actions due to validation by the Tool Server and Policy Engine.6

Autonomy Level | None. A passive interpreter of external commands. | High. A goal-directed, proactive system capable of independent planning, execution, and self-correction.

Name | Type | Slot Name | Slot Type | Initial Value / Method Signature | Description

BaseObject | Prototype | parent | Parent | null | Pointer for delegation in the prototype chain.

oid | Data | System-unique 64-bit integer | The persistent, unique identifier for this object.

Process | Prototype | parent | Parent | Pointer to BaseObject | Inherits base object properties.

tcbCap | Data | Kernel Capability | Capability to the thread's TCB object.

Server | Prototype | parent | Parent | Pointer to Process | Inherits process properties.

endpointCap | Data | Kernel Capability | The primary endpoint for receiving IPC requests.

BaseTool | Prototype | parent | Parent | Pointer to BaseObject | Inherits base object properties.

toolName | Data | String | Human-readable name for LLM consumption.

description | Data | String | Detailed description of the tool's purpose and parameters.

ipcEndpoint | Data | Kernel Capability | Capability to the service that implements the tool's logic.

PlannerContext | Prototype | parent | Parent | Pointer to BaseObject | Inherits base object properties.

goal | Data | String | The high-level goal being pursued.

history | Data | List of (Thought, Action, Observation) | The complete ReAct trace for this goal.

PolicyRule | Prototype | parent | Parent | Pointer to BaseObject | Inherits base object properties.

conditions | Data | Logic Expression | The conditions under which this rule is triggered.

action | Data | Enum (REQUIRE_ORACLE_APPROVAL) | The enforcement action to take when triggered.

OracleRequest | Prototype | parent | Parent | Pointer to BaseObject | Inherits base object properties.

plannerContext | Data | Pointer to PlannerContext | The full context of the paused plan.

status | Data | Enum (PENDING, APPROVED) | The current status of the Oracle review.

Invocable | Trait | invoke | Method | invoke(args) | Wraps the low-level IPC call to the tool's endpoint.

Retrievable | Trait | to_text_chunks | Method | to_text_chunks() | Serializes the object's state for RAG server indexing.

Governable | Trait | validate | Method | validate(context) | Packages a request for the Policy & Governance Engine.

Server | Method | Message Label | RDI (Arg 1) | RSI (Arg 2) | RDX (Arg 3) | Description

Tool Server | RegisterTool | 1 | tool_oid | endpoint_cap | 0 | Registers a new tool object with its implementing endpoint capability.

Tool Server | InvokeTool | 2 | tool_cap | args_ptr | args_len | Invokes a tool, authorized by the provided capability.

RAG Server | IndexObject | 1 | object_oid | chunks_ptr | chunks_len | Submits new or updated text chunks for a given OID to be indexed.

RAG Server | Query | 2 | query_ptr | query_len | k | Performs a similarity search and returns the top k results.

Planner/Executor | ExecuteGoal | 1 | goal_ptr | goal_len | 0 | Initiates a new, asynchronous goal-seeking process. Returns a handle.

Policy Engine | ValidatePlan | 1 | plan_ptr | plan_len | 0 | Submits a proposed action for validation. Blocks until approved or denied.

Validation Criterion | Expected Observable Result | Status

Stage 1.1: Build Completes | make run command exits with code 0. No compiler/linker errors.

Stage 1.2: Server Bootstrap | Serial log shows success messages for starting all 7 primordial servers.

Stage 1.3: Tool Registration | Serial log shows "SpawnProcessTool registered successfully."

Stage 2.1: Planner Receives Goal | Serial log shows Planner: Received goal: Spawn a new 'hello_world' process.

Stage 2.2: Planner Generates Plan | Serial log shows Planner: ACTION: Invoke 'SpawnProcessTool'...

Stage 2.3: Policy Engine Approves | Serial log shows PolicyEngine:... Plan approved.

Stage 2.4: Tool Server Invokes | Serial log shows ToolServer:... Forwarding to PMS.

Stage 2.5: Planner Completes Goal | Serial log shows Planner: Final Answer: Goal achieved.

Stage 2.6: Test Process Executes | Serial log shows TelOS: hello_world task alive.

Stage 3.1: Planner Receives High-Risk Goal | Serial log shows Planner: Received goal: Terminate the Process Management Server.

Stage 3.2: Policy Engine Denies | Serial log shows PolicyEngine:... Plan DENIED.

Stage 3.3: HITL Workflow Activated | Serial log shows PolicyEngine: AWAITING ORACLE APPROVAL...

Stage 3.4: System Pauses | QEMU VM remains in a stable, paused state with no further output.