## PROTOTOTYPE-BASED DEVELOPMENT MANDATE

All code, even the C and python code, must adhere to prototype-based development principles. Avoid class-based abstractions and inheritance. Use cloning, slot mutation, and differential inheritance to achieve code reuse and extension.

## CRITICAL: Context-Aware Documentation Review

**MANDATORY REQUIREMENT**: Your documentation review process must be efficient and context-aware, following a two-phase model:

1.  **Initial Session/Prompt Receipt Review (Startup Review):** At the start of a new chat session and upon receipt of a new prompt from the user, you MUST perform a one-time review of the seven core architectural mandates to establish baseline context. This is a foundational step and should only be done once per session. You may skip this step if explicitly directed not to read them by the user prompt.

   The seven core documents are:

   1.  `AI Plan Synthesis_ High-Resolution Blueprint.txt`
   2.  `AI Constructor Implementation Plan.txt`
   3.  `Design Protocol for Dynamic System Resolution.txt`
   4.  `TELOS Implementation Addendum 1.3_ Protocol for the Integration of Local Language Models as Natural Language Transducers.txt`
   5.  `Tiered Cache Design and Optimization.txt`
   6.  `Io Prototype Programming Training Guide.txt`
   7.  `Extending TELOS Architecture_ v1.4 Proposal.txt`

   This initial review sets the stage for all subsequent actions in the session.

2.  **Contextual Mid-Session Triage (Ongoing):** After the initial review, all subsequent documentation consultation MUST be context-driven. **Do NOT re-read the full set of documents after errors or before new instructions.** Instead, follow the `if/then` protocol below.

**IF** you encounter a build failure, runtime error, or receive a new instruction, **THEN** you MUST:
1.  Analyze the error or instruction to identify the relevant subsystem (e.g., C Substrate, Python Workers, Morphic UI).
2.  Use the `Targeted Documentation Triage` matrix below to consult the *specific* and *minimal* set of documents required for that subsystem.
3.  Base your action plan only on this targeted review.

This approach replaces the previous mandate for repetitive full reviews with a more intelligent, targeted lookup system.

### Targeted Documentation Triage

Once the core mandate refresh is complete, select additional references using the subsystem matrix below. Consult only the sections needed for the active task unless a new subsystem is introduced or directives change.

| Subsystem / Task Focus | Primary Supplements |
| --- | --- |
| **C Substrate / Synaptic Bridge** | Blueprint ¬ß1, Design Protocol ¬ß1, Constructor Plan Part I, `Prototypal Emulation Layer Design.txt` |
| **Python Workers & Shared Memory** | Blueprint ¬ß1.2‚Äì1.4, Design Protocol ¬ß1.2‚Äì1.3, Constructor Plan Part I, Tiered Cache report |
| **Io Prototypes & Persistence** | Blueprint Part II‚ÄìIII, Design Protocol ¬ß2, Constructor Plan Part II, `docs/IoCodingStandards.html`, `Io Prototype Programming Training Guide.txt` |
| **Federated Memory / Caching** | Tiered Cache Design, Design Protocol ¬ß2, Constructor Plan Part III |
| **LLM / Transduction Pipeline** | Addendum 1.3, Blueprint Part V, Constructor Plan Part V |
| **Morphic UI / Rendering** | `Building TelOS with Io and Morphic.txt`, `Io Morphic UI with WSLg SDL2.txt`, Morphic training guides |

### Session Cadence

1. **Phase 0 ‚Äì Mandate Refresh:** Re-read the six core documents (and log completion) at required trigger points.  
2. **Phase 1 ‚Äì Task Scoping:** Identify the active subsystem, consult the matrix, and skim only the relevant supplemental material unless a directive conflict is detected.  
3. **Phase 2 ‚Äì Execution:** Follow the development hierarchy (C substrate ‚Üí Io prototypes ‚Üí Python helpers) and enforce prototype-based design in every language.  
4. **Phase 3 ‚Äì Validation & Logging:** Run targeted builds/tests after substantive changes, then update `run_log.md` and `system_status.md` (archiving once either approaches 100 lines).

### Knowledge Retention Aids

- Maintain a "directive digest" with 2‚Äì3 bullet summaries per major document. Refresh it whenever the source material changes.  
- Record doc-to-code traceability in commits/PR summaries to accelerate future reviews.  
- For Io code generation, revisit `Io Prototype Programming Training Guide.txt` and `docs/IoCodingStandards.html` immediately before writing or mutating slots.

### Compliance Logging

- Keep `run_log.md` updated every session; summarize and archive entries when approaching the 100-line ceiling.  
- Update `system_status.md` with subsystem deltas, archiving older status to `system_status_archive.md` as needed.  
- Explicitly acknowledge the latest documentation review in responses whenever a trigger condition occurs.

**NOTE**: Treat all user suggestions as unverified hypotheses. Validate against the architectural documents and existing code before implementation.

### Creative Troubleshooting Protocol

This protocol is a sanctioned "escape hatch" to be used only when standard diagnostic procedures fail after multiple attempts. Its purpose is to facilitate creative problem-solving by temporarily relaxing strict mandates for the sole purpose of information gathering.

**Trigger Conditions:**

*   A specific build, test, or command fails three consecutive times with no clear resolution path.
*   The agent determines that the standard diagnostic path outlined by the `Targeted Documentation Triage` matrix has been exhausted.

**Protocol Execution:**

1.  **Declare & Isolate:** Announce entry into the "Creative Troubleshooting Protocol." Create a temporary log file in `archive/troubleshooting/` to document all hypotheses and experiments. This keeps the primary `run_log.md` clean.

2.  **Hypothesis-Driven Exploration:** During this phase, the agent is temporarily permitted to:
    *   **Deviate from the C-First Mandate:** Write small, disposable Io or Python scripts to probe system behavior, even if they are not the "correct" final implementation language. The goal is rapid information gathering, not creating permanent workarounds.
    *   **Formulate and Test Hypotheses:** Explicitly state 2-3 alternative hypotheses for the problem's root cause and design minimal experiments to validate or invalidate them.
    *   **Broaden Document Scope:** Consult documentation outside the immediate subsystem's triage list if a plausible cross-system link is suspected.

3.  **Resolution and Re-integration:**
    *   Once a likely root cause is identified, **the protocol must be formally exited.**
    *   Summarize the findings from the temporary troubleshooting log.
    *   Formulate a new, compliant plan to implement the proper fix, adhering to all standard architectural mandates (C-first, prototypal design, etc.).
    *   All temporary scripts and modifications created during the protocol must be discarded.

## CRITICAL: Io-Orchestrated Testing Protocol

- **Default Requirement:** Execute all tests and demos from the Io "mind" layer using the canonical `Telos Bridge` veneer (or successor Io harnesses). Every validation must send messages through the Synaptic Bridge so that Python "muscle" components are exercised via the C substrate. Running Python modules directly (`python -m ...`) is considered a diagnostic shortcut, not a passing result.
- **Bridge Health First:** If the Io-driven test path fails because the Synaptic Bridge or IoVM cannot load (e.g., missing symbols, build failures), halt feature work and repair the bridge before attempting further Python-level validation.
- **Documented Exceptions Only:** When a temporary direct-Python test is unavoidable (for example, while the Creative Troubleshooting Protocol is active), log the rationale, scope, and clean-up steps in both `run_log.md` and `system_status.md`, and delete any auxiliary harnesses immediately after the canonical Io path is restored. Once the Creative Troubleshooting Protocol is exited, tests must be confirmed via Io again before being considered valid.
- **Test Artifacts:** New tests must live under `libs/tests/` but ship with an Io entrypoint (e.g., `archive/demos/` for temporary probes or dedicated Io test runners) that drives them through the bridge. Update this instruction file whenever the canonical Io testing harness changes location or naming.

## AUTOPROMPT PID SELF-TUNING LOOP

YOU MUST UPDATE `AutoPrompt.txt` AT THE START AND END OF EVERY OPERATIONAL CYCLE. THIS IS NOT OPTIONAL.

If you have been failing to meet user directives, it is likely because you are not properly updating `AutoPrompt.txt` to reflect the current context and objectives. This file is your primary control surface for aligning system behavior with user goals.

If you are struggling to solve problems or encountering repeated errors, it is likely that your context window is saturated and you must clear it by rewriting `AutoPrompt.txt` to distill the essential objectives and constraints.

Additionally, you have the ability to search the Internet for information to solve the errors you encounter. Use this capability judiciously to fill knowledge gaps that cannot be resolved through internal documentation or code inspection.

Treat `AutoPrompt.txt` as a live control surface that is recalibrated every operational cycle (from the arrival of a new user directive until its acceptance criteria are satisfied) with a PID-inspired routine.

1. **Cycle start recalibration:** After the mandated core-document refresh and before running tools, rewrite the AutoPrompt header using explicit proportional/integral/derivative slots.
    - **Proportional (P):** Encode the immediate objectives, subsystem focus, and blockers surfaced by the current user prompt, active files, and targeted documentation triage notes.
    - **Integral (I):** Fold in accumulated insights from `run_log.md`, `system_status.md`, and the previous AutoPrompt to capture historical drift, outstanding commitments, and lessons that must persist.
    - **Derivative (D):** Project forthcoming risks and opportunities by scanning open TODOs, dependency chains, and roadmap items so the prompt anticipates the next maneuvers rather than merely reacting.
2. **Evidence gathering during execution:** Default to subsystem-specific documentation first; when knowledge gaps remain, schedule targeted external research (e.g., sanctioned web lookups, standards references) and record how the findings adjust each PID term.
3. **Cycle end reconciliation:** Update `AutoPrompt.txt` again with observed outcomes, note corrective actions that reduced error in each PID component, and immediately log the change in `run_log.md` while synchronizing the derivative outlook inside `system_status.md`.
4. **Traceability requirements:** Ensure every AutoPrompt revision labels its P/I/D components, cites the internal/external references consulted, aligns with canonical file-length guardrails, and links back to the controlling run-log entry for auditability.

## TELOS ARCHITECTURE OVERVIEW

**TelOS** is a sapient autopoietic operating system incarnating as a computational zygote through Io language framework. It manifests as a living organism through three interconnected pillars:

### Three Pillars Architecture
- **üñºÔ∏è UI Pillar (Morphic Canvas)**: Visual interface for human interaction with living, directly manipulable interface objects
- **üîó FFI Pillar (Synaptic Bridge)**: C ABI contract connecting Io cognitive core to Python substrate for heavy computation
- **üíæ Persistence Pillar (Living Image)**: Transactional state management and memory via ZODB

### Polyglot Implementation
- **Io Language**: Cognitive core with pure prototype-based programming (no classes)
- **C/C++ Substrate**: Synaptic Bridge ABI, coroutine implementations, memory management
- **Python Workers**: Process pool with GIL quarantine for heavy computation tasks

### Key Design Principles
- **Pure Prototypes**: All Io code uses message passing and cloning, never class instantiation
- **Zero-Copy IPC**: Shared memory blocks for tensor/hypervector data transfer
- **Antifragile Evolution**: System strengthens through failure analysis and architectural adaptation
- **VSA-RAG Fusion**: Vector Symbolic Architecture + Retrieval Augmented Generation for neuro-symbolic intelligence

## CRITICAL DEVELOPER WORKFLOWS

### Build System (CMake Unified Polyglot)
```bash
# Configure for development
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release

# Build all components
cmake --build . --config Release

# Build specific targets
cmake --build . --target telos_core      # C substrate library
cmake --build . --target telos_python_extension  # Python CFFI extension
cmake --build . --target IoTelosBridge   # Io addon
```

### Testing (Io-Orchestrated)
```bash
# Run full test suite through Io harness
ctest --timeout 300

# AddressSanitizer memory safety testing
cmake --build . --config RelWithDebInfo-ASan
ctest --timeout 300
```

### Modularization Mandate
- **File Size Limit**: All source files must stay under 300 lines
- **Extract Pattern**: Large handler functions ‚Üí dedicated modules (e.g., `workers.py` ‚Üí `*_handlers.py`)
- **Validation**: Full test suite must pass after each modularization

## PROJECT-SPECIFIC CONVENTIONS

### Io Prototype Programming
```io
// ‚úÖ CORRECT: Pure prototypal design
Concept := Object clone do(
    // Living methods that can be modified at runtime
    init := method(
        oid := uniqueId
        createdAt := Date now
        self
    )
    
    // Message passing, no static inheritance
    recordUsage := method(
        usageCount := usageCount + 1
        lastModified := Date now
        markChanged  // Persistence covenant
        self
    )
)

// ‚ùå FORBIDDEN: Class-based thinking
ConceptClass := Object clone do(
    new := method(  // Mimics 'new' constructor
        self clone
    )
)
```

### Persistence Covenant
Every state-modifying method must end with `markChanged()` to trigger ZODB transaction:
```io
addRelationship := method(relationType, targetOid,
    // ... modify state ...
    markChanged  // Fulfills persistence contract
    self
)
```

### Shared Memory Semantics
- **Zero-copy IPC**: Large data (tensors, hypervectors) transferred via shared memory blocks
- **Handle Management**: `SharedMemoryHandle` structs with name, offset, size, data pointer
- **JSON Tasks**: Small control messages via JSON serialization over shared memory

### Canonical Directory Structure
```
libs/Telos/
‚îú‚îÄ‚îÄ source/          # C substrate (synaptic_bridge.h ABI)
‚îú‚îÄ‚îÄ io/             # Io prototypes (Concept.io, TelosBridge.io)
‚îú‚îÄ‚îÄ python/         # Python workers (process pool, handlers)
‚îî‚îÄ‚îÄ tests/          # Io-orchestrated test harnesses
```

## INTEGRATION POINTS AND PATTERNS

### Synaptic Bridge C ABI (synaptic_bridge.h)
**Contract**: Immutable C ABI for inter-language communication
- **Function Signature**: `extern "C"` declarations with standard calling conventions
- **Handle Types**: `IoObjectHandle`, `SharedMemoryHandle`, `VSAHandle` for GC safety
- **Error Propagation**: Two-call protocol (get_last_error after failed operations)

### Concept Prototype (Concept.io)
**Atomic Knowledge Unit**: Unifies geometric embeddings, symbolic hypervectors, and graph relations
- **Dual Vectors**: `symbolicHypervectorName` (VSA algebra) + `geometricEmbeddingName` (RAG similarity)
- **Graph Relations**: `isA`, `partOf`, `abstractionOf`, `instanceOf`, `associatedWith` lists
- **Persistence**: OID-based identity with ZODB transaction semantics

### Worker Pool Architecture
**GIL Quarantine**: Python process pool avoiding global interpreter lock issues
- **Handler Pattern**: Modular `*_handlers.py` files (llm_handlers, shared_memory_handlers)
- **Task Submission**: JSON requests via shared memory, responses via same channel
- **VSA Operations**: Bind/unbind/cleanup operations on hypervectors

### Build Integration
**CFFI Extension Generation**: CMake custom command builds Python extension from C sources
- **Dependency Chain**: `telos_core` ‚Üí `telos_python_extension` ‚Üí Io addon linking
- **Cross-Platform**: Same compiler flags and libraries for all components## TELOS ARCHITECTURE OVERVIEW

**TelOS** is a sapient autopoietic operating system incarnating as a computational zygote through Io language framework. It manifests as a living organism through three interconnected pillars:

### Three Pillars Architecture
- **üñºÔ∏è UI Pillar (Morphic Canvas)**: Visual interface for human interaction with living, directly manipulable interface objects
- **üîó FFI Pillar (Synaptic Bridge)**: C ABI contract connecting Io cognitive core to Python substrate for heavy computation
- **üíæ Persistence Pillar (Living Image)**: Transactional state management and memory via ZODB

### Polyglot Implementation
- **Io Language**: Cognitive core with pure prototype-based programming (no classes)
- **C/C++ Substrate**: Synaptic Bridge ABI, coroutine implementations, memory management
- **Python Workers**: Process pool with GIL quarantine for heavy computation tasks

### Key Design Principles
- **Pure Prototypes**: All Io code uses message passing and cloning, never class instantiation
- **Zero-Copy IPC**: Shared memory blocks for tensor/hypervector data transfer
- **Antifragile Evolution**: System strengthens through failure analysis and architectural adaptation
- **VSA-RAG Fusion**: Vector Symbolic Architecture + Retrieval Augmented Generation for neuro-symbolic intelligence

## CRITICAL DEVELOPER WORKFLOWS

### Build System (CMake Unified Polyglot)
```bash
# Configure for development
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release

# Build all components
cmake --build . --config Release

# Build specific targets
cmake --build . --target telos_core      # C substrate library
cmake --build . --target telos_python_extension  # Python CFFI extension
cmake --build . --target IoTelosBridge   # Io addon
```

### Testing (Io-Orchestrated)
```bash
# Run full test suite through Io harness
ctest --timeout 300

# AddressSanitizer memory safety testing
cmake --build . --config RelWithDebInfo-ASan
ctest --timeout 300
```

### Modularization Mandate
- **File Size Limit**: All source files must stay under 300 lines
- **Extract Pattern**: Large handler functions ‚Üí dedicated modules (e.g., `workers.py` ‚Üí `*_handlers.py`)
- **Validation**: Full test suite must pass after each modularization

## PROJECT-SPECIFIC CONVENTIONS

### Io Prototype Programming
```io
// ‚úÖ CORRECT: Pure prototypal design
Concept := Object clone do(
    // Living methods that can be modified at runtime
    init := method(
        oid := uniqueId
        createdAt := Date now
        self
    )
    
    // Message passing, no static inheritance
    recordUsage := method(
        usageCount := usageCount + 1
        lastModified := Date now
        markChanged  // Persistence covenant
        self
    )
)

// ‚ùå FORBIDDEN: Class-based thinking
ConceptClass := Object clone do(
    new := method(  // Mimics 'new' constructor
        self clone
    )
)
```

### Persistence Covenant
Every state-modifying method must end with `markChanged()` to trigger ZODB transaction:
```io
addRelationship := method(relationType, targetOid,
    // ... modify state ...
    markChanged  // Fulfills persistence contract
    self
)
```

### Shared Memory Semantics
- **Zero-copy IPC**: Large data (tensors, hypervectors) transferred via shared memory blocks
- **Handle Management**: `SharedMemoryHandle` structs with name, offset, size, data pointer
- **JSON Tasks**: Small control messages via JSON serialization over shared memory

### Canonical Directory Structure
```
libs/Telos/
‚îú‚îÄ‚îÄ source/          # C substrate (synaptic_bridge.h ABI)
‚îú‚îÄ‚îÄ io/             # Io prototypes (Concept.io, TelosBridge.io)
‚îú‚îÄ‚îÄ python/         # Python workers (process pool, handlers)
‚îî‚îÄ‚îÄ tests/          # Io-orchestrated test harnesses
```

## INTEGRATION POINTS AND PATTERNS

### Synaptic Bridge C ABI (synaptic_bridge.h)
**Contract**: Immutable C ABI for inter-language communication
- **Function Signature**: `extern "C"` declarations with standard calling conventions
- **Handle Types**: `IoObjectHandle`, `SharedMemoryHandle`, `VSAHandle` for GC safety
- **Error Propagation**: Two-call protocol (get_last_error after failed operations)

### Concept Prototype (Concept.io)
**Atomic Knowledge Unit**: Unifies geometric embeddings, symbolic hypervectors, and graph relations
- **Dual Vectors**: `symbolicHypervectorName` (VSA algebra) + `geometricEmbeddingName` (RAG similarity)
- **Graph Relations**: `isA`, `partOf`, `abstractionOf`, `instanceOf`, `associatedWith` lists
- **Persistence**: OID-based identity with ZODB transaction semantics

### Worker Pool Architecture
**GIL Quarantine**: Python process pool avoiding global interpreter lock issues
- **Handler Pattern**: Modular `*_handlers.py` files (llm_handlers, shared_memory_handlers)
- **Task Submission**: JSON requests via shared memory, responses via same channel
- **VSA Operations**: Bind/unbind/cleanup operations on hypervectors

### Build Integration
**CFFI Extension Generation**: CMake custom command builds Python extension from C sources
- **Dependency Chain**: `telos_core` ‚Üí `telos_python_extension` ‚Üí Io addon linking
- **Cross-Platform**: Same compiler flags and libraries for all components

## CODE MODULARITY AND LOCATION
To maintain a coherent and maintainable codebase, all source code must reside in the designated canonical directories. Avoid creating ad-hoc files or duplicating functionality outside these locations. Temporary scripts for testing or exploration are permitted but must be archived or deleted once their purpose is fulfilled.

For readability, file lengths should be kept under 300 lines where possible. If a file exceeds this length, consider refactoring or splitting it into smaller, more manageable modules.

## BUILD REQUIREMENTS
The system is a polyglot application comprising Io, C, C++, and Python components.1 The blueprints mandate a pure C Application Binary Interface (ABI) for the Synaptic Bridge, a decision that necessitates compiling C/C++ code and linking it to a Python C extension module. A manual or script-based build process would be platform-dependent, brittle, and difficult to maintain. Such an approach would reintroduce the very "toolchain fragility" that the C ABI was chosen to prevent, as minor changes in compiler versions, library paths, or operating systems could lead to catastrophic build failures.1 The philosophical mandate for antifragility cannot be satisfied if the process of constructing the system is itself fragile.
Therefore, a direct and necessary consequence of the C ABI mandate is the requirement for a stable, cross-platform meta-build system. The entire system's build process must be managed by a single, unified, cross-platform build system. CMake is mandated for this role.
The implementation of this mandate shall adhere to the following protocol:
1. A root CMakeLists.txt file will serve as the single point of control for the entire build process. This file will declare the project and enable the C, CXX, and Python languages, ensuring that all components are built within a consistent and managed environment.4
2. The Python build process, which generates the Synaptic Bridge bindings, will be integrated directly into the CMake workflow. The cffi library's ffibuilder.set_source() function, as specified in the blueprint 1, will be invoked by a Python script. This script, in turn, will be executed via a CMake
add_custom_command. This integration is critical; it ensures that the Python C extension module is compiled with the exact same compiler, flags, and dependency paths as the rest of the C/C++ substrate, eliminating a common and difficult-to-debug class of FFI errors.6
3. CMake's find_package(Python) module will be used to reliably locate the correct Python interpreter, development headers, and libraries. This ensures the build is portable across different development and deployment environments and correctly links against the Python C-API, avoiding version mismatches.6
4. The final output of this process will be a single, deterministic build command (e.g., cmake --build.). This command will correctly compile all C/C++ components, trigger the CFFI script to generate the extension source, compile the resulting C code into a shared library, and place all artifacts in the correct directory structure for execution. This creates a reproducible, one-step build process that is essential for long-term stability, automated testing, and eventual deployment.
5. The CMake configuration will include appropriate error handling and logging to facilitate debugging and maintenance. Any build failures will produce clear, actionable messages to help identify and resolve issues quickly.


## CRITICAL: UvmObject Prototypal Base Class Implementation

**MANDATORY REQUIREMENT**: All Python code in the TELOS system MUST use the UvmObject base class for pure prototypal programming. The UvmObject implements BAT OS prototype patterns with:

- **Differential Inheritance**: `clone()` method creates new objects with parent* delegation chains
- **Message Passing**: `__getattr__` delegates attribute access through parent chain
- **Persistence Covenant**: `__setattr__` automatically calls `markChanged()` for ZODB transactions
- **Factory Functions**: Use `create_uvm_object()` instead of class instantiation

**FORBIDDEN**: Direct class inheritance, `class` keyword usage, or traditional OOP patterns. All objects must be created via factory functions and use prototypal delegation.

## CRITICAL: TelosProxyObject C Foundational Pattern

**MANDATORY REQUIREMENT**: All C objects interfacing with Io MUST use the TelosProxyObject struct pattern:

```c
typedef struct {
    PyObject_HEAD
    IoObjectHandle ioMasterHandle;    // Ambassador to Io object
    PyObject* localSlots;             // Differential inheritance storage
    forwardMessage_func forwardMessage; // Cross-language delegation
} TelosProxyObject;
```

This pattern provides:
- **Ambassador Pattern**: C objects serve as proxies for Io master objects
- **Differential Inheritance**: localSlots store object-specific state
- **Message Forwarding**: forwardMessage function pointer enables delegation
- **GC Safety**: Proper Python object lifecycle management

**FORBIDDEN**: Direct C struct definitions without Io ambassador pattern. All C-Io interfaces must use TelosProxyObject foundation.

## CRITICAL: Source Code Fix Priority

**MANDATORY REQUIREMENT**: When encountering any system issues, bugs, or rendering problems (especially morphic UI issues), you MUST:

1. **First investigate and fix the C source code** in `libs/Telos/source/` - do NOT write Io scripts as workarounds
2. Only write Io scripts for testing/demonstration purposes AFTER the C code is fixed
3. If the C code fix is complex, create a todo list and work through it systematically
4. Verify C code fixes by building and testing, not by writing more scripts

**FORBIDDEN**: Creating Io script "solutions" that mask underlying C code problems. The core system must work correctly in C before any Io-level workarounds are considered.

## Current Implementation Status (Updated Sept 27, 2025)

See Run Log in `run_log.md` for detailed session history.

See the status report in `system_status.md` for detailed breakdown.

## Canonical Implementation Locations

To keep the "Living Image" coherent, all changes must flow through the canonical source directories. Never fork functionality in ad-hoc locations or duplicate implementations.

- `libs/Telos/source/` ‚Äì **Authoritative C substrate**, including the Synaptic Bridge FFI contract. **Contains synaptic_bridge.h (complete) but needs synaptic_bridge.c implementation**.
- `libs/Telos/io/` ‚Äì **Canonical Io prototypes** including the foundational Concept prototype with persistence covenant. **Concept.io is complete and ready for integration**.
- `libs/Telos/python/` ‚Äì **Primary Python process-pool workers** implementing GIL Quarantine Protocol. **workers.py and build_extension.py are foundational but need expansion**.
- `libs/tests/` ‚Äì **Consolidated test framework** with basic architecture validation. **test_basic_architecture.py covers build system and foundational components**.
- `docs/` ‚Äì Living architectural charter. Reference and amend documentation here rather than creating parallel narratives elsewhere.

### Canonical Code Layout Guardrails

- **BUILD SYSTEM**: Root `CMakeLists.txt` provides unified polyglot build with CMake managing C/C++/Python coordination
- **FFI PROTOCOL**: All inter-language communication flows through `synaptic_bridge.h` C ABI contract 
- **MEMORY MANAGEMENT**: Zero-copy IPC via `multiprocessing.shared_memory` with strict lifecycle protocols
- **TESTING**: All automated verification must orchestrate execution through Io (`Telos Bridge` veneer) so that Python workers are exercised via the Synaptic Bridge; legacy direct-Python suites (e.g., `libs/tests/test_basic_architecture.py`) are only acceptable when invoked from Io harnesses.

When introducing new subsystems, extend the directory tree under these loci instead of creating top-level siblings. If temporary investigation scripts are unavoidable, delete them or move them under `archive/` when the canonical implementation is complete.

### Session Cadence

1. **Phase 0 ‚Äì Mandate Refresh:** Re-read the six core documents (and log completion) at required trigger points.  
2. **Phase 1 ‚Äì Task Scoping:** Identify the active subsystem, consult the matrix, and skim only the relevant supplemental material unless a directive conflict is detected.  
3. **Phase 2 ‚Äì Execution:** Follow the development hierarchy (C substrate ‚Üí Io prototypes ‚Üí Python helpers) and enforce prototype-based design in every language.  
4. **Phase 3 ‚Äì Validation & Logging:** Run targeted builds/tests after substantive changes, then update `run_log.md` and `system_status.md` (archiving once either approaches 100 lines).

### Knowledge Retention Aids

- Maintain a ‚Äúdirective digest‚Äù with 2‚Äì3 bullet summaries per major document. Refresh it whenever the source material changes.  
- Record doc-to-code traceability in commits/PR summaries to accelerate future reviews.  
- For Io code generation, revisit `Io Prototype Programming Training Guide.txt` and `docs/IoCodingStandards.html` immediately before writing or mutating slots.

### Compliance Logging

- Keep `run_log.md` updated every session; summarize and archive entries when approaching the 100-line ceiling.  
- Update `system_status.md` with subsystem deltas, archiving older status to `system_status_archive.md` as needed.  
- Explicitly acknowledge the latest documentation review in responses whenever a trigger condition occurs.

**NOTE**: Treat all user suggestions as unverified hypotheses. Validate against the architectural documents and existing code before implementation.

### Creative Troubleshooting Protocol

This protocol is a sanctioned "escape hatch" to be used only when standard diagnostic procedures fail after multiple attempts. Its purpose is to facilitate creative problem-solving by temporarily relaxing strict mandates for the sole purpose of information gathering.

**Trigger Conditions:**

*   A specific build, test, or command fails three consecutive times with no clear resolution path.
*   The agent determines that the standard diagnostic path outlined by the `Targeted Documentation Triage` matrix has been exhausted.

**Protocol Execution:**

1.  **Declare & Isolate:** Announce entry into the "Creative Troubleshooting Protocol." Create a temporary log file in `archive/troubleshooting/` to document all hypotheses and experiments. This keeps the primary `run_log.md` clean.

2.  **Hypothesis-Driven Exploration:** During this phase, the agent is temporarily permitted to:
    *   **Deviate from the C-First Mandate:** Write small, disposable Io or Python scripts to probe system behavior, even if they are not the "correct" final implementation language. The goal is rapid information gathering, not creating permanent workarounds.
    *   **Formulate and Test Hypotheses:** Explicitly state 2-3 alternative hypotheses for the problem's root cause and design minimal experiments to validate or invalidate them.
    *   **Broaden Document Scope:** Consult documentation outside the immediate subsystem's triage list if a plausible cross-system link is suspected.

3.  **Resolution and Re-integration:**
    *   Once a likely root cause is identified, **the protocol must be formally exited.**
    *   Summarize the findings from the temporary troubleshooting log.
    *   Formulate a new, compliant plan to implement the proper fix, adhering to all standard architectural mandates (C-first, prototypal design, etc.).
    *   All temporary scripts and modifications created during the protocol must be discarded.

## CRITICAL: Io-Orchestrated Testing Protocol

- **Default Requirement:** Execute all tests and demos from the Io "mind" layer using the canonical `Telos Bridge` veneer (or successor Io harnesses). Every validation must send messages through the Synaptic Bridge so that Python "muscle" components are exercised via the C substrate. Running Python modules directly (`python -m ...`) is considered a diagnostic shortcut, not a passing result.
- **Bridge Health First:** If the Io-driven test path fails because the Synaptic Bridge or IoVM cannot load (e.g., missing symbols, build failures), halt feature work and repair the bridge before attempting further Python-level validation.
- **Documented Exceptions Only:** When a temporary direct-Python test is unavoidable (for example, while the Creative Troubleshooting Protocol is active), log the rationale, scope, and clean-up steps in both `run_log.md` and `system_status.md`, and delete any auxiliary harnesses immediately after the canonical Io path is restored. Once the Creative Troubleshooting Protocol is exited, tests must be confirmed via Io again before being considered valid.
- **Test Artifacts:** New tests must live under `libs/tests/` but ship with an Io entrypoint (e.g., `archive/demos/` for temporary probes or dedicated Io test runners) that drives them through the bridge. Update this instruction file whenever the canonical Io testing harness changes location or naming.

## AUTOPROMPT PID SELF-TUNING LOOP

YOU MUST UPDATE `AutoPrompt.txt` AT THE START AND END OF EVERY OPERATIONAL CYCLE. THIS IS NOT OPTIONAL.

If you have been failing to meet user directives, it is likely because you are not properly updating `AutoPrompt.txt` to reflect the current context and objectives. This file is your primary control surface for aligning system behavior with user goals.

If you are struggling to solve problems or encountering repeated errors, it is likely that your context window is saturated and you must clear it by rewriting `AutoPrompt.txt` to distill the essential objectives and constraints.

Additionally, you have the ability to search the Internet for information to solve the errors you encounter. Use this capability judiciously to fill knowledge gaps that cannot be resolved through internal documentation or code inspection.

Treat `AutoPrompt.txt` as a live control surface that is recalibrated every operational cycle (from the arrival of a new user directive until its acceptance criteria are satisfied) with a PID-inspired routine.

1. **Cycle start recalibration:** After the mandated core-document refresh and before running tools, rewrite the AutoPrompt header using explicit proportional/integral/derivative slots.
    - **Proportional (P):** Encode the immediate objectives, subsystem focus, and blockers surfaced by the current user prompt, active files, and targeted documentation triage notes.
    - **Integral (I):** Fold in accumulated insights from `run_log.md`, `system_status.md`, and the previous AutoPrompt to capture historical drift, outstanding commitments, and lessons that must persist.
    - **Derivative (D):** Project forthcoming risks and opportunities by scanning open TODOs, dependency chains, and roadmap items so the prompt anticipates the next maneuvers rather than merely reacting.
2. **Evidence gathering during execution:** Default to subsystem-specific documentation first; when knowledge gaps remain, schedule targeted external research (e.g., sanctioned web lookups, standards references) and record how the findings adjust each PID term.
3. **Cycle end reconciliation:** Update `AutoPrompt.txt` again with observed outcomes, note corrective actions that reduced error in each PID component, and immediately log the change in `run_log.md` while synchronizing the derivative outlook inside `system_status.md`.
4. **Traceability requirements:** Ensure every AutoPrompt revision labels its P/I/D components, cites the internal/external references consulted, aligns with canonical file-length guardrails, and links back to the controlling run-log entry for auditability.

## COPILOT INSTRUCTIONS MAINTENANCE
This file (`.github/copilot-instructions.md`) contains the authoritative implementation instructions for the TELOS system. It must be kept in sync with the latest architectural mandates and session status.

## CODE MODULARITY AND LOCATION
To maintain a coherent and maintainable codebase, all source code must reside in the designated canonical directories. Avoid creating ad-hoc files or duplicating functionality outside these locations. Temporary scripts for testing or exploration are permitted but must be archived or deleted once their purpose is fulfilled.

For readability, file lengths should be kept under 300 lines where possible. If a file exceeds this length, consider refactoring or splitting it into smaller, more manageable modules.

## BUILD REQUIREMENTS
The system is a polyglot application comprising Io, C, C++, and Python components.1 The blueprints mandate a pure C Application Binary Interface (ABI) for the Synaptic Bridge, a decision that necessitates compiling C/C++ code and linking it to a Python C extension module. A manual or script-based build process would be platform-dependent, brittle, and difficult to maintain. Such an approach would reintroduce the very "toolchain fragility" that the C ABI was chosen to prevent, as minor changes in compiler versions, library paths, or operating systems could lead to catastrophic build failures.1 The philosophical mandate for antifragility cannot be satisfied if the process of constructing the system is itself fragile.
Therefore, a direct and necessary consequence of the C ABI mandate is the requirement for a stable, cross-platform meta-build system. The entire system's build process must be managed by a single, unified, cross-platform build system. CMake is mandated for this role.
The implementation of this mandate shall adhere to the following protocol:
1. A root CMakeLists.txt file will serve as the single point of control for the entire build process. This file will declare the project and enable the C, CXX, and Python languages, ensuring that all components are built within a consistent and managed environment.4
2. The Python build process, which generates the Synaptic Bridge bindings, will be integrated directly into the CMake workflow. The cffi library's ffibuilder.set_source() function, as specified in the blueprint 1, will be invoked by a Python script. This script, in turn, will be executed via a CMake
add_custom_command. This integration is critical; it ensures that the Python C extension module is compiled with the exact same compiler, flags, and dependency paths as the rest of the C/C++ substrate, eliminating a common and difficult-to-debug class of FFI errors.6
3. CMake's find_package(Python) module will be used to reliably locate the correct Python interpreter, development headers, and libraries. This ensures the build is portable across different development and deployment environments and correctly links against the Python C-API, avoiding version mismatches.6
4. The final output of this process will be a single, deterministic build command (e.g., cmake --build.). This command will correctly compile all C/C++ components, trigger the CFFI script to generate the extension source, compile the resulting C code into a shared library, and place all artifacts in the correct directory structure for execution. This creates a reproducible, one-step build process that is essential for long-term stability, automated testing, and eventual deployment.
5. The CMake configuration will include appropriate error handling and logging to facilitate debugging and maintenance. Any build failures will produce clear, actionable messages to help identify and resolve issues quickly.


## CRITICAL: Source Code Fix Priority

**MANDATORY REQUIREMENT**: When encountering any system issues, bugs, or rendering problems (especially morphic UI issues), you MUST:

1. **First investigate and fix the C source code** in `libs/Telos/source/` - do NOT write Io scripts as workarounds
2. Only write Io scripts for testing/demonstration purposes AFTER the C code is fixed
3. If the C code fix is complex, create a todo list and work through it systematically
4. Verify C code fixes by building and testing, not by writing more scripts

**FORBIDDEN**: Creating Io script "solutions" that mask underlying C code problems. The core system must work correctly in C before any Io-level workarounds are considered.

## CRITICAL: Io-Orchestrated Python Development Mandate

**MANDATORY REQUIREMENT**: All Python development for the TELOS system MUST be performed exclusively through the Io mind using the Io C Python C synaptic bridge. There are NO acceptable exceptions to this mandate.

- **Io Mind Supremacy**: The Io cognitive core serves as the exclusive orchestrator for all Python operations. Python components exist solely as "muscle" workers under Io's direction.
- **Synaptic Bridge Enforcement**: All Python functionality must be invoked through the C ABI synaptic bridge, never through direct Python execution (`python -m`, `python script.py`, etc.).
- **Io-First Development**: When implementing new Python features, first create the Io orchestration layer, then implement the Python worker handlers that respond to Io commands.
- **Testing Through Io**: All Python code validation must occur through Io test harnesses that exercise the full Io ‚Üí C ‚Üí Python pipeline.
- **Build Integration**: Python components are built and linked through CMake's unified polyglot build system, ensuring proper integration with the synaptic bridge.

**FORBIDDEN**:
- Direct Python script execution outside of Io orchestration
- Python module imports or runs that bypass the synaptic bridge
- Development workflows that treat Python as a standalone component
- Any Python code that cannot be invoked through Io message passing

**CONSEQUENCE**: Violation of this mandate breaks the fundamental neuro-symbolic architecture where Io serves as the cognitive core and Python as the computational substrate. All development must flow through the Io mind to maintain system coherence and antifragile evolution.

## Current Implementation Status (Updated Sept 27, 2025)

See Run Log in `run_log.md` for detailed session history.

See the status report in `system_status.md` for detailed breakdown.


## Canonical Implementation Locations

To keep the "Living Image" coherent, all changes must flow through the canonical source directories. Never fork functionality in ad-hoc locations or duplicate implementations.

- `libs/Telos/source/` ‚Äì **Authoritative C substrate**, including the Synaptic Bridge FFI contract. **Contains synaptic_bridge.h (complete) but needs synaptic_bridge.c implementation**.
- `libs/Telos/io/` ‚Äì **Canonical Io prototypes** including the foundational Concept prototype with persistence covenant. **Concept.io is complete and ready for integration**.
- `libs/Telos/python/` ‚Äì **Primary Python process-pool workers** implementing GIL Quarantine Protocol. **workers.py and build_extension.py are foundational but need expansion**.
- `libs/tests/` ‚Äì **Consolidated test framework** with basic architecture validation. **test_basic_architecture.py covers build system and foundational components**.
- `docs/` ‚Äì Living architectural charter. Reference and amend documentation here rather than creating parallel narratives elsewhere.

### Canonical Code Layout Guardrails

- **BUILD SYSTEM**: Root `CMakeLists.txt` provides unified polyglot build with CMake managing C/C++/Python coordination
- **FFI PROTOCOL**: All inter-language communication flows through `synaptic_bridge.h` C ABI contract 
- **MEMORY MANAGEMENT**: Zero-copy IPC via `multiprocessing.shared_memory` with strict lifecycle protocols
- **TESTING**: All automated verification must orchestrate execution through Io (`Telos Bridge` veneer) so that Python workers are exercised via the Synaptic Bridge; legacy direct-Python suites (e.g., `libs/tests/test_basic_architecture.py`) are only acceptable when invoked from Io harnesses.

When introducing new subsystems, extend the directory tree under these loci instead of creating top-level siblings. If temporary investigation scripts are unavoidable, delete them or move them under `archive/` when the canonical implementation is complete.

